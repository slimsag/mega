-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

--[[

Graphs memory usage statistics. Expects to receive messages with memory usage
data embedded in a specific set of message fields, which matches the messages
generated by :ref:`config_linux_mem_stats_decoder`: MemFree, Cached, Active,
Inactive, VmallocUsed, Shmem, SwapCached.

Config:

- sec_per_row (uint, optional, default 60)
    Sets the size of each bucket (resolution in seconds) in the sliding
    window.

- rows (uint, optional, default 1440)
    Sets the size of the sliding window i.e., 1440 rows representing 60
    seconds per row is a 24 sliding hour window with 1 minute resolution.

- anomaly_config (string, optional)
    See :ref:`sandbox_anomaly_module`.

- preservation_version (uint, optional, default 0)
    If `preserve_data = true` is set in the SandboxFilter configuration, then
    this value should be incremented every time the `sec_per_row` or `rows`
    configuration is changed to prevent the plugin from failing to start
    during data restoration.

*Example Heka Configuration*

.. code-block:: ini

    [MemoryStatsFilter]
    type = "SandboxFilter"
    filename = "lua_filters/memstats.lua"
    ticker_interval = 60
    preserve_data = true
    message_matcher = "Type == 'stats.memstats'"

--]]
_PRESERVATION_VERSION = read_config("preservation_version") or 0

require "circular_buffer"
require "string"
require "table"
local alert         = require "alert"
local annotation    = require "annotation"
local anomaly       = require "anomaly"

local title             = "Memory Stats"
local rows              = read_config("rows") or 1440
local sec_per_row       = read_config("sec_per_row") or 60
local anomaly_config    = anomaly.parse_config(read_config("anomaly_config"))
annotation.set_prune(title, rows * sec_per_row * 1e9)

local field_names = {"MemFree", "Cached", "Active", "Inactive", "VmallocUsed", "Shmem", "SwapCached"}

-- Handle swap separately. We're going to track SwapFree, and SwapUsed
-- SwapUsed will need to be calcuated.

cbuf = circular_buffer.new(rows, #field_names+2, sec_per_row)

local labels = {}
local SwapFreeCol = #field_names+1
local SwapUsedCol = #field_names+2

for i, name in pairs(field_names) do
    labels[i] = string.format("Fields[%s]", name)
    cbuf:set_header(i, name, "Count", "max")
end

cbuf:set_header(SwapFreeCol, "SwapFree", "Count", "max")
cbuf:set_header(SwapUsedCol, "SwapUsed", "Count", "max")


function process_message ()
    local ts = read_message("Timestamp")
    for i, label in pairs(labels) do
        local val = read_message(label)
        if type(val) ~= "number" then return -1 end
        cbuf:set(ts, i, val)
    end
    local swapFree = read_message("Fields[SwapFree]")
    if type(swapFree) ~= "number" then return -1 end
    local swapTotal = read_message("Fields[SwapTotal]")
    if type(swapTotal) ~= "number" then return -1 end
    local swapUsed = swapTotal - swapFree

    cbuf:set(ts, SwapFreeCol, swapFree)
    cbuf:set(ts, SwapUsedCol, swapUsed)

    return 0
end

function timer_event(ns)
    if anomaly_config then
        if not alert.throttled(ns) then
            local msg, annos = anomaly.detect(ns, title, cbuf, anomaly_config)
            if msg then
                annotation.concat(title, annos)
                alert.send(ns, msg)
            end
        end
        inject_payload("cbuf", title, annotation.prune(title, ns), cbuf)
    else
        inject_payload("cbuf", title, cbuf)
    end
end
