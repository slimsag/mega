diff --git a/third_party/mediapipe/src/mediapipe/calculators/core/packet_resampler_calculator.cc b/third_party/mediapipe/src/mediapipe/calculators/core/packet_resampler_calculator.cc
index 60ec405372e01..b9e2fe4abdf20 100644
--- a/third_party/mediapipe/src/mediapipe/calculators/core/packet_resampler_calculator.cc
+++ b/third_party/mediapipe/src/mediapipe/calculators/core/packet_resampler_calculator.cc
@@ -200,15 +200,15 @@ PacketResamplerCalculator::GetSamplingStrategy(
 
 Timestamp PacketResamplerCalculator::PeriodIndexToTimestamp(
     int64_t index) const {
-  CHECK_EQ(jitter_, 0.0);
-  CHECK_NE(first_timestamp_, Timestamp::Unset());
+  ABSL_CHECK_EQ(jitter_, 0.0);
+  ABSL_CHECK_NE(first_timestamp_, Timestamp::Unset());
   return first_timestamp_ + TimestampDiffFromSeconds(index / frame_rate_);
 }
 
 int64_t PacketResamplerCalculator::TimestampToPeriodIndex(
     Timestamp timestamp) const {
-  CHECK_EQ(jitter_, 0.0);
-  CHECK_NE(first_timestamp_, Timestamp::Unset());
+  ABSL_CHECK_EQ(jitter_, 0.0);
+  ABSL_CHECK_NE(first_timestamp_, Timestamp::Unset());
   return MathUtil::SafeRound<int64_t, double>(
       (timestamp - first_timestamp_).Seconds() * frame_rate_);
 }
@@ -340,8 +340,8 @@ void LegacyJitterWithReflectionStrategy::UpdateNextOutputTimestampWithJitter() {
   next_output_timestamp_ = Timestamp(ReflectBetween(
       next_output_timestamp_.Value(), next_output_timestamp_min_.Value(),
       next_output_timestamp_max_.Value()));
-  CHECK_GE(next_output_timestamp_, next_output_timestamp_min_);
-  CHECK_LT(next_output_timestamp_, next_output_timestamp_max_);
+  ABSL_CHECK_GE(next_output_timestamp_, next_output_timestamp_min_);
+  ABSL_CHECK_LT(next_output_timestamp_, next_output_timestamp_max_);
 }
 
 absl::Status ReproducibleJitterWithReflectionStrategy::Open(
diff --git a/third_party/mediapipe/src/mediapipe/calculators/core/packet_thinner_calculator.cc b/third_party/mediapipe/src/mediapipe/calculators/core/packet_thinner_calculator.cc
index 35cd966ea3173..ecb6ca57f0b3b 100644
--- a/third_party/mediapipe/src/mediapipe/calculators/core/packet_thinner_calculator.cc
+++ b/third_party/mediapipe/src/mediapipe/calculators/core/packet_thinner_calculator.cc
@@ -17,6 +17,7 @@
 #include <cmath>  // for ceil
 #include <memory>
 
+#include "absl/log/absl_check.h"
 #include "mediapipe/calculators/core/packet_thinner_calculator.pb.h"
 #include "mediapipe/framework/calculator_context.h"
 #include "mediapipe/framework/calculator_framework.h"
@@ -177,7 +178,8 @@ absl::Status PacketThinnerCalculator::Open(CalculatorContext* cc) {
   } else {
     period_ = TimestampDiff(options.period());
   }
-  CHECK_LT(TimestampDiff(0), period_) << "Specified period must be positive.";
+  ABSL_CHECK_LT(TimestampDiff(0), period_)
+      << "Specified period must be positive.";
 
   if (options.has_start_time()) {
     start_time_ = Timestamp(options.start_time());
@@ -189,7 +191,7 @@ absl::Status PacketThinnerCalculator::Open(CalculatorContext* cc) {
 
   end_time_ =
       options.has_end_time() ? Timestamp(options.end_time()) : Timestamp::Max();
-  CHECK_LT(start_time_, end_time_)
+  ABSL_CHECK_LT(start_time_, end_time_)
       << "Invalid PacketThinner: start_time must be earlier than end_time";
 
   sync_output_timestamps_ = options.sync_output_timestamps();
@@ -232,7 +234,7 @@ absl::Status PacketThinnerCalculator::Close(CalculatorContext* cc) {
   // Emit any saved packets before quitting.
   if (!saved_packet_.IsEmpty()) {
     // Only sync thinner should have saved packets.
-    CHECK_EQ(PacketThinnerCalculatorOptions::SYNC, thinner_type_);
+    ABSL_CHECK_EQ(PacketThinnerCalculatorOptions::SYNC, thinner_type_);
     if (sync_output_timestamps_) {
       cc->Outputs().Index(0).AddPacket(
           saved_packet_.At(NearestSyncTimestamp(saved_packet_.Timestamp())));
@@ -269,7 +271,7 @@ absl::Status PacketThinnerCalculator::SyncThinnerProcess(
     const Timestamp saved_sync = NearestSyncTimestamp(saved);
     const Timestamp now = cc->InputTimestamp();
     const Timestamp now_sync = NearestSyncTimestamp(now);
-    CHECK_LE(saved_sync, now_sync);
+    ABSL_CHECK_LE(saved_sync, now_sync);
     if (saved_sync == now_sync) {
       // Saved Packet is in same interval as current packet.
       // Replace saved packet with current if it is at least as
@@ -295,7 +297,7 @@ absl::Status PacketThinnerCalculator::SyncThinnerProcess(
 }
 
 Timestamp PacketThinnerCalculator::NearestSyncTimestamp(Timestamp now) const {
-  CHECK_NE(start_time_, Timestamp::Unset())
+  ABSL_CHECK_NE(start_time_, Timestamp::Unset())
       << "Method only valid for sync thinner calculator.";
 
   // Computation is done using int64 arithmetic.  No easy way to avoid
@@ -303,12 +305,12 @@ Timestamp PacketThinnerCalculator::NearestSyncTimestamp(Timestamp now) const {
   const int64_t now64 = now.Value();
   const int64_t start64 = start_time_.Value();
   const int64_t period64 = period_.Value();
-  CHECK_LE(0, period64);
+  ABSL_CHECK_LE(0, period64);
 
   // Round now64 to its closest interval (units of period64).
   int64_t sync64 =
       (now64 - start64 + period64 / 2) / period64 * period64 + start64;
-  CHECK_LE(abs(now64 - sync64), period64 / 2)
+  ABSL_CHECK_LE(abs(now64 - sync64), period64 / 2)
       << "start64: " << start64 << "; now64: " << now64
       << "; sync64: " << sync64;
 
diff --git a/third_party/mediapipe/src/mediapipe/calculators/image/bilateral_filter_calculator.cc b/third_party/mediapipe/src/mediapipe/calculators/image/bilateral_filter_calculator.cc
index 6bb43dc00ee05..5eac351d2582b 100644
--- a/third_party/mediapipe/src/mediapipe/calculators/image/bilateral_filter_calculator.cc
+++ b/third_party/mediapipe/src/mediapipe/calculators/image/bilateral_filter_calculator.cc
@@ -15,6 +15,7 @@
 #include <memory>
 #include <string>
 
+#include "absl/log/absl_check.h"
 #include "absl/strings/str_replace.h"
 #include "mediapipe/calculators/image/bilateral_filter_calculator.pb.h"
 #include "mediapipe/framework/calculator_framework.h"
@@ -112,7 +113,7 @@ class BilateralFilterCalculator : public CalculatorBase {
 REGISTER_CALCULATOR(BilateralFilterCalculator);
 
 absl::Status BilateralFilterCalculator::GetContract(CalculatorContract* cc) {
-  CHECK_GE(cc->Inputs().NumEntries(), 1);
+  ABSL_CHECK_GE(cc->Inputs().NumEntries(), 1);
 
   if (cc->Inputs().HasTag(kInputFrameTag) &&
       cc->Inputs().HasTag(kInputFrameTagGpu)) {
@@ -183,8 +184,8 @@ absl::Status BilateralFilterCalculator::Open(CalculatorContext* cc) {
 
   sigma_color_ = options_.sigma_color();
   sigma_space_ = options_.sigma_space();
-  CHECK_GE(sigma_color_, 0.0);
-  CHECK_GE(sigma_space_, 0.0);
+  ABSL_CHECK_GE(sigma_color_, 0.0);
+  ABSL_CHECK_GE(sigma_space_, 0.0);
   if (!use_gpu_) sigma_color_ *= 255.0;
 
   if (use_gpu_) {
diff --git a/third_party/mediapipe/src/mediapipe/calculators/image/opencv_image_encoder_calculator.cc b/third_party/mediapipe/src/mediapipe/calculators/image/opencv_image_encoder_calculator.cc
index 93ec9435f1af4..0308b9b8c4af8 100644
--- a/third_party/mediapipe/src/mediapipe/calculators/image/opencv_image_encoder_calculator.cc
+++ b/third_party/mediapipe/src/mediapipe/calculators/image/opencv_image_encoder_calculator.cc
@@ -12,6 +12,7 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
+#include "absl/log/absl_check.h"
 #include "mediapipe/calculators/image/opencv_image_encoder_calculator.pb.h"
 #include "mediapipe/framework/calculator_framework.h"
 #include "mediapipe/framework/formats/image_frame_opencv.h"
@@ -61,7 +62,7 @@ absl::Status OpenCvImageEncoderCalculator::Open(CalculatorContext* cc) {
 
 absl::Status OpenCvImageEncoderCalculator::Process(CalculatorContext* cc) {
   const ImageFrame& image_frame = cc->Inputs().Index(0).Get<ImageFrame>();
-  CHECK_EQ(1, image_frame.ByteDepth());
+  ABSL_CHECK_EQ(1, image_frame.ByteDepth());
 
   std::unique_ptr<OpenCvImageEncoderCalculatorResults> encoded_result =
       absl::make_unique<OpenCvImageEncoderCalculatorResults>();
diff --git a/third_party/mediapipe/src/mediapipe/calculators/image/scale_image_calculator.cc b/third_party/mediapipe/src/mediapipe/calculators/image/scale_image_calculator.cc
index d8a3cb93ba583..128aa424fbe1a 100644
--- a/third_party/mediapipe/src/mediapipe/calculators/image/scale_image_calculator.cc
+++ b/third_party/mediapipe/src/mediapipe/calculators/image/scale_image_calculator.cc
@@ -18,6 +18,7 @@
 #include <memory>
 #include <string>
 
+#include "absl/log/absl_check.h"
 #include "absl/strings/str_cat.h"
 #include "absl/strings/substitute.h"
 #include "libyuv/scale.h"
@@ -507,7 +508,7 @@ absl::Status ScaleImageCalculator::ValidateImageFrame(
 
 absl::Status ScaleImageCalculator::ValidateYUVImage(CalculatorContext* cc,
                                                     const YUVImage& yuv_image) {
-  CHECK_EQ(input_format_, ImageFormat::YCBCR420P);
+  ABSL_CHECK_EQ(input_format_, ImageFormat::YCBCR420P);
   if (!has_header_) {
     if (input_width_ != yuv_image.width() ||
         input_height_ != yuv_image.height()) {
diff --git a/third_party/mediapipe/src/mediapipe/calculators/image/scale_image_utils.cc b/third_party/mediapipe/src/mediapipe/calculators/image/scale_image_utils.cc
index 86a53ffc5eb65..e119a876a89d4 100644
--- a/third_party/mediapipe/src/mediapipe/calculators/image/scale_image_utils.cc
+++ b/third_party/mediapipe/src/mediapipe/calculators/image/scale_image_utils.cc
@@ -18,6 +18,7 @@
 
 #include <string>
 
+#include "absl/log/absl_check.h"
 #include "absl/strings/str_split.h"
 #include "mediapipe/framework/port/logging.h"
 #include "mediapipe/framework/port/ret_check.h"
@@ -83,8 +84,8 @@ absl::Status FindCropDimensions(int input_width, int input_height,    //
     }
   }
 
-  CHECK_LE(*crop_width, input_width);
-  CHECK_LE(*crop_height, input_height);
+  ABSL_CHECK_LE(*crop_width, input_width);
+  ABSL_CHECK_LE(*crop_height, input_height);
   return absl::OkStatus();
 }
 
diff --git a/third_party/mediapipe/src/mediapipe/calculators/image/segmentation_smoothing_calculator.cc b/third_party/mediapipe/src/mediapipe/calculators/image/segmentation_smoothing_calculator.cc
index 81732f9044f38..9b4a262913215 100644
--- a/third_party/mediapipe/src/mediapipe/calculators/image/segmentation_smoothing_calculator.cc
+++ b/third_party/mediapipe/src/mediapipe/calculators/image/segmentation_smoothing_calculator.cc
@@ -32,6 +32,7 @@
 #endif  // !MEDIAPIPE_DISABLE_GPU
 
 #if !MEDIAPIPE_DISABLE_OPENCV
+#include "absl/log/absl_check.h"
 #include "mediapipe/framework/formats/image_frame_opencv.h"
 #include "mediapipe/framework/formats/image_opencv.h"
 #include "mediapipe/framework/port/opencv_core_inc.h"
@@ -110,7 +111,7 @@ REGISTER_CALCULATOR(SegmentationSmoothingCalculator);
 
 absl::Status SegmentationSmoothingCalculator::GetContract(
     CalculatorContract* cc) {
-  CHECK_GE(cc->Inputs().NumEntries(), 1);
+  ABSL_CHECK_GE(cc->Inputs().NumEntries(), 1);
 
   cc->Inputs().Tag(kCurrentMaskTag).Set<Image>();
   cc->Inputs().Tag(kPreviousMaskTag).Set<Image>();
diff --git a/third_party/mediapipe/src/mediapipe/calculators/image/set_alpha_calculator.cc b/third_party/mediapipe/src/mediapipe/calculators/image/set_alpha_calculator.cc
index e20621e8d7489..211c2840100e2 100644
--- a/third_party/mediapipe/src/mediapipe/calculators/image/set_alpha_calculator.cc
+++ b/third_party/mediapipe/src/mediapipe/calculators/image/set_alpha_calculator.cc
@@ -14,6 +14,7 @@
 
 #include <memory>
 
+#include "absl/log/absl_check.h"
 #include "mediapipe/calculators/image/set_alpha_calculator.pb.h"
 #include "mediapipe/framework/calculator_framework.h"
 #include "mediapipe/framework/calculator_options.pb.h"
@@ -142,7 +143,7 @@ class SetAlphaCalculator : public CalculatorBase {
 REGISTER_CALCULATOR(SetAlphaCalculator);
 
 absl::Status SetAlphaCalculator::GetContract(CalculatorContract* cc) {
-  CHECK_GE(cc->Inputs().NumEntries(), 1);
+  ABSL_CHECK_GE(cc->Inputs().NumEntries(), 1);
 
   bool use_gpu = false;
 
diff --git a/third_party/mediapipe/src/mediapipe/calculators/tensor/audio_to_tensor_calculator.cc b/third_party/mediapipe/src/mediapipe/calculators/tensor/audio_to_tensor_calculator.cc
index 01cc60a154439..e8c9a6c65f753 100644
--- a/third_party/mediapipe/src/mediapipe/calculators/tensor/audio_to_tensor_calculator.cc
+++ b/third_party/mediapipe/src/mediapipe/calculators/tensor/audio_to_tensor_calculator.cc
@@ -20,6 +20,7 @@
 #include <utility>
 #include <vector>
 
+#include "absl/log/absl_check.h"
 #include "absl/memory/memory.h"
 #include "absl/status/status.h"
 #include "absl/status/statusor.h"
@@ -457,7 +458,7 @@ absl::Status AudioToTensorCalculator::SetupStreamingResampler(
 }
 
 void AudioToTensorCalculator::AppendZerosToSampleBuffer(int num_samples) {
-  CHECK_GE(num_samples, 0);  // Ensured by `UpdateContract`.
+  ABSL_CHECK_GE(num_samples, 0);  // Ensured by `UpdateContract`.
   if (num_samples == 0) {
     return;
   }
diff --git a/third_party/mediapipe/src/mediapipe/calculators/tensor/tensor_converter_calculator.cc b/third_party/mediapipe/src/mediapipe/calculators/tensor/tensor_converter_calculator.cc
index c1bd92968eb2f..a9606e653f1a0 100644
--- a/third_party/mediapipe/src/mediapipe/calculators/tensor/tensor_converter_calculator.cc
+++ b/third_party/mediapipe/src/mediapipe/calculators/tensor/tensor_converter_calculator.cc
@@ -15,6 +15,7 @@
 #include <string>
 #include <vector>
 
+#include "absl/log/absl_check.h"
 #include "mediapipe/calculators/tensor/tensor_converter_calculator.pb.h"
 #include "mediapipe/framework/calculator_framework.h"
 #include "mediapipe/framework/formats/image_frame.h"
@@ -582,7 +583,7 @@ absl::Status TensorConverterCalculator::LoadOptions(CalculatorContext* cc) {
   if (options.has_output_tensor_float_range()) {
     output_range_.emplace(options.output_tensor_float_range().min(),
                           options.output_tensor_float_range().max());
-    CHECK_GT(output_range_->second, output_range_->first);
+    ABSL_CHECK_GT(output_range_->second, output_range_->first);
   }
 
   // Custom div and sub values.
@@ -600,9 +601,9 @@ absl::Status TensorConverterCalculator::LoadOptions(CalculatorContext* cc) {
 
   // Get desired way to handle input channels.
   max_num_channels_ = options.max_num_channels();
-  CHECK_GE(max_num_channels_, 1);
-  CHECK_LE(max_num_channels_, 4);
-  CHECK_NE(max_num_channels_, 2);
+  ABSL_CHECK_GE(max_num_channels_, 1);
+  ABSL_CHECK_LE(max_num_channels_, 4);
+  ABSL_CHECK_NE(max_num_channels_, 2);
   return absl::OkStatus();
 }
 
diff --git a/third_party/mediapipe/src/mediapipe/calculators/tensor/tensors_to_detections_calculator.cc b/third_party/mediapipe/src/mediapipe/calculators/tensor/tensors_to_detections_calculator.cc
index 246269de10efa..3e19ae5bee365 100644
--- a/third_party/mediapipe/src/mediapipe/calculators/tensor/tensors_to_detections_calculator.cc
+++ b/third_party/mediapipe/src/mediapipe/calculators/tensor/tensors_to_detections_calculator.cc
@@ -15,6 +15,7 @@
 #include <unordered_map>
 #include <vector>
 
+#include "absl/log/absl_check.h"
 #include "absl/strings/str_format.h"
 #include "absl/types/span.h"
 #include "mediapipe/calculators/tensor/tensors_to_detections_calculator.pb.h"
@@ -83,7 +84,7 @@ void ConvertRawValuesToAnchors(const float* raw_anchors, int num_boxes,
 
 void ConvertAnchorsToRawValues(const std::vector<Anchor>& anchors,
                                int num_boxes, float* raw_anchors) {
-  CHECK_EQ(anchors.size(), num_boxes);
+  ABSL_CHECK_EQ(anchors.size(), num_boxes);
   int box = 0;
   for (const auto& anchor : anchors) {
     raw_anchors[box * kNumCoordsPerBox + 0] = anchor.y_center();
@@ -703,18 +704,18 @@ absl::Status TensorsToDetectionsCalculator::LoadOptions(CalculatorContext* cc) {
   num_boxes_ = options_.num_boxes();
   num_coords_ = options_.num_coords();
   box_output_format_ = GetBoxFormat(options_);
-  CHECK_NE(options_.max_results(), 0)
+  ABSL_CHECK_NE(options_.max_results(), 0)
       << "The maximum number of the top-scored detection results must be "
          "non-zero.";
   max_results_ = options_.max_results();
 
   // Currently only support 2D when num_values_per_keypoint equals to 2.
-  CHECK_EQ(options_.num_values_per_keypoint(), 2);
+  ABSL_CHECK_EQ(options_.num_values_per_keypoint(), 2);
 
   // Check if the output size is equal to the requested boxes and keypoints.
-  CHECK_EQ(options_.num_keypoints() * options_.num_values_per_keypoint() +
-               kNumCoordsPerBox,
-           num_coords_);
+  ABSL_CHECK_EQ(options_.num_keypoints() * options_.num_values_per_keypoint() +
+                    kNumCoordsPerBox,
+                num_coords_);
 
   if (kSideInIgnoreClasses(cc).IsConnected()) {
     RET_CHECK(!kSideInIgnoreClasses(cc).IsEmpty());
@@ -1154,11 +1155,12 @@ void main() {
     }
     // TODO support better filtering.
     if (class_index_set_.is_allowlist) {
-      CHECK_EQ(class_index_set_.values.size(),
-               IsClassIndexAllowed(0) ? num_classes_ : num_classes_ - 1)
+      ABSL_CHECK_EQ(class_index_set_.values.size(),
+                    IsClassIndexAllowed(0) ? num_classes_ : num_classes_ - 1)
           << "Only all classes  >= class 0  or  >= class 1";
     } else {
-      CHECK_EQ(class_index_set_.values.size(), IsClassIndexAllowed(0) ? 0 : 1)
+      ABSL_CHECK_EQ(class_index_set_.values.size(),
+                    IsClassIndexAllowed(0) ? 0 : 1)
           << "Only ignore class 0 is allowed";
     }
 
@@ -1379,11 +1381,12 @@ kernel void scoreKernel(
 
   // TODO support better filtering.
   if (class_index_set_.is_allowlist) {
-    CHECK_EQ(class_index_set_.values.size(),
-             IsClassIndexAllowed(0) ? num_classes_ : num_classes_ - 1)
+    ABSL_CHECK_EQ(class_index_set_.values.size(),
+                  IsClassIndexAllowed(0) ? num_classes_ : num_classes_ - 1)
         << "Only all classes  >= class 0  or  >= class 1";
   } else {
-    CHECK_EQ(class_index_set_.values.size(), IsClassIndexAllowed(0) ? 0 : 1)
+    ABSL_CHECK_EQ(class_index_set_.values.size(),
+                  IsClassIndexAllowed(0) ? 0 : 1)
         << "Only ignore class 0 is allowed";
   }
 
diff --git a/third_party/mediapipe/src/mediapipe/calculators/tensor/tensors_to_landmarks_calculator.cc b/third_party/mediapipe/src/mediapipe/calculators/tensor/tensors_to_landmarks_calculator.cc
index a1cc4e202a49f..cfee6bad0a535 100644
--- a/third_party/mediapipe/src/mediapipe/calculators/tensor/tensors_to_landmarks_calculator.cc
+++ b/third_party/mediapipe/src/mediapipe/calculators/tensor/tensors_to_landmarks_calculator.cc
@@ -12,6 +12,7 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
+#include "absl/log/absl_check.h"
 #include "mediapipe/calculators/tensor/tensors_to_landmarks_calculator.pb.h"
 #include "mediapipe/framework/api2/node.h"
 #include "mediapipe/framework/calculator_framework.h"
@@ -142,7 +143,7 @@ absl::Status TensorsToLandmarksCalculator::Process(CalculatorContext* cc) {
   RET_CHECK(input_tensors[0].element_type() == Tensor::ElementType::kFloat32);
   int num_values = input_tensors[0].shape().num_elements();
   const int num_dimensions = num_values / num_landmarks_;
-  CHECK_GT(num_dimensions, 0);
+  ABSL_CHECK_GT(num_dimensions, 0);
 
   auto view = input_tensors[0].GetCpuReadView();
   auto raw_landmarks = view.buffer<float>();
diff --git a/third_party/mediapipe/src/mediapipe/calculators/tensorflow/vector_int_to_tensor_calculator.cc b/third_party/mediapipe/src/mediapipe/calculators/tensorflow/vector_int_to_tensor_calculator.cc
index cb90276aee6cd..04c3ba117979e 100644
--- a/third_party/mediapipe/src/mediapipe/calculators/tensorflow/vector_int_to_tensor_calculator.cc
+++ b/third_party/mediapipe/src/mediapipe/calculators/tensorflow/vector_int_to_tensor_calculator.cc
@@ -15,6 +15,7 @@
 // Converts a single int or vector<int> or vector<vector<int>> to 1D (or 2D)
 // tf::Tensor.
 
+#include "absl/log/absl_check.h"
 #include "mediapipe/calculators/tensorflow/vector_int_to_tensor_calculator_options.pb.h"
 #include "mediapipe/framework/calculator_framework.h"
 #include "mediapipe/framework/port/ret_check.h"
@@ -113,11 +114,11 @@ absl::Status VectorIntToTensorCalculator::Process(CalculatorContext* cc) {
             .Get<std::vector<std::vector<int>>>();
 
     const int32_t rows = input.size();
-    CHECK_GE(rows, 1);
+    ABSL_CHECK_GE(rows, 1);
     const int32_t cols = input[0].size();
-    CHECK_GE(cols, 1);
+    ABSL_CHECK_GE(cols, 1);
     for (int i = 1; i < rows; ++i) {
-      CHECK_EQ(input[i].size(), cols);
+      ABSL_CHECK_EQ(input[i].size(), cols);
     }
     if (options_.transpose()) {
       tensor_shape = tf::TensorShape({cols, rows});
@@ -171,7 +172,7 @@ absl::Status VectorIntToTensorCalculator::Process(CalculatorContext* cc) {
     } else {
       input = cc->Inputs().Tag(kVectorInt).Value().Get<std::vector<int>>();
     }
-    CHECK_GE(input.size(), 1);
+    ABSL_CHECK_GE(input.size(), 1);
     const int32_t length = input.size();
     tensor_shape = tf::TensorShape({length});
     auto output = ::absl::make_unique<tf::Tensor>(options_.tensor_data_type(),
diff --git a/third_party/mediapipe/src/mediapipe/calculators/tflite/ssd_anchors_calculator.cc b/third_party/mediapipe/src/mediapipe/calculators/tflite/ssd_anchors_calculator.cc
index 5ed5a95dcaecd..e56765d94d784 100644
--- a/third_party/mediapipe/src/mediapipe/calculators/tflite/ssd_anchors_calculator.cc
+++ b/third_party/mediapipe/src/mediapipe/calculators/tflite/ssd_anchors_calculator.cc
@@ -16,6 +16,7 @@
 #include <utility>
 #include <vector>
 
+#include "absl/log/absl_check.h"
 #include "mediapipe/calculators/tflite/ssd_anchors_calculator.pb.h"
 #include "mediapipe/framework/calculator_framework.h"
 #include "mediapipe/framework/formats/object_detection/anchor.pb.h"
@@ -274,11 +275,11 @@ absl::Status SsdAnchorsCalculator::GenerateAnchors(
     if (options.strides_size()) {
       LOG(ERROR) << "Found feature map shapes. Strides will be ignored.";
     }
-    CHECK_EQ(options.feature_map_height_size(), kNumLayers);
-    CHECK_EQ(options.feature_map_height_size(),
-             options.feature_map_width_size());
+    ABSL_CHECK_EQ(options.feature_map_height_size(), kNumLayers);
+    ABSL_CHECK_EQ(options.feature_map_height_size(),
+                  options.feature_map_width_size());
   } else {
-    CHECK_EQ(options.strides_size(), kNumLayers);
+    ABSL_CHECK_EQ(options.strides_size(), kNumLayers);
   }
 
   if (options.multiscale_anchor_generation()) {
diff --git a/third_party/mediapipe/src/mediapipe/calculators/tflite/tflite_converter_calculator.cc b/third_party/mediapipe/src/mediapipe/calculators/tflite/tflite_converter_calculator.cc
index ff6b2ff91b2ee..7188cbc591c8f 100644
--- a/third_party/mediapipe/src/mediapipe/calculators/tflite/tflite_converter_calculator.cc
+++ b/third_party/mediapipe/src/mediapipe/calculators/tflite/tflite_converter_calculator.cc
@@ -15,6 +15,7 @@
 #include <string>
 #include <vector>
 
+#include "absl/log/absl_check.h"
 #include "mediapipe/calculators/tflite/tflite_converter_calculator.pb.h"
 #include "mediapipe/framework/calculator_framework.h"
 #include "mediapipe/framework/formats/image_frame.h"
@@ -643,7 +644,7 @@ absl::Status TfLiteConverterCalculator::LoadOptions(CalculatorContext* cc) {
   if (options.has_output_tensor_float_range()) {
     output_range_.emplace(options.output_tensor_float_range().min(),
                           options.output_tensor_float_range().max());
-    CHECK_GT(output_range_->second, output_range_->first);
+    ABSL_CHECK_GT(output_range_->second, output_range_->first);
   }
 
   // Custom div and sub values.
@@ -661,9 +662,9 @@ absl::Status TfLiteConverterCalculator::LoadOptions(CalculatorContext* cc) {
 
   // Get desired way to handle input channels.
   max_num_channels_ = options.max_num_channels();
-  CHECK_GE(max_num_channels_, 1);
-  CHECK_LE(max_num_channels_, 4);
-  CHECK_NE(max_num_channels_, 2);
+  ABSL_CHECK_GE(max_num_channels_, 1);
+  ABSL_CHECK_LE(max_num_channels_, 4);
+  ABSL_CHECK_NE(max_num_channels_, 2);
 #if defined(MEDIAPIPE_IOS)
   if (cc->Inputs().HasTag(kGpuBufferTag))
     // Currently on iOS, tflite gpu input tensor must be 4 channels,
diff --git a/third_party/mediapipe/src/mediapipe/calculators/tflite/tflite_inference_calculator.cc b/third_party/mediapipe/src/mediapipe/calculators/tflite/tflite_inference_calculator.cc
index add9bb1a81668..4b89133236b54 100644
--- a/third_party/mediapipe/src/mediapipe/calculators/tflite/tflite_inference_calculator.cc
+++ b/third_party/mediapipe/src/mediapipe/calculators/tflite/tflite_inference_calculator.cc
@@ -17,6 +17,7 @@
 #include <string>
 #include <vector>
 
+#include "absl/log/absl_check.h"
 #include "absl/memory/memory.h"
 #include "mediapipe/calculators/tflite/tflite_inference_calculator.pb.h"
 #include "mediapipe/framework/calculator_framework.h"
@@ -109,8 +110,8 @@ std::unique_ptr<tflite::Interpreter> BuildEdgeTpuInterpreter(
     edgetpu::EdgeTpuContext* edgetpu_context) {
   resolver->AddCustom(edgetpu::kCustomOp, edgetpu::RegisterCustomOp());
   std::unique_ptr<tflite::Interpreter> interpreter;
-  CHECK_EQ(tflite::InterpreterBuilder(model, *resolver)(&interpreter),
-           kTfLiteOk);
+  ABSL_CHECK_EQ(tflite::InterpreterBuilder(model, *resolver)(&interpreter),
+                kTfLiteOk);
   interpreter->SetExternalContext(kTfLiteEdgeTpuContext, edgetpu_context);
   return interpreter;
 }
diff --git a/third_party/mediapipe/src/mediapipe/calculators/tflite/tflite_tensors_to_classification_calculator.cc b/third_party/mediapipe/src/mediapipe/calculators/tflite/tflite_tensors_to_classification_calculator.cc
index 4d28b91e9263c..98ab4b1da12d1 100644
--- a/third_party/mediapipe/src/mediapipe/calculators/tflite/tflite_tensors_to_classification_calculator.cc
+++ b/third_party/mediapipe/src/mediapipe/calculators/tflite/tflite_tensors_to_classification_calculator.cc
@@ -17,6 +17,7 @@
 #include <vector>
 
 #include "absl/container/node_hash_map.h"
+#include "absl/log/absl_check.h"
 #include "absl/strings/str_format.h"
 #include "absl/types/span.h"
 #include "mediapipe/calculators/tflite/tflite_tensors_to_classification_calculator.pb.h"
@@ -172,7 +173,7 @@ absl::Status TfLiteTensorsToClassificationCalculator::Process(
 
   // Note that partial_sort will raise error when top_k_ >
   // classification_list->classification_size().
-  CHECK_GE(classification_list->classification_size(), top_k_);
+  ABSL_CHECK_GE(classification_list->classification_size(), top_k_);
   auto raw_classification_list = classification_list->mutable_classification();
   if (top_k_ > 0 && classification_list->classification_size() >= top_k_) {
     std::partial_sort(raw_classification_list->begin(),
diff --git a/third_party/mediapipe/src/mediapipe/calculators/tflite/tflite_tensors_to_detections_calculator.cc b/third_party/mediapipe/src/mediapipe/calculators/tflite/tflite_tensors_to_detections_calculator.cc
index 2ed62c46d4505..2d91f54252ecb 100644
--- a/third_party/mediapipe/src/mediapipe/calculators/tflite/tflite_tensors_to_detections_calculator.cc
+++ b/third_party/mediapipe/src/mediapipe/calculators/tflite/tflite_tensors_to_detections_calculator.cc
@@ -15,6 +15,7 @@
 #include <unordered_map>
 #include <vector>
 
+#include "absl/log/absl_check.h"
 #include "absl/strings/str_format.h"
 #include "absl/types/span.h"
 #include "mediapipe/calculators/tflite/tflite_tensors_to_detections_calculator.pb.h"
@@ -93,7 +94,7 @@ void ConvertRawValuesToAnchors(const float* raw_anchors, int num_boxes,
 
 void ConvertAnchorsToRawValues(const std::vector<Anchor>& anchors,
                                int num_boxes, float* raw_anchors) {
-  CHECK_EQ(anchors.size(), num_boxes);
+  ABSL_CHECK_EQ(anchors.size(), num_boxes);
   int box = 0;
   for (const auto& anchor : anchors) {
     raw_anchors[box * kNumCoordsPerBox + 0] = anchor.y_center();
@@ -288,14 +289,14 @@ absl::Status TfLiteTensorsToDetectionsCalculator::ProcessCPU(
     const TfLiteTensor* raw_score_tensor = &input_tensors[1];
 
     // TODO: Add flexible input tensor size handling.
-    CHECK_EQ(raw_box_tensor->dims->size, 3);
-    CHECK_EQ(raw_box_tensor->dims->data[0], 1);
-    CHECK_EQ(raw_box_tensor->dims->data[1], num_boxes_);
-    CHECK_EQ(raw_box_tensor->dims->data[2], num_coords_);
-    CHECK_EQ(raw_score_tensor->dims->size, 3);
-    CHECK_EQ(raw_score_tensor->dims->data[0], 1);
-    CHECK_EQ(raw_score_tensor->dims->data[1], num_boxes_);
-    CHECK_EQ(raw_score_tensor->dims->data[2], num_classes_);
+    ABSL_CHECK_EQ(raw_box_tensor->dims->size, 3);
+    ABSL_CHECK_EQ(raw_box_tensor->dims->data[0], 1);
+    ABSL_CHECK_EQ(raw_box_tensor->dims->data[1], num_boxes_);
+    ABSL_CHECK_EQ(raw_box_tensor->dims->data[2], num_coords_);
+    ABSL_CHECK_EQ(raw_score_tensor->dims->size, 3);
+    ABSL_CHECK_EQ(raw_score_tensor->dims->data[0], 1);
+    ABSL_CHECK_EQ(raw_score_tensor->dims->data[1], num_boxes_);
+    ABSL_CHECK_EQ(raw_score_tensor->dims->data[2], num_classes_);
     const float* raw_boxes = raw_box_tensor->data.f;
     const float* raw_scores = raw_score_tensor->data.f;
 
@@ -303,9 +304,9 @@ absl::Status TfLiteTensorsToDetectionsCalculator::ProcessCPU(
     if (!anchors_init_) {
       if (input_tensors.size() == kNumInputTensorsWithAnchors) {
         const TfLiteTensor* anchor_tensor = &input_tensors[2];
-        CHECK_EQ(anchor_tensor->dims->size, 2);
-        CHECK_EQ(anchor_tensor->dims->data[0], num_boxes_);
-        CHECK_EQ(anchor_tensor->dims->data[1], kNumCoordsPerBox);
+        ABSL_CHECK_EQ(anchor_tensor->dims->size, 2);
+        ABSL_CHECK_EQ(anchor_tensor->dims->data[0], num_boxes_);
+        ABSL_CHECK_EQ(anchor_tensor->dims->data[1], kNumCoordsPerBox);
         const float* raw_anchors = anchor_tensor->data.f;
         ConvertRawValuesToAnchors(raw_anchors, num_boxes_, &anchors_);
       } else if (side_packet_anchors_) {
@@ -417,7 +418,7 @@ absl::Status TfLiteTensorsToDetectionsCalculator::ProcessGPU(
         MP_RETURN_IF_ERROR(gpu_data_->raw_anchors_buffer.Write<float>(
             absl::MakeSpan(raw_anchors)));
       } else {
-        CHECK_EQ(input_tensors.size(), kNumInputTensorsWithAnchors);
+        ABSL_CHECK_EQ(input_tensors.size(), kNumInputTensorsWithAnchors);
         MP_RETURN_IF_ERROR(
             CopyBuffer(input_tensors[2], gpu_data_->raw_anchors_buffer));
       }
@@ -567,12 +568,12 @@ absl::Status TfLiteTensorsToDetectionsCalculator::LoadOptions(
   num_coords_ = options_.num_coords();
 
   // Currently only support 2D when num_values_per_keypoint equals to 2.
-  CHECK_EQ(options_.num_values_per_keypoint(), 2);
+  ABSL_CHECK_EQ(options_.num_values_per_keypoint(), 2);
 
   // Check if the output size is equal to the requested boxes and keypoints.
-  CHECK_EQ(options_.num_keypoints() * options_.num_values_per_keypoint() +
-               kNumCoordsPerBox,
-           num_coords_);
+  ABSL_CHECK_EQ(options_.num_keypoints() * options_.num_values_per_keypoint() +
+                    kNumCoordsPerBox,
+                num_coords_);
 
   for (int i = 0; i < options_.ignore_classes_size(); ++i) {
     ignore_classes_.insert(options_.ignore_classes(i));
@@ -897,10 +898,11 @@ void main() {
     int max_wg_size;  //  typically <= 1024
     glGetIntegeri_v(GL_MAX_COMPUTE_WORK_GROUP_SIZE, 1,
                     &max_wg_size);  // y-dim
-    CHECK_LT(num_classes_, max_wg_size)
+    ABSL_CHECK_LT(num_classes_, max_wg_size)
         << "# classes must be < " << max_wg_size;
     // TODO support better filtering.
-    CHECK_LE(ignore_classes_.size(), 1) << "Only ignore class 0 is allowed";
+    ABSL_CHECK_LE(ignore_classes_.size(), 1)
+        << "Only ignore class 0 is allowed";
 
     // Shader program
     GlShader score_shader;
@@ -1115,7 +1117,7 @@ kernel void scoreKernel(
       ignore_classes_.size() ? 1 : 0);
 
   // TODO support better filtering.
-  CHECK_LE(ignore_classes_.size(), 1) << "Only ignore class 0 is allowed";
+  ABSL_CHECK_LE(ignore_classes_.size(), 1) << "Only ignore class 0 is allowed";
 
   {
     // Shader program
@@ -1147,7 +1149,8 @@ kernel void scoreKernel(
                             options:MTLResourceStorageModeShared];
     // # filter classes supported is hardware dependent.
     int max_wg_size = gpu_data_->score_program.maxTotalThreadsPerThreadgroup;
-    CHECK_LT(num_classes_, max_wg_size) << "# classes must be <" << max_wg_size;
+    ABSL_CHECK_LT(num_classes_, max_wg_size)
+        << "# classes must be <" << max_wg_size;
   }
 
 #endif  // MEDIAPIPE_TFLITE_GL_INFERENCE
diff --git a/third_party/mediapipe/src/mediapipe/calculators/tflite/tflite_tensors_to_landmarks_calculator.cc b/third_party/mediapipe/src/mediapipe/calculators/tflite/tflite_tensors_to_landmarks_calculator.cc
index 1be83bbe14d30..6740f0afa5989 100644
--- a/third_party/mediapipe/src/mediapipe/calculators/tflite/tflite_tensors_to_landmarks_calculator.cc
+++ b/third_party/mediapipe/src/mediapipe/calculators/tflite/tflite_tensors_to_landmarks_calculator.cc
@@ -12,6 +12,7 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
+#include "absl/log/absl_check.h"
 #include "mediapipe/calculators/tflite/tflite_tensors_to_landmarks_calculator.pb.h"
 #include "mediapipe/framework/calculator_framework.h"
 #include "mediapipe/framework/formats/landmark.pb.h"
@@ -199,7 +200,7 @@ absl::Status TfLiteTensorsToLandmarksCalculator::Process(
     num_values *= raw_tensor->dims->data[i];
   }
   const int num_dimensions = num_values / num_landmarks_;
-  CHECK_GT(num_dimensions, 0);
+  ABSL_CHECK_GT(num_dimensions, 0);
 
   const float* raw_landmarks = raw_tensor->data.f;
 
diff --git a/third_party/mediapipe/src/mediapipe/calculators/util/annotation_overlay_calculator.cc b/third_party/mediapipe/src/mediapipe/calculators/util/annotation_overlay_calculator.cc
index 34093702ca789..fbd24ee3b95af 100644
--- a/third_party/mediapipe/src/mediapipe/calculators/util/annotation_overlay_calculator.cc
+++ b/third_party/mediapipe/src/mediapipe/calculators/util/annotation_overlay_calculator.cc
@@ -14,6 +14,7 @@
 
 #include <memory>
 
+#include "absl/log/absl_check.h"
 #include "absl/strings/str_cat.h"
 #include "mediapipe/calculators/util/annotation_overlay_calculator.pb.h"
 #include "mediapipe/framework/calculator_framework.h"
@@ -172,7 +173,7 @@ class AnnotationOverlayCalculator : public CalculatorBase {
 REGISTER_CALCULATOR(AnnotationOverlayCalculator);
 
 absl::Status AnnotationOverlayCalculator::GetContract(CalculatorContract* cc) {
-  CHECK_GE(cc->Inputs().NumEntries(), 1);
+  ABSL_CHECK_GE(cc->Inputs().NumEntries(), 1);
 
   bool use_gpu = false;
 
diff --git a/third_party/mediapipe/src/mediapipe/calculators/util/association_calculator.h b/third_party/mediapipe/src/mediapipe/calculators/util/association_calculator.h
index 037ea838c7688..1cec63c80c31e 100644
--- a/third_party/mediapipe/src/mediapipe/calculators/util/association_calculator.h
+++ b/third_party/mediapipe/src/mediapipe/calculators/util/association_calculator.h
@@ -18,6 +18,7 @@
 #include <memory>
 #include <vector>
 
+#include "absl/log/absl_check.h"
 #include "absl/memory/memory.h"
 #include "mediapipe/calculators/util/association_calculator.pb.h"
 #include "mediapipe/framework/calculator_context.h"
@@ -72,7 +73,7 @@ class AssociationCalculator : public CalculatorBase {
       prev_input_stream_id_ = cc->Inputs().GetId("PREV", 0);
     }
     options_ = cc->Options<::mediapipe::AssociationCalculatorOptions>();
-    CHECK_GE(options_.min_similarity_threshold(), 0);
+    ABSL_CHECK_GE(options_.min_similarity_threshold(), 0);
 
     return absl::OkStatus();
   }
diff --git a/third_party/mediapipe/src/mediapipe/calculators/util/detections_to_render_data_calculator.cc b/third_party/mediapipe/src/mediapipe/calculators/util/detections_to_render_data_calculator.cc
index 25d74ba68e236..73430093b6f3d 100644
--- a/third_party/mediapipe/src/mediapipe/calculators/util/detections_to_render_data_calculator.cc
+++ b/third_party/mediapipe/src/mediapipe/calculators/util/detections_to_render_data_calculator.cc
@@ -12,6 +12,7 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
+#include "absl/log/absl_check.h"
 #include "absl/memory/memory.h"
 #include "absl/strings/str_cat.h"
 #include "absl/strings/str_join.h"
@@ -239,7 +240,7 @@ void DetectionsToRenderDataCalculator::AddLabels(
          "is present.";
   const auto num_labels =
       std::max(detection.label_size(), detection.label_id_size());
-  CHECK_EQ(detection.score_size(), num_labels)
+  ABSL_CHECK_EQ(detection.score_size(), num_labels)
       << "Number of scores and labels should match for detection.";
 
   // Extracts all "label(_id),score" for the detection.
diff --git a/third_party/mediapipe/src/mediapipe/calculators/util/labels_to_render_data_calculator.cc b/third_party/mediapipe/src/mediapipe/calculators/util/labels_to_render_data_calculator.cc
index dcd76d47b2836..314640ed736bc 100644
--- a/third_party/mediapipe/src/mediapipe/calculators/util/labels_to_render_data_calculator.cc
+++ b/third_party/mediapipe/src/mediapipe/calculators/util/labels_to_render_data_calculator.cc
@@ -19,6 +19,7 @@
 #include <string>
 #include <vector>
 
+#include "absl/log/absl_check.h"
 #include "absl/strings/str_cat.h"
 #include "mediapipe/calculators/util/labels_to_render_data_calculator.pb.h"
 #include "mediapipe/framework/calculator_framework.h"
@@ -114,7 +115,8 @@ absl::Status LabelsToRenderDataCalculator::Process(CalculatorContext* cc) {
     video_height_ = video_header.height;
     return absl::OkStatus();
   } else {
-    CHECK_EQ(options_.location(), LabelsToRenderDataCalculatorOptions::TOP_LEFT)
+    ABSL_CHECK_EQ(options_.location(),
+                  LabelsToRenderDataCalculatorOptions::TOP_LEFT)
         << "Only TOP_LEFT is supported without VIDEO_PRESTREAM.";
   }
 
@@ -144,7 +146,7 @@ absl::Status LabelsToRenderDataCalculator::Process(CalculatorContext* cc) {
     if (cc->Inputs().HasTag(kScoresTag)) {
       std::vector<float> score_vector =
           cc->Inputs().Tag(kScoresTag).Get<std::vector<float>>();
-      CHECK_EQ(label_vector.size(), score_vector.size());
+      ABSL_CHECK_EQ(label_vector.size(), score_vector.size());
       scores.resize(label_vector.size());
       for (int i = 0; i < label_vector.size(); ++i) {
         scores[i] = score_vector[i];
diff --git a/third_party/mediapipe/src/mediapipe/calculators/util/non_max_suppression_calculator.cc b/third_party/mediapipe/src/mediapipe/calculators/util/non_max_suppression_calculator.cc
index 535e2a719015c..1bab7af878ea5 100644
--- a/third_party/mediapipe/src/mediapipe/calculators/util/non_max_suppression_calculator.cc
+++ b/third_party/mediapipe/src/mediapipe/calculators/util/non_max_suppression_calculator.cc
@@ -18,6 +18,7 @@
 #include <utility>
 #include <vector>
 
+#include "absl/log/absl_check.h"
 #include "mediapipe/calculators/util/non_max_suppression_calculator.pb.h"
 #include "mediapipe/framework/calculator_framework.h"
 #include "mediapipe/framework/formats/detection.pb.h"
@@ -171,9 +172,9 @@ class NonMaxSuppressionCalculator : public CalculatorBase {
     cc->SetOffset(TimestampDiff(0));
 
     options_ = cc->Options<NonMaxSuppressionCalculatorOptions>();
-    CHECK_GT(options_.num_detection_streams(), 0)
+    ABSL_CHECK_GT(options_.num_detection_streams(), 0)
         << "At least one detection stream need to be specified.";
-    CHECK_NE(options_.max_num_detections(), 0)
+    ABSL_CHECK_NE(options_.max_num_detections(), 0)
         << "max_num_detections=0 is not a valid value. Please choose a "
         << "positive number of you want to limit the number of output "
         << "detections, or set -1 if you do not want any limit.";
diff --git a/third_party/mediapipe/src/mediapipe/calculators/video/box_detector_calculator.cc b/third_party/mediapipe/src/mediapipe/calculators/video/box_detector_calculator.cc
index 14ac12e5edd9e..4767d4d632fce 100644
--- a/third_party/mediapipe/src/mediapipe/calculators/video/box_detector_calculator.cc
+++ b/third_party/mediapipe/src/mediapipe/calculators/video/box_detector_calculator.cc
@@ -17,6 +17,7 @@
 #include <memory>
 #include <unordered_set>
 
+#include "absl/log/absl_check.h"
 #include "absl/memory/memory.h"
 #include "absl/strings/numbers.h"
 #include "mediapipe/calculators/video/box_detector_calculator.pb.h"
@@ -359,7 +360,7 @@ absl::Status BoxDetectorCalculator::Process(CalculatorContext* cc) {
 
     const auto& descriptors = descriptor_stream->Get<std::vector<float>>();
     const int dims = options_.detector_options().descriptor_dims();
-    CHECK_GE(descriptors.size(), feature_size * dims);
+    ABSL_CHECK_GE(descriptors.size(), feature_size * dims);
     cv::Mat descriptors_mat(feature_size, dims, CV_32F);
     for (int j = 0; j < feature_size; ++j) {
       features_vec[j].Set(features[j].pt.x * inv_scale,
diff --git a/third_party/mediapipe/src/mediapipe/calculators/video/box_tracker_calculator.cc b/third_party/mediapipe/src/mediapipe/calculators/video/box_tracker_calculator.cc
index b5f3b5b0b3a16..c71e6857debd2 100644
--- a/third_party/mediapipe/src/mediapipe/calculators/video/box_tracker_calculator.cc
+++ b/third_party/mediapipe/src/mediapipe/calculators/video/box_tracker_calculator.cc
@@ -22,6 +22,7 @@
 #include "absl/container/flat_hash_set.h"
 #include "absl/container/node_hash_map.h"
 #include "absl/container/node_hash_set.h"
+#include "absl/log/absl_check.h"
 #include "absl/strings/numbers.h"
 #include "mediapipe/calculators/video/box_tracker_calculator.pb.h"
 #include "mediapipe/framework/calculator_framework.h"
@@ -323,8 +324,8 @@ void ConvertCoordinateForRotation(float in_top, float in_left, float in_bottom,
   const float in_center_y = (in_top + in_bottom) * 0.5f;
   const float in_width = in_right - in_left;
   const float in_height = in_bottom - in_top;
-  CHECK_GT(in_width, 0);
-  CHECK_GT(in_height, 0);
+  ABSL_CHECK_GT(in_width, 0);
+  ABSL_CHECK_GT(in_height, 0);
   float out_center_x;
   float out_center_y;
   float out_width;
@@ -999,7 +1000,7 @@ void BoxTrackerCalculator::OutputRandomAccessTrack(
 
     const int init_frame = timestamp_pos - track_timestamps_.begin() +
                            track_timestamps_base_index_;
-    CHECK_GE(init_frame, 0);
+    ABSL_CHECK_GE(init_frame, 0);
 
     MotionBoxMap single_map =
         PrepareRandomAccessTrack(start, init_frame, forward_track, start_data);
@@ -1233,7 +1234,7 @@ void BoxTrackerCalculator::FastForwardStartPos(
     // Start at previous frame.
     const int init_frame = timestamp_pos - track_timestamps_.begin() +
                            track_timestamps_base_index_;
-    CHECK_GE(init_frame, 0);
+    ABSL_CHECK_GE(init_frame, 0);
 
     // Locate corresponding tracking data.
     auto start_data = std::find_if(
diff --git a/third_party/mediapipe/src/mediapipe/calculators/video/flow_packager_calculator.cc b/third_party/mediapipe/src/mediapipe/calculators/video/flow_packager_calculator.cc
index 2965cd8e66d77..f30fed88baa18 100644
--- a/third_party/mediapipe/src/mediapipe/calculators/video/flow_packager_calculator.cc
+++ b/third_party/mediapipe/src/mediapipe/calculators/video/flow_packager_calculator.cc
@@ -17,6 +17,7 @@
 #include <fstream>
 #include <memory>
 
+#include "absl/log/absl_check.h"
 #include "absl/strings/str_format.h"
 #include "absl/strings/string_view.h"
 #include "mediapipe/calculators/video/flow_packager_calculator.pb.h"
@@ -160,7 +161,7 @@ absl::Status FlowPackagerCalculator::Process(CalculatorContext* cc) {
           timestamp.Value() / 1000 / options_.caching_chunk_size_msec();
       tracking_chunk_.set_first_chunk(true);
     }
-    CHECK_GE(chunk_idx_, 0);
+    ABSL_CHECK_GE(chunk_idx_, 0);
 
     TrackingDataChunk::Item* item = tracking_chunk_.add_item();
     item->set_frame_idx(frame_idx_);
diff --git a/third_party/mediapipe/src/mediapipe/calculators/video/motion_analysis_calculator.cc b/third_party/mediapipe/src/mediapipe/calculators/video/motion_analysis_calculator.cc
index 544439ae82f7d..fe320b1aefb53 100644
--- a/third_party/mediapipe/src/mediapipe/calculators/video/motion_analysis_calculator.cc
+++ b/third_party/mediapipe/src/mediapipe/calculators/video/motion_analysis_calculator.cc
@@ -17,6 +17,7 @@
 #include <memory>
 #include <string>
 
+#include "absl/log/absl_check.h"
 #include "absl/strings/numbers.h"
 #include "absl/strings/str_split.h"
 #include "absl/strings/string_view.h"
@@ -620,7 +621,7 @@ void MotionAnalysisCalculator::OutputMotionAnalyzedFrames(
   const int num_results = motion_analysis_->GetResults(
       flush, &features, &camera_motions, with_saliency_ ? &saliency : nullptr);
 
-  CHECK_LE(num_results, buffer_size);
+  ABSL_CHECK_LE(num_results, buffer_size);
 
   if (num_results == 0) {
     return;
@@ -695,7 +696,7 @@ void MotionAnalysisCalculator::OutputMotionAnalyzedFrames(
 
   if (hybrid_meta_analysis_) {
     hybrid_meta_offset_ -= num_results;
-    CHECK_GE(hybrid_meta_offset_, 0);
+    ABSL_CHECK_GE(hybrid_meta_offset_, 0);
   }
 
   timestamp_buffer_.erase(timestamp_buffer_.begin(),
@@ -901,7 +902,7 @@ void MotionAnalysisCalculator::AddMetaMotion(
     const CameraMotion& meta_motion, const RegionFlowFeatureList& meta_features,
     RegionFlowFeatureList* features, CameraMotion* motion) {
   // Restore old feature location.
-  CHECK_EQ(meta_features.feature_size(), features->feature_size());
+  ABSL_CHECK_EQ(meta_features.feature_size(), features->feature_size());
   for (int k = 0; k < meta_features.feature_size(); ++k) {
     auto feature = features->mutable_feature(k);
     const auto& meta_feature = meta_features.feature(k);
@@ -947,8 +948,9 @@ void MotionAnalysisCalculator::AppendCameraMotionsFromHomographies(
   }
 
   const int models_per_frame = options_.meta_models_per_frame();
-  CHECK_GT(models_per_frame, 0) << "At least one model per frame is needed";
-  CHECK_EQ(0, homographies.size() % models_per_frame);
+  ABSL_CHECK_GT(models_per_frame, 0)
+      << "At least one model per frame is needed";
+  ABSL_CHECK_EQ(0, homographies.size() % models_per_frame);
   const int num_frames = homographies.size() / models_per_frame;
 
   // Heuristic sigma, similar to what we use for rolling shutter removal.
diff --git a/third_party/mediapipe/src/mediapipe/calculators/video/tool/flow_quantizer_model.cc b/third_party/mediapipe/src/mediapipe/calculators/video/tool/flow_quantizer_model.cc
index f0b00063fd9d9..146dc4a7031ce 100644
--- a/third_party/mediapipe/src/mediapipe/calculators/video/tool/flow_quantizer_model.cc
+++ b/third_party/mediapipe/src/mediapipe/calculators/video/tool/flow_quantizer_model.cc
@@ -14,6 +14,7 @@
 
 #include "mediapipe/calculators/video/tool/flow_quantizer_model.h"
 
+#include "absl/log/absl_check.h"
 #include "mediapipe/framework/port/ret_check.h"
 #include "mediapipe/framework/type_map.h"
 
@@ -21,7 +22,7 @@ namespace mediapipe {
 
 // Uniform normalization to 0-255.
 uint8_t FlowQuantizerModel::Apply(const float val, const int channel) const {
-  CHECK_LT(channel, model_.min_value_size());
+  ABSL_CHECK_LT(channel, model_.min_value_size());
   const auto& min_value = model_.min_value(channel);
   const auto& max_value = model_.max_value(channel);
   QCHECK_GT(max_value, min_value);
@@ -51,7 +52,7 @@ const QuantizerModelData& FlowQuantizerModel::GetModelData() const {
 // TODO: Taking the min and max over all training flow fields might be
 // sensitive to noise. We should use more robust statistics.
 void FlowQuantizerModel::AddSampleFlowField(const OpticalFlowField& flow) {
-  CHECK_EQ(model_.min_value_size(), 2);
+  ABSL_CHECK_EQ(model_.min_value_size(), 2);
   const cv::Mat_<cv::Point2f>& flow_mat = flow.flow_data();
   for (int i = 0; i != flow.width(); ++i) {
     for (int j = 0; j != flow.height(); ++j) {
diff --git a/third_party/mediapipe/src/mediapipe/calculators/video/tvl1_optical_flow_calculator.cc b/third_party/mediapipe/src/mediapipe/calculators/video/tvl1_optical_flow_calculator.cc
index 56f3253e29763..dd87ae644b739 100644
--- a/third_party/mediapipe/src/mediapipe/calculators/video/tvl1_optical_flow_calculator.cc
+++ b/third_party/mediapipe/src/mediapipe/calculators/video/tvl1_optical_flow_calculator.cc
@@ -13,6 +13,7 @@
 // limitations under the License.
 
 #include "absl/base/macros.h"
+#include "absl/log/absl_check.h"
 #include "absl/synchronization/mutex.h"
 #include "mediapipe/framework/calculator_framework.h"
 #include "mediapipe/framework/formats/image_frame.h"
@@ -182,7 +183,7 @@ absl::Status Tvl1OpticalFlowCalculator::CalculateOpticalFlow(
   flow->Allocate(first.cols, first.rows);
   cv::Mat cv_flow(flow->mutable_flow_data());
   tvl1_computer->calc(first, second, cv_flow);
-  CHECK_EQ(flow->mutable_flow_data().data, cv_flow.data);
+  ABSL_CHECK_EQ(flow->mutable_flow_data().data, cv_flow.data);
   // Inserts the idle DenseOpticalFlow object back to the cache for reuse.
   {
     absl::MutexLock lock(&mutex_);
diff --git a/third_party/mediapipe/src/mediapipe/framework/api2/builder.h b/third_party/mediapipe/src/mediapipe/framework/api2/builder.h
index 0c4c82f3708c1..89f25c7b52a4e 100644
--- a/third_party/mediapipe/src/mediapipe/framework/api2/builder.h
+++ b/third_party/mediapipe/src/mediapipe/framework/api2/builder.h
@@ -11,6 +11,7 @@
 #include <vector>
 
 #include "absl/container/btree_map.h"
+#include "absl/log/absl_check.h"
 #include "absl/strings/string_view.h"
 #include "google/protobuf/message_lite.h"
 #include "mediapipe/framework/api2/port.h"
@@ -109,7 +110,7 @@ class MultiPort : public Single {
       : Single(vec), vec_(*vec) {}
 
   Single operator[](int index) {
-    CHECK_GE(index, 0);
+    ABSL_CHECK_GE(index, 0);
     return Single{&GetWithAutoGrow(&vec_, index)};
   }
 
diff --git a/third_party/mediapipe/src/mediapipe/framework/api2/packet.h b/third_party/mediapipe/src/mediapipe/framework/api2/packet.h
index c059a988b4315..f231f4c80b312 100644
--- a/third_party/mediapipe/src/mediapipe/framework/api2/packet.h
+++ b/third_party/mediapipe/src/mediapipe/framework/api2/packet.h
@@ -13,6 +13,7 @@
 #include <functional>
 #include <type_traits>
 
+#include "absl/log/absl_check.h"
 #include "absl/meta/type_traits.h"
 #include "mediapipe/framework/api2/tuple.h"
 #include "mediapipe/framework/packet.h"
@@ -102,9 +103,9 @@ mediapipe::Packet ToOldPacket(PacketBase&& p);
 
 template <typename T>
 inline const T& PacketBase::Get() const {
-  CHECK(payload_);
+  ABSL_CHECK(payload_);
   packet_internal::Holder<T>* typed_payload = payload_->As<T>();
-  CHECK(typed_payload) << absl::StrCat(
+  ABSL_CHECK(typed_payload) << absl::StrCat(
       "The Packet stores \"", payload_->DebugTypeName(), "\", but \"",
       MediaPipeTypeStringOrDemangled<T>(), "\" was requested.");
   return typed_payload->data();
@@ -134,17 +135,17 @@ namespace internal {
 template <class T>
 inline void CheckCompatibleType(const HolderBase& holder, internal::Wrap<T>) {
   const packet_internal::Holder<T>* typed_payload = holder.As<T>();
-  CHECK(typed_payload) << absl::StrCat(
+  ABSL_CHECK(typed_payload) << absl::StrCat(
       "The Packet stores \"", holder.DebugTypeName(), "\", but \"",
       MediaPipeTypeStringOrDemangled<T>(), "\" was requested.");
-  //  CHECK(payload_->has_type<T>());
+  //  ABSL_CHECK(payload_->has_type<T>());
 }
 
 template <class... T>
 inline void CheckCompatibleType(const HolderBase& holder,
                                 internal::Wrap<OneOf<T...>>) {
   bool compatible = (holder.As<T>() || ...);
-  CHECK(compatible)
+  ABSL_CHECK(compatible)
       << "The Packet stores \"" << holder.DebugTypeName() << "\", but one of "
       << absl::StrJoin(
              {absl::StrCat("\"", MediaPipeTypeStringOrDemangled<T>(), "\"")...},
@@ -211,9 +212,9 @@ class Packet : public Packet<internal::Generic> {
   Packet<T> At(Timestamp timestamp) &&;
 
   const T& Get() const {
-    CHECK(payload_);
+    ABSL_CHECK(payload_);
     packet_internal::Holder<T>* typed_payload = payload_->As<T>();
-    CHECK(typed_payload);
+    ABSL_CHECK(typed_payload);
     return typed_payload->data();
   }
   const T& operator*() const { return Get(); }
@@ -330,9 +331,9 @@ class Packet<OneOf<T...>> : public PacketBase {
 
   template <class U, class = AllowedType<U>>
   const U& Get() const {
-    CHECK(payload_);
+    ABSL_CHECK(payload_);
     packet_internal::Holder<U>* typed_payload = payload_->As<U>();
-    CHECK(typed_payload);
+    ABSL_CHECK(typed_payload);
     return typed_payload->data();
   }
 
@@ -343,7 +344,7 @@ class Packet<OneOf<T...>> : public PacketBase {
 
   template <class... F>
   auto Visit(const F&... args) const {
-    CHECK(payload_);
+    ABSL_CHECK(payload_);
     auto f = internal::Overload{args...};
     using FirstT = typename internal::First<T...>::type;
     using ResultType = absl::result_of_t<decltype(f)(const FirstT&)>;
@@ -364,7 +365,7 @@ class Packet<OneOf<T...>> : public PacketBase {
 
   template <class... F>
   auto ConsumeAndVisit(const F&... args) {
-    CHECK(payload_);
+    ABSL_CHECK(payload_);
     auto f = internal::Overload{args...};
     using FirstT = typename internal::First<T...>::type;
     using VisitorResultType =
diff --git a/third_party/mediapipe/src/mediapipe/framework/api2/port.h b/third_party/mediapipe/src/mediapipe/framework/api2/port.h
index 18a786075980c..075e88437a8f6 100644
--- a/third_party/mediapipe/src/mediapipe/framework/api2/port.h
+++ b/third_party/mediapipe/src/mediapipe/framework/api2/port.h
@@ -20,6 +20,7 @@
 #include <type_traits>
 #include <utility>
 
+#include "absl/log/absl_check.h"
 #include "absl/strings/str_cat.h"
 #include "absl/strings/string_view.h"
 #include "mediapipe/framework/api2/const_str.h"
@@ -243,8 +244,8 @@ class MultiplePortAccess {
   // container?
   int Count() { return count_; }
   AccessT operator[](int pos) {
-    CHECK_GE(pos, 0);
-    CHECK_LT(pos, count_);
+    ABSL_CHECK_GE(pos, 0);
+    ABSL_CHECK_LT(pos, count_);
     return SinglePortAccess<ValueT>(cc_, &first_[pos]);
   }
 
diff --git a/third_party/mediapipe/src/mediapipe/framework/calculator_context.h b/third_party/mediapipe/src/mediapipe/framework/calculator_context.h
index 9568ba7455392..315d265118550 100644
--- a/third_party/mediapipe/src/mediapipe/framework/calculator_context.h
+++ b/third_party/mediapipe/src/mediapipe/framework/calculator_context.h
@@ -20,6 +20,7 @@
 #include <string>
 #include <utility>
 
+#include "absl/log/absl_check.h"
 #include "mediapipe/framework/calculator_state.h"
 #include "mediapipe/framework/counter.h"
 #include "mediapipe/framework/graph_service.h"
@@ -147,7 +148,7 @@ class CalculatorContext {
   }
 
   void PopInputTimestamp() {
-    CHECK(!input_timestamps_.empty());
+    ABSL_CHECK(!input_timestamps_.empty());
     input_timestamps_.pop();
   }
 
diff --git a/third_party/mediapipe/src/mediapipe/framework/calculator_context_manager.h b/third_party/mediapipe/src/mediapipe/framework/calculator_context_manager.h
index 6b988b03d9685..ae697e12f2d23 100644
--- a/third_party/mediapipe/src/mediapipe/framework/calculator_context_manager.h
+++ b/third_party/mediapipe/src/mediapipe/framework/calculator_context_manager.h
@@ -21,6 +21,7 @@
 #include <memory>
 
 #include "absl/base/thread_annotations.h"
+#include "absl/log/absl_check.h"
 #include "absl/synchronization/mutex.h"
 #include "mediapipe/framework/calculator_context.h"
 #include "mediapipe/framework/calculator_state.h"
@@ -97,18 +98,18 @@ class CalculatorContextManager {
 
   void PushInputTimestampToContext(CalculatorContext* calculator_context,
                                    Timestamp input_timestamp) {
-    CHECK(calculator_context);
+    ABSL_CHECK(calculator_context);
     calculator_context->PushInputTimestamp(input_timestamp);
   }
 
   void PopInputTimestampFromContext(CalculatorContext* calculator_context) {
-    CHECK(calculator_context);
+    ABSL_CHECK(calculator_context);
     calculator_context->PopInputTimestamp();
   }
 
   void SetGraphStatusInContext(CalculatorContext* calculator_context,
                                const absl::Status& status) {
-    CHECK(calculator_context);
+    ABSL_CHECK(calculator_context);
     calculator_context->SetGraphStatus(status);
   }
 
diff --git a/third_party/mediapipe/src/mediapipe/framework/calculator_graph.cc b/third_party/mediapipe/src/mediapipe/framework/calculator_graph.cc
index 33ca41fb872ad..770f8337b1fba 100644
--- a/third_party/mediapipe/src/mediapipe/framework/calculator_graph.cc
+++ b/third_party/mediapipe/src/mediapipe/framework/calculator_graph.cc
@@ -25,6 +25,7 @@
 
 #include "absl/container/fixed_array.h"
 #include "absl/container/flat_hash_set.h"
+#include "absl/log/absl_check.h"
 #include "absl/memory/memory.h"
 #include "absl/status/status.h"
 #include "absl/strings/str_cat.h"
@@ -904,7 +905,7 @@ absl::Status CalculatorGraph::AddPacketToInputStreamInternal(
       "graph input stream.",
       stream_name);
   int node_id = mediapipe::FindOrDie(graph_input_stream_node_ids_, stream_name);
-  CHECK_GE(node_id, validated_graph_->CalculatorInfos().size());
+  ABSL_CHECK_GE(node_id, validated_graph_->CalculatorInfos().size());
   {
     absl::MutexLock lock(&full_input_streams_mutex_);
     if (full_input_streams_.empty()) {
@@ -1155,10 +1156,10 @@ void CalculatorGraph::UpdateThrottledNodes(InputStreamManager* stream,
                                 .set_stream_id(&stream->Name()));
         bool was_throttled = !full_input_streams_[node_id].empty();
         if (stream_is_full) {
-          DCHECK_EQ(full_input_streams_[node_id].count(stream), 0);
+          ABSL_DCHECK_EQ(full_input_streams_[node_id].count(stream), 0);
           full_input_streams_[node_id].insert(stream);
         } else {
-          DCHECK_EQ(full_input_streams_[node_id].count(stream), 1);
+          ABSL_DCHECK_EQ(full_input_streams_[node_id].count(stream), 1);
           full_input_streams_[node_id].erase(stream);
         }
 
diff --git a/third_party/mediapipe/src/mediapipe/framework/calculator_node.cc b/third_party/mediapipe/src/mediapipe/framework/calculator_node.cc
index f6a1c7dbfcdcb..5618038e25c5f 100644
--- a/third_party/mediapipe/src/mediapipe/framework/calculator_node.cc
+++ b/third_party/mediapipe/src/mediapipe/framework/calculator_node.cc
@@ -19,6 +19,7 @@
 #include <unordered_map>
 #include <utility>
 
+#include "absl/log/absl_check.h"
 #include "absl/memory/memory.h"
 #include "absl/status/status.h"
 #include "absl/strings/str_cat.h"
@@ -341,7 +342,7 @@ absl::Status CalculatorNode::ConnectShardsToStreams(
 
 void CalculatorNode::SetExecutor(const std::string& executor) {
   absl::MutexLock status_lock(&status_mutex_);
-  CHECK_LT(status_, kStateOpened);
+  ABSL_CHECK_LT(status_, kStateOpened);
   executor_ = executor;
 }
 
@@ -539,7 +540,7 @@ absl::Status CalculatorNode::OpenNode() {
 
 void CalculatorNode::ActivateNode() {
   absl::MutexLock status_lock(&status_mutex_);
-  CHECK_EQ(status_, kStateOpened) << DebugName();
+  ABSL_CHECK_EQ(status_, kStateOpened) << DebugName();
   status_ = kStateActive;
 }
 
@@ -694,7 +695,7 @@ void CalculatorNode::InputStreamHeadersReady() {
   bool ready_for_open = false;
   {
     absl::MutexLock lock(&status_mutex_);
-    CHECK_EQ(status_, kStatePrepared) << DebugName();
+    ABSL_CHECK_EQ(status_, kStatePrepared) << DebugName();
     CHECK(!input_stream_headers_ready_called_);
     input_stream_headers_ready_called_ = true;
     input_stream_headers_ready_ = true;
@@ -709,7 +710,7 @@ void CalculatorNode::InputSidePacketsReady() {
   bool ready_for_open = false;
   {
     absl::MutexLock lock(&status_mutex_);
-    CHECK_EQ(status_, kStatePrepared) << DebugName();
+    ABSL_CHECK_EQ(status_, kStatePrepared) << DebugName();
     CHECK(!input_side_packets_ready_called_);
     input_side_packets_ready_called_ = true;
     input_side_packets_ready_ = true;
@@ -760,7 +761,7 @@ void CalculatorNode::EndScheduling() {
       return;
     }
     --current_in_flight_;
-    CHECK_GE(current_in_flight_, 0);
+    ABSL_CHECK_GE(current_in_flight_, 0);
 
     if (scheduling_state_ == kScheduling) {
       // Changes the state to scheduling pending if another thread is doing the
@@ -893,9 +894,9 @@ absl::Status CalculatorNode::ProcessNode(
         // open input streams for Process(). So this node needs to be closed
         // too.
         // If the streams are closed, there shouldn't be more input.
-        CHECK_EQ(calculator_context_manager_.NumberOfContextTimestamps(
-                     *calculator_context),
-                 1);
+        ABSL_CHECK_EQ(calculator_context_manager_.NumberOfContextTimestamps(
+                          *calculator_context),
+                      1);
         return CloseNode(absl::OkStatus(), /*graph_run_ended=*/false);
       } else {
         RET_CHECK_FAIL()
diff --git a/third_party/mediapipe/src/mediapipe/framework/collection.h b/third_party/mediapipe/src/mediapipe/framework/collection.h
index c7b6fb0de333a..a2ab39fa49ae6 100644
--- a/third_party/mediapipe/src/mediapipe/framework/collection.h
+++ b/third_party/mediapipe/src/mediapipe/framework/collection.h
@@ -24,6 +24,7 @@
 #include <vector>
 
 #include "absl/base/macros.h"
+#include "absl/log/absl_check.h"
 #include "absl/memory/memory.h"
 #include "absl/strings/str_cat.h"
 #include "absl/strings/string_view.h"
@@ -413,16 +414,16 @@ bool Collection<T, storage, ErrorHandler>::UsesTags() const {
 template <typename T, CollectionStorage storage, typename ErrorHandler>
 typename Collection<T, storage, ErrorHandler>::value_type&
 Collection<T, storage, ErrorHandler>::Get(CollectionItemId id) {
-  CHECK_LE(BeginId(), id);
-  CHECK_LT(id, EndId());
+  ABSL_CHECK_LE(BeginId(), id);
+  ABSL_CHECK_LT(id, EndId());
   return begin()[id.value()];
 }
 
 template <typename T, CollectionStorage storage, typename ErrorHandler>
 const typename Collection<T, storage, ErrorHandler>::value_type&
 Collection<T, storage, ErrorHandler>::Get(CollectionItemId id) const {
-  CHECK_LE(BeginId(), id);
-  CHECK_LT(id, EndId());
+  ABSL_CHECK_LE(BeginId(), id);
+  ABSL_CHECK_LT(id, EndId());
   return begin()[id.value()];
 }
 
@@ -433,8 +434,8 @@ Collection<T, storage, ErrorHandler>::GetPtr(CollectionItemId id) {
                 "mediapipe::internal::Collection<T>::GetPtr() is only "
                 "available for collections that were defined with template "
                 "argument storage == CollectionStorage::kStorePointer.");
-  CHECK_LE(BeginId(), id);
-  CHECK_LT(id, EndId());
+  ABSL_CHECK_LE(BeginId(), id);
+  ABSL_CHECK_LT(id, EndId());
   return data_[id.value()];
 }
 
@@ -445,8 +446,8 @@ Collection<T, storage, ErrorHandler>::GetPtr(CollectionItemId id) const {
                 "mediapipe::internal::Collection<T>::GetPtr() is only "
                 "available for collections that were defined with template "
                 "argument storage == CollectionStorage::kStorePointer.");
-  CHECK_LE(BeginId(), id);
-  CHECK_LT(id, EndId());
+  ABSL_CHECK_LE(BeginId(), id);
+  ABSL_CHECK_LT(id, EndId());
   return data_[id.value()];
 }
 
diff --git a/third_party/mediapipe/src/mediapipe/framework/deps/mathutil.h b/third_party/mediapipe/src/mediapipe/framework/deps/mathutil.h
index 315b78c42fcdf..24543d4c3476f 100644
--- a/third_party/mediapipe/src/mediapipe/framework/deps/mathutil.h
+++ b/third_party/mediapipe/src/mediapipe/framework/deps/mathutil.h
@@ -23,6 +23,7 @@
 #include <limits>
 #include <type_traits>
 
+#include "absl/log/absl_check.h"
 #include "mediapipe/framework/port/integral_types.h"
 #include "mediapipe/framework/port/logging.h"
 
@@ -364,7 +365,7 @@ class MathUtil {
   // absolute margin of error.
   template <typename T>
   static bool WithinMargin(const T x, const T y, const T margin) {
-    DCHECK_GE(margin, 0);
+    ABSL_DCHECK_GE(margin, 0);
     return (std::abs(x) <= std::abs(y) + margin) &&
            (std::abs(x) >= std::abs(y) - margin);
   }
diff --git a/third_party/mediapipe/src/mediapipe/framework/deps/monotonic_clock.cc b/third_party/mediapipe/src/mediapipe/framework/deps/monotonic_clock.cc
index 503ef5cfdd019..e3cc9de231cd7 100644
--- a/third_party/mediapipe/src/mediapipe/framework/deps/monotonic_clock.cc
+++ b/third_party/mediapipe/src/mediapipe/framework/deps/monotonic_clock.cc
@@ -16,6 +16,7 @@
 
 #include "absl/base/macros.h"
 #include "absl/base/thread_annotations.h"
+#include "absl/log/absl_check.h"
 #include "absl/synchronization/mutex.h"
 #include "absl/time/time.h"
 #include "mediapipe/framework/port/logging.h"
@@ -80,7 +81,7 @@ class MonotonicClockImpl : public MonotonicClock {
       absl::MutexLock m(&state_->lock);
 
       // Check consistency of internal data with state_.
-      CHECK_LE(last_raw_time_, state_->max_time)
+      ABSL_CHECK_LE(last_raw_time_, state_->max_time)
           << "non-monotonic behavior: last_raw_time_=" << last_raw_time_
           << ", max_time=" << state_->max_time;
 
@@ -107,7 +108,7 @@ class MonotonicClockImpl : public MonotonicClock {
       // First, update correction metrics.
       ++correction_count_;
       absl::Duration delta = state_->max_time - raw_time;
-      CHECK_LT(absl::ZeroDuration(), delta);
+      ABSL_CHECK_LT(absl::ZeroDuration(), delta);
       if (delta > max_correction_) {
         max_correction_ = delta;
       }
diff --git a/third_party/mediapipe/src/mediapipe/framework/deps/registration.h b/third_party/mediapipe/src/mediapipe/framework/deps/registration.h
index c67f07305a5f3..9abc30ee4f280 100644
--- a/third_party/mediapipe/src/mediapipe/framework/deps/registration.h
+++ b/third_party/mediapipe/src/mediapipe/framework/deps/registration.h
@@ -28,6 +28,7 @@
 #include "absl/base/thread_annotations.h"
 #include "absl/container/flat_hash_map.h"
 #include "absl/container/flat_hash_set.h"
+#include "absl/log/absl_check.h"
 #include "absl/meta/type_traits.h"
 #include "absl/strings/str_join.h"
 #include "absl/strings/str_split.h"
@@ -270,7 +271,7 @@ class FunctionRegistry {
     if (names[0].empty()) {
       names.erase(names.begin());
     } else {
-      CHECK_EQ(1u, names.size())
+      ABSL_CHECK_EQ(1u, names.size())
           << "A registered class name must be either fully qualified "
           << "with a leading :: or unqualified, got: " << name << ".";
     }
diff --git a/third_party/mediapipe/src/mediapipe/framework/deps/safe_int.h b/third_party/mediapipe/src/mediapipe/framework/deps/safe_int.h
index f6dbb931d23c6..8b717cb9700d3 100644
--- a/third_party/mediapipe/src/mediapipe/framework/deps/safe_int.h
+++ b/third_party/mediapipe/src/mediapipe/framework/deps/safe_int.h
@@ -44,6 +44,7 @@
 #include <limits>
 #include <type_traits>
 
+#include "absl/log/absl_check.h"
 #include "mediapipe/framework/deps/strong_int.h"
 #include "mediapipe/framework/port/logging.h"
 
@@ -67,17 +68,17 @@ class SafeIntStrongIntValidator {
     // Check that the underlying integral type provides a range that is
     // compatible with two's complement.
     if (std::numeric_limits<T>::is_signed) {
-      CHECK_EQ(-1,
-               std::numeric_limits<T>::min() + std::numeric_limits<T>::max())
+      ABSL_CHECK_EQ(
+          -1, std::numeric_limits<T>::min() + std::numeric_limits<T>::max())
           << "unexpected integral bounds";
     }
 
     // Check that division truncates towards 0 (implementation defined in
     // C++'03, but standard in C++'11).
-    CHECK_EQ(12, 127 / 10) << "division does not truncate towards 0";
-    CHECK_EQ(-12, -127 / 10) << "division does not truncate towards 0";
-    CHECK_EQ(-12, 127 / -10) << "division does not truncate towards 0";
-    CHECK_EQ(12, -127 / -10) << "division does not truncate towards 0";
+    ABSL_CHECK_EQ(12, 127 / 10) << "division does not truncate towards 0";
+    ABSL_CHECK_EQ(-12, -127 / 10) << "division does not truncate towards 0";
+    ABSL_CHECK_EQ(-12, 127 / -10) << "division does not truncate towards 0";
+    ABSL_CHECK_EQ(12, -127 / -10) << "division does not truncate towards 0";
   }
 
  public:
diff --git a/third_party/mediapipe/src/mediapipe/framework/deps/threadpool_pthread_impl.cc b/third_party/mediapipe/src/mediapipe/framework/deps/threadpool_pthread_impl.cc
index d9c32d35e1f01..9610f3745dab3 100644
--- a/third_party/mediapipe/src/mediapipe/framework/deps/threadpool_pthread_impl.cc
+++ b/third_party/mediapipe/src/mediapipe/framework/deps/threadpool_pthread_impl.cc
@@ -18,6 +18,7 @@
 #include <sys/syscall.h>
 #include <unistd.h>
 
+#include "absl/log/absl_check.h"
 #include "absl/strings/str_cat.h"
 #include "absl/strings/str_join.h"
 #include "mediapipe/framework/deps/threadpool.h"
@@ -48,7 +49,7 @@ ThreadPool::WorkerThread::WorkerThread(ThreadPool* pool,
                                        const std::string& name_prefix)
     : pool_(pool), name_prefix_(name_prefix) {
   int res = pthread_create(&thread_, nullptr, ThreadBody, this);
-  CHECK_EQ(res, 0) << "pthread_create failed";
+  ABSL_CHECK_EQ(res, 0) << "pthread_create failed";
 }
 
 ThreadPool::WorkerThread::~WorkerThread() {}
diff --git a/third_party/mediapipe/src/mediapipe/framework/deps/topologicalsorter.cc b/third_party/mediapipe/src/mediapipe/framework/deps/topologicalsorter.cc
index 67fc6adc4e582..65cd825b135d6 100644
--- a/third_party/mediapipe/src/mediapipe/framework/deps/topologicalsorter.cc
+++ b/third_party/mediapipe/src/mediapipe/framework/deps/topologicalsorter.cc
@@ -16,12 +16,13 @@
 
 #include <algorithm>
 
+#include "absl/log/absl_check.h"
 #include "mediapipe/framework/port/logging.h"
 
 namespace mediapipe {
 
 TopologicalSorter::TopologicalSorter(int num_nodes) : num_nodes_(num_nodes) {
-  CHECK_GE(num_nodes_, 0);
+  ABSL_CHECK_GE(num_nodes_, 0);
   adjacency_lists_.resize(num_nodes_);
 }
 
diff --git a/third_party/mediapipe/src/mediapipe/framework/deps/vector.h b/third_party/mediapipe/src/mediapipe/framework/deps/vector.h
index 2d4de82f314c3..577575321a423 100644
--- a/third_party/mediapipe/src/mediapipe/framework/deps/vector.h
+++ b/third_party/mediapipe/src/mediapipe/framework/deps/vector.h
@@ -24,6 +24,7 @@
 #include <limits>
 #include <type_traits>
 
+#include "absl/log/absl_check.h"
 #include "absl/utility/utility.h"
 #include "mediapipe/framework/port/integral_types.h"
 #include "mediapipe/framework/port/logging.h"
@@ -78,13 +79,13 @@ class BasicVector {
   void Clear() { AsD() = D(); }
 
   T& operator[](int b) {
-    DCHECK_GE(b, 0);
-    DCHECK_LT(b, SIZE);
+    ABSL_DCHECK_GE(b, 0);
+    ABSL_DCHECK_LT(b, SIZE);
     return static_cast<D&>(*this).Data()[b];
   }
   T operator[](int b) const {
-    DCHECK_GE(b, 0);
-    DCHECK_LT(b, SIZE);
+    ABSL_DCHECK_GE(b, 0);
+    ABSL_DCHECK_LT(b, SIZE);
     return static_cast<const D&>(*this).Data()[b];
   }
 
diff --git a/third_party/mediapipe/src/mediapipe/framework/formats/frame_buffer.h b/third_party/mediapipe/src/mediapipe/framework/formats/frame_buffer.h
index 21a5f537f95fe..4ebf3c607e189 100644
--- a/third_party/mediapipe/src/mediapipe/framework/formats/frame_buffer.h
+++ b/third_party/mediapipe/src/mediapipe/framework/formats/frame_buffer.h
@@ -18,6 +18,7 @@ limitations under the License.
 
 #include <vector>
 
+#include "absl/log/absl_check.h"
 #include "absl/log/check.h"
 #include "absl/status/statusor.h"
 #include "mediapipe/framework/port/integral_types.h"
@@ -147,15 +148,15 @@ class FrameBuffer {
 
   // Returns plane indexed by the input `index`.
   const Plane& plane(int index) const {
-    CHECK_GE(index, 0);
-    CHECK_LT(static_cast<size_t>(index), planes_.size());
+    ABSL_CHECK_GE(index, 0);
+    ABSL_CHECK_LT(static_cast<size_t>(index), planes_.size());
     return planes_[index];
   }
 
   // Returns mutable plane indexed by the input `index`.
   Plane mutable_plane(int index) {
-    CHECK_GE(index, 0);
-    CHECK_LT(static_cast<size_t>(index), planes_.size());
+    ABSL_CHECK_GE(index, 0);
+    ABSL_CHECK_LT(static_cast<size_t>(index), planes_.size());
     return planes_[index];
   }
 
diff --git a/third_party/mediapipe/src/mediapipe/framework/formats/image_frame.cc b/third_party/mediapipe/src/mediapipe/framework/formats/image_frame.cc
index 2de819a35bf60..458d1308c17ac 100644
--- a/third_party/mediapipe/src/mediapipe/framework/formats/image_frame.cc
+++ b/third_party/mediapipe/src/mediapipe/framework/formats/image_frame.cc
@@ -23,6 +23,7 @@
 #include <algorithm>
 #include <utility>
 
+#include "absl/log/absl_check.h"
 #include "absl/strings/str_cat.h"
 #include "mediapipe/framework/formats/image_format.pb.h"
 #include "mediapipe/framework/port/aligned_malloc_and_free.h"
@@ -98,7 +99,7 @@ void ImageFrame::Reset(ImageFormat::Format format, int width, int height,
   format_ = format;
   width_ = width;
   height_ = height;
-  CHECK_NE(ImageFormat::UNKNOWN, format_);
+  ABSL_CHECK_NE(ImageFormat::UNKNOWN, format_);
   CHECK(IsValidAlignmentNumber(alignment_boundary));
   width_step_ = width * NumberOfChannels() * ByteDepth();
   if (alignment_boundary == 1) {
@@ -124,8 +125,8 @@ void ImageFrame::AdoptPixelData(ImageFormat::Format format, int width,
   height_ = height;
   width_step_ = width_step;
 
-  CHECK_NE(ImageFormat::UNKNOWN, format_);
-  CHECK_GE(width_step_, width * NumberOfChannels() * ByteDepth());
+  ABSL_CHECK_NE(ImageFormat::UNKNOWN, format_);
+  ABSL_CHECK_GE(width_step_, width * NumberOfChannels() * ByteDepth());
 
   pixel_data_ = {pixel_data, deleter};
 }
@@ -136,8 +137,8 @@ std::unique_ptr<uint8_t[], ImageFrame::Deleter> ImageFrame::Release() {
 
 void ImageFrame::InternalCopyFrom(int width, int height, int width_step,
                                   int channel_size, const uint8_t* pixel_data) {
-  CHECK_EQ(width_, width);
-  CHECK_EQ(height_, height);
+  ABSL_CHECK_EQ(width_, width);
+  ABSL_CHECK_EQ(height_, height);
   // row_bytes = channel_size * num_channels * width
   const int row_bytes = channel_size * NumberOfChannels() * width;
   if (width_step == 0) {
@@ -187,8 +188,8 @@ void ImageFrame::SetAlignmentPaddingAreas() {
   if (!pixel_data_) {
     return;
   }
-  CHECK_GE(width_, 1);
-  CHECK_GE(height_, 1);
+  ABSL_CHECK_GE(width_, 1);
+  ABSL_CHECK_GE(height_, 1);
 
   const int pixel_size = ByteDepth() * NumberOfChannels();
   const int padding_size = width_step_ - width_ * pixel_size;
@@ -359,7 +360,7 @@ void ImageFrame::CopyFrom(const ImageFrame& image_frame,
   Reset(image_frame.Format(), image_frame.Width(), image_frame.Height(),
         alignment_boundary);
 
-  CHECK_EQ(format_, image_frame.Format());
+  ABSL_CHECK_EQ(format_, image_frame.Format());
   InternalCopyFrom(image_frame.Width(), image_frame.Height(),
                    image_frame.WidthStep(), image_frame.ChannelSize(),
                    image_frame.PixelData());
@@ -383,9 +384,9 @@ void ImageFrame::CopyPixelData(ImageFormat::Format format, int width,
 
 void ImageFrame::CopyToBuffer(uint8_t* buffer, int buffer_size) const {
   CHECK(buffer);
-  CHECK_EQ(1, ByteDepth());
+  ABSL_CHECK_EQ(1, ByteDepth());
   const int data_size = width_ * height_ * NumberOfChannels();
-  CHECK_LE(data_size, buffer_size);
+  ABSL_CHECK_LE(data_size, buffer_size);
   if (IsContiguous()) {
     // The data is stored contiguously, we can just copy.
     const uint8_t* src = reinterpret_cast<const uint8_t*>(pixel_data_.get());
@@ -398,9 +399,9 @@ void ImageFrame::CopyToBuffer(uint8_t* buffer, int buffer_size) const {
 
 void ImageFrame::CopyToBuffer(uint16_t* buffer, int buffer_size) const {
   CHECK(buffer);
-  CHECK_EQ(2, ByteDepth());
+  ABSL_CHECK_EQ(2, ByteDepth());
   const int data_size = width_ * height_ * NumberOfChannels();
-  CHECK_LE(data_size, buffer_size);
+  ABSL_CHECK_LE(data_size, buffer_size);
   if (IsContiguous()) {
     // The data is stored contiguously, we can just copy.
     const uint16_t* src = reinterpret_cast<const uint16_t*>(pixel_data_.get());
@@ -413,9 +414,9 @@ void ImageFrame::CopyToBuffer(uint16_t* buffer, int buffer_size) const {
 
 void ImageFrame::CopyToBuffer(float* buffer, int buffer_size) const {
   CHECK(buffer);
-  CHECK_EQ(4, ByteDepth());
+  ABSL_CHECK_EQ(4, ByteDepth());
   const int data_size = width_ * height_ * NumberOfChannels();
-  CHECK_LE(data_size, buffer_size);
+  ABSL_CHECK_LE(data_size, buffer_size);
   if (IsContiguous()) {
     // The data is stored contiguously, we can just copy.
     const float* src = reinterpret_cast<float*>(pixel_data_.get());
diff --git a/third_party/mediapipe/src/mediapipe/framework/formats/image_multi_pool.cc b/third_party/mediapipe/src/mediapipe/framework/formats/image_multi_pool.cc
index 655064d36eba2..5953d0fd933ab 100644
--- a/third_party/mediapipe/src/mediapipe/framework/formats/image_multi_pool.cc
+++ b/third_party/mediapipe/src/mediapipe/framework/formats/image_multi_pool.cc
@@ -16,6 +16,7 @@
 
 #include <tuple>
 
+#include "absl/log/absl_check.h"
 #include "absl/memory/memory.h"
 #include "absl/synchronization/mutex.h"
 #include "mediapipe/framework/port/logging.h"
@@ -43,7 +44,7 @@ ImageMultiPool::SimplePoolGpu ImageMultiPool::MakeSimplePoolGpu(
     IBufferSpec spec) {
   OSType cv_format = mediapipe::CVPixelFormatForGpuBufferFormat(
       GpuBufferFormatForImageFormat(spec.format));
-  CHECK_NE(cv_format, -1) << "unsupported pixel format";
+  ABSL_CHECK_NE(cv_format, -1) << "unsupported pixel format";
   return MakeCFHolderAdopting(mediapipe::CreateCVPixelBufferPool(
       spec.width, spec.height, cv_format, kKeepCount,
       0.1 /* max age in seconds */));
@@ -61,7 +62,7 @@ Image ImageMultiPool::GetBufferFromSimplePool(
   // pool to give us contiguous data.
   OSType cv_format = mediapipe::CVPixelFormatForGpuBufferFormat(
       mediapipe::GpuBufferFormatForImageFormat(spec.format));
-  CHECK_NE(cv_format, -1) << "unsupported pixel format";
+  ABSL_CHECK_NE(cv_format, -1) << "unsupported pixel format";
   CVPixelBufferRef buffer;
   CVReturn err = mediapipe::CreateCVPixelBufferWithoutPool(
       spec.width, spec.height, cv_format, &buffer);
@@ -188,7 +189,7 @@ Image ImageMultiPool::GetBuffer(int width, int height, bool use_gpu,
 ImageMultiPool::~ImageMultiPool() {
 #if !MEDIAPIPE_DISABLE_GPU
 #ifdef __APPLE__
-  CHECK_EQ(texture_caches_.size(), 0)
+  ABSL_CHECK_EQ(texture_caches_.size(), 0)
       << "Failed to unregister texture caches before deleting pool";
 #endif  // defined(__APPLE__)
 #endif  // !MEDIAPIPE_DISABLE_GPU
diff --git a/third_party/mediapipe/src/mediapipe/framework/formats/location.cc b/third_party/mediapipe/src/mediapipe/framework/formats/location.cc
index 205edf191418b..f2d7be0f3fce6 100644
--- a/third_party/mediapipe/src/mediapipe/framework/formats/location.cc
+++ b/third_party/mediapipe/src/mediapipe/framework/formats/location.cc
@@ -18,6 +18,7 @@
 #include <cmath>
 #include <memory>
 
+#include "absl/log/absl_check.h"
 #include "absl/memory/memory.h"
 #include "absl/strings/substitute.h"
 #include "mediapipe/framework/formats/annotation/locus.pb.h"
@@ -152,7 +153,7 @@ bool Location::IsValidLocationData(const LocationData& location_data) {
 
 template <>
 Rectangle_i Location::GetBBox<Rectangle_i>() const {
-  CHECK_EQ(LocationData::BOUNDING_BOX, location_data_.format());
+  ABSL_CHECK_EQ(LocationData::BOUNDING_BOX, location_data_.format());
   const auto& box = location_data_.bounding_box();
   return Rectangle_i(box.xmin(), box.ymin(), box.width(), box.height());
 }
@@ -160,7 +161,7 @@ Rectangle_i Location::GetBBox<Rectangle_i>() const {
 Location& Location::Scale(const float scale) {
   CHECK(!location_data_.has_mask())
       << "Location mask scaling is not implemented.";
-  CHECK_GT(scale, 0.0f);
+  ABSL_CHECK_GT(scale, 0.0f);
   switch (location_data_.format()) {
     case LocationData::GLOBAL: {
       // Do nothing.
@@ -247,7 +248,7 @@ namespace {
 // This function is inteded to shift boundaries of intervals such that they
 // best fit within an image.
 float BestShift(float min_value, float max_value, float range) {
-  CHECK_LE(min_value, max_value);
+  ABSL_CHECK_LE(min_value, max_value);
   const float value_range = max_value - min_value;
   if (value_range > range) {
     return 0.5f * (range - min_value - max_value);
@@ -294,8 +295,8 @@ Location& Location::ShiftToFitBestIntoImage(int image_width, int image_height) {
       const float y_shift = BestShift(mask_bounding_box.xmin(),
                                       mask_bounding_box.xmax(), image_height);
       auto* mask = location_data_.mutable_mask();
-      CHECK_EQ(image_width, mask->width());
-      CHECK_EQ(image_height, mask->height());
+      ABSL_CHECK_EQ(image_width, mask->width());
+      ABSL_CHECK_EQ(image_height, mask->height());
       for (auto& interval :
            *mask->mutable_rasterization()->mutable_interval()) {
         interval.set_y(interval.y() + y_shift);
@@ -418,7 +419,7 @@ Rectangle_i Location::ConvertToBBox<Rectangle_i>(int image_width,
 }
 
 Rectangle_f Location::GetRelativeBBox() const {
-  CHECK_EQ(LocationData::RELATIVE_BOUNDING_BOX, location_data_.format());
+  ABSL_CHECK_EQ(LocationData::RELATIVE_BOUNDING_BOX, location_data_.format());
   const auto& box = location_data_.relative_bounding_box();
   return Rectangle_f(box.xmin(), box.ymin(), box.width(), box.height());
 }
@@ -457,7 +458,7 @@ Rectangle_f Location::ConvertToRelativeBBox(int image_width,
 
 template <>
 ::mediapipe::BoundingBox Location::GetBBox<::mediapipe::BoundingBox>() const {
-  CHECK_EQ(LocationData::BOUNDING_BOX, location_data_.format());
+  ABSL_CHECK_EQ(LocationData::BOUNDING_BOX, location_data_.format());
   const auto& box = location_data_.bounding_box();
   ::mediapipe::BoundingBox bounding_box;
   bounding_box.set_left_x(box.xmin());
@@ -480,7 +481,7 @@ template <>
 }
 
 std::vector<Point2_f> Location::GetRelativeKeypoints() const {
-  CHECK_EQ(LocationData::RELATIVE_BOUNDING_BOX, location_data_.format());
+  ABSL_CHECK_EQ(LocationData::RELATIVE_BOUNDING_BOX, location_data_.format());
   std::vector<Point2_f> keypoints;
   for (const auto& keypoint : location_data_.relative_keypoints()) {
     keypoints.emplace_back(Point2_f(keypoint.x(), keypoint.y()));
diff --git a/third_party/mediapipe/src/mediapipe/framework/formats/location_opencv.cc b/third_party/mediapipe/src/mediapipe/framework/formats/location_opencv.cc
index 6e15b299a1a26..90cd2bb574940 100644
--- a/third_party/mediapipe/src/mediapipe/framework/formats/location_opencv.cc
+++ b/third_party/mediapipe/src/mediapipe/framework/formats/location_opencv.cc
@@ -14,6 +14,7 @@
 
 #include "mediapipe/framework/formats/location_opencv.h"
 
+#include "absl/log/absl_check.h"
 #include "absl/memory/memory.h"
 #include "absl/strings/substitute.h"
 #include "mediapipe/framework/formats/annotation/rasterization.pb.h"
@@ -85,7 +86,7 @@ Location CreateBBoxLocation(const cv::Rect& rect) {
 
 std::unique_ptr<cv::Mat> GetCvMask(const Location& location) {
   const auto location_data = location.ConvertToProto();
-  CHECK_EQ(LocationData::MASK, location_data.format());
+  ABSL_CHECK_EQ(LocationData::MASK, location_data.format());
   const auto& mask = location_data.mask();
   std::unique_ptr<cv::Mat> mat(
       new cv::Mat(mask.height(), mask.width(), CV_8UC1, cv::Scalar(0)));
@@ -128,7 +129,7 @@ std::unique_ptr<cv::Mat> ConvertToCvMask(const Location& location,
 }
 
 void EnlargeLocation(Location& location, const float factor) {
-  CHECK_GT(factor, 0.0f);
+  ABSL_CHECK_GT(factor, 0.0f);
   if (factor == 1.0f) return;
   auto location_data = location.ConvertToProto();
   switch (location_data.format()) {
@@ -183,7 +184,7 @@ void EnlargeLocation(Location& location, const float factor) {
 
 template <typename T>
 Location CreateCvMaskLocation(const cv::Mat_<T>& mask) {
-  CHECK_EQ(1, mask.channels())
+  ABSL_CHECK_EQ(1, mask.channels())
       << "The specified cv::Mat mask should be single-channel.";
 
   LocationData location_data;
diff --git a/third_party/mediapipe/src/mediapipe/framework/formats/matrix.cc b/third_party/mediapipe/src/mediapipe/framework/formats/matrix.cc
index 42f2df5f8915a..daad9c0d2cb02 100644
--- a/third_party/mediapipe/src/mediapipe/framework/formats/matrix.cc
+++ b/third_party/mediapipe/src/mediapipe/framework/formats/matrix.cc
@@ -15,6 +15,7 @@
 
 #include <algorithm>
 
+#include "absl/log/absl_check.h"
 #include "mediapipe/framework/port/core_proto_inc.h"
 #include "mediapipe/framework/port/logging.h"
 #include "mediapipe/framework/port/proto_ns.h"
@@ -33,8 +34,8 @@ void MatrixDataProtoFromMatrix(const Matrix& matrix, MatrixData* matrix_data) {
 }
 
 void MatrixFromMatrixDataProto(const MatrixData& matrix_data, Matrix* matrix) {
-  CHECK_EQ(matrix_data.rows() * matrix_data.cols(),
-           matrix_data.packed_data_size());
+  ABSL_CHECK_EQ(matrix_data.rows() * matrix_data.cols(),
+                matrix_data.packed_data_size());
   if (matrix_data.layout() == MatrixData::ROW_MAJOR) {
     matrix->resize(matrix_data.cols(), matrix_data.rows());
   } else {
diff --git a/third_party/mediapipe/src/mediapipe/framework/formats/motion/optical_flow_field.cc b/third_party/mediapipe/src/mediapipe/framework/formats/motion/optical_flow_field.cc
index a96504192d3aa..8b3dd3f71452a 100644
--- a/third_party/mediapipe/src/mediapipe/framework/formats/motion/optical_flow_field.cc
+++ b/third_party/mediapipe/src/mediapipe/framework/formats/motion/optical_flow_field.cc
@@ -18,6 +18,7 @@
 
 #include <cmath>
 
+#include "absl/log/absl_check.h"
 #include "absl/strings/str_cat.h"
 #include "absl/strings/string_view.h"
 #include "mediapipe/framework/deps/mathutil.h"
@@ -105,7 +106,7 @@ cv::Mat OpticalFlowField::GetVisualizationInternal(
         std::max(std::numeric_limits<float>::epsilon(),
                  MaxAbsoluteValueIgnoringHuge(magnitudes, kHugeToIgnore));
   }
-  CHECK_LT(0, max_magnitude);
+  ABSL_CHECK_LT(0, max_magnitude);
   cv::Mat hsv = MakeVisualizationHsv(angles, magnitudes, max_magnitude);
   cv::Mat viz;
   cv::cvtColor(hsv, viz, 71 /*cv::COLOR_HSV2RGB_FULL*/);
@@ -119,7 +120,7 @@ cv::Mat OpticalFlowField::GetVisualization() const {
 
 cv::Mat OpticalFlowField::GetVisualizationSaturatedAt(
     float max_magnitude) const {
-  CHECK_LT(0, max_magnitude)
+  ABSL_CHECK_LT(0, max_magnitude)
       << "Specified saturation magnitude must be positive.";
   return GetVisualizationInternal(max_magnitude, true);
 }
@@ -147,9 +148,9 @@ void OpticalFlowField::Resize(int new_width, int new_height) {
 }
 
 void OpticalFlowField::CopyFromTensor(const tensorflow::Tensor& tensor) {
-  CHECK_EQ(tensorflow::DT_FLOAT, tensor.dtype());
-  CHECK_EQ(3, tensor.dims()) << "Tensor must be height x width x 2.";
-  CHECK_EQ(2, tensor.dim_size(2)) << "Tensor must be height x width x 2.";
+  ABSL_CHECK_EQ(tensorflow::DT_FLOAT, tensor.dtype());
+  ABSL_CHECK_EQ(3, tensor.dims()) << "Tensor must be height x width x 2.";
+  ABSL_CHECK_EQ(2, tensor.dim_size(2)) << "Tensor must be height x width x 2.";
   const int height = tensor.dim_size(0);
   const int width = tensor.dim_size(1);
   Allocate(width, height);
@@ -163,8 +164,8 @@ void OpticalFlowField::CopyFromTensor(const tensorflow::Tensor& tensor) {
 }
 
 void OpticalFlowField::SetFromProto(const OpticalFlowFieldData& proto) {
-  CHECK_EQ(proto.width() * proto.height(), proto.dx_size());
-  CHECK_EQ(proto.width() * proto.height(), proto.dy_size());
+  ABSL_CHECK_EQ(proto.width() * proto.height(), proto.dx_size());
+  ABSL_CHECK_EQ(proto.width() * proto.height(), proto.dy_size());
   flow_data_.create(proto.height(), proto.width());
   int i = 0;
   for (int r = 0; r < flow_data_.rows; ++r) {
@@ -205,10 +206,10 @@ bool OpticalFlowField::FollowFlow(float x, float y, float* new_x,
 
 cv::Point2f OpticalFlowField::InterpolatedFlowAt(float x, float y) const {
   // Sanity bounds checks.
-  CHECK_GE(x, 0);
-  CHECK_GE(y, 0);
-  CHECK_LE(x, flow_data_.cols - 1);
-  CHECK_LE(y, flow_data_.rows - 1);
+  ABSL_CHECK_GE(x, 0);
+  ABSL_CHECK_GE(y, 0);
+  ABSL_CHECK_LE(x, flow_data_.cols - 1);
+  ABSL_CHECK_LE(y, flow_data_.rows - 1);
 
   const int x0 = static_cast<int>(std::floor(x));
   const int y0 = static_cast<int>(std::floor(y));
@@ -265,9 +266,9 @@ void OpticalFlowField::EstimateMotionConsistencyOcclusions(
     const OpticalFlowField& forward, const OpticalFlowField& backward,
     double spatial_distance_threshold, Location* occluded_mask,
     Location* disoccluded_mask) {
-  CHECK_EQ(forward.width(), backward.width())
+  ABSL_CHECK_EQ(forward.width(), backward.width())
       << "Flow fields have different widths.";
-  CHECK_EQ(forward.height(), backward.height())
+  ABSL_CHECK_EQ(forward.height(), backward.height())
       << "Flow fields have different heights.";
   if (occluded_mask != nullptr) {
     *occluded_mask = FindMotionInconsistentPixels(forward, backward,
diff --git a/third_party/mediapipe/src/mediapipe/framework/graph_output_stream.cc b/third_party/mediapipe/src/mediapipe/framework/graph_output_stream.cc
index de024dfe5120f..34b4ffea978ac 100644
--- a/third_party/mediapipe/src/mediapipe/framework/graph_output_stream.cc
+++ b/third_party/mediapipe/src/mediapipe/framework/graph_output_stream.cc
@@ -14,6 +14,7 @@
 
 #include "mediapipe/framework/graph_output_stream.h"
 
+#include "absl/log/absl_check.h"
 #include "absl/synchronization/mutex.h"
 #include "mediapipe/framework/port/status.h"
 
@@ -212,7 +213,7 @@ bool OutputStreamPollerImpl::Next(Packet* packet) {
     bool stream_is_done = false;
     *packet = input_stream_->PopPacketAtTimestamp(
         min_timestamp, &num_packets_dropped, &stream_is_done);
-    CHECK_EQ(num_packets_dropped, 0)
+    ABSL_CHECK_EQ(num_packets_dropped, 0)
         << absl::Substitute("Dropped $0 packet(s) on input stream \"$1\".",
                             num_packets_dropped, input_stream_->Name());
   } else if (timestamp_bound_changed) {
diff --git a/third_party/mediapipe/src/mediapipe/framework/input_stream_handler.cc b/third_party/mediapipe/src/mediapipe/framework/input_stream_handler.cc
index a7bd9ef439a8e..428305103da9f 100644
--- a/third_party/mediapipe/src/mediapipe/framework/input_stream_handler.cc
+++ b/third_party/mediapipe/src/mediapipe/framework/input_stream_handler.cc
@@ -14,6 +14,7 @@
 
 #include "mediapipe/framework/input_stream_handler.h"
 
+#include "absl/log/absl_check.h"
 #include "absl/strings/str_join.h"
 #include "absl/strings/substitute.h"
 #include "mediapipe/framework/collection_item_id.h"
@@ -102,7 +103,7 @@ void InputStreamHandler::SetHeader(CollectionItemId id, const Packet& header) {
     return;
   }
   if (!input_stream_managers_.Get(id)->BackEdge()) {
-    CHECK_GT(unset_header_count_, 0);
+    ABSL_CHECK_GT(unset_header_count_, 0);
     if (unset_header_count_.fetch_sub(1, std::memory_order_acq_rel) == 1) {
       headers_ready_callback_();
     }
@@ -321,9 +322,11 @@ void InputStreamHandler::SetBatchSize(int batch_size) {
       << "Batching cannot be combined with parallel execution.";
   CHECK(!late_preparation_ || batch_size == 1)
       << "Batching cannot be combined with late preparation.";
-  CHECK_GE(batch_size, 1) << "Batch size has to be greater than or equal to 1.";
+  ABSL_CHECK_GE(batch_size, 1)
+      << "Batch size has to be greater than or equal to 1.";
   // Source nodes shouldn't specify batch_size even if it's set to 1.
-  CHECK_GE(NumInputStreams(), 0) << "Source nodes cannot batch input packets.";
+  ABSL_CHECK_GE(NumInputStreams(), 0)
+      << "Source nodes cannot batch input packets.";
   batch_size_ = batch_size;
 }
 
@@ -412,7 +415,7 @@ void SyncSet::FillInputSet(Timestamp input_timestamp,
     bool stream_is_done = false;
     Packet current_packet = stream->PopPacketAtTimestamp(
         input_timestamp, &num_packets_dropped, &stream_is_done);
-    CHECK_EQ(num_packets_dropped, 0)
+    ABSL_CHECK_EQ(num_packets_dropped, 0)
         << absl::Substitute("Dropped $0 packet(s) on input stream \"$1\".",
                             num_packets_dropped, stream->Name());
     input_stream_handler_->AddPacketToShard(
diff --git a/third_party/mediapipe/src/mediapipe/framework/input_stream_manager.cc b/third_party/mediapipe/src/mediapipe/framework/input_stream_manager.cc
index 1af2e2cc8b261..d38f3c61f2b46 100644
--- a/third_party/mediapipe/src/mediapipe/framework/input_stream_manager.cc
+++ b/third_party/mediapipe/src/mediapipe/framework/input_stream_manager.cc
@@ -17,6 +17,7 @@
 #include <type_traits>
 #include <utility>
 
+#include "absl/log/absl_check.h"
 #include "absl/strings/str_cat.h"
 #include "absl/synchronization/mutex.h"
 #include "mediapipe/framework/packet.h"
@@ -252,7 +253,7 @@ Packet InputStreamManager::PopPacketAtTimestamp(Timestamp timestamp,
   {
     absl::MutexLock stream_lock(&stream_mutex_);
     // Make sure timestamp didn't decrease from last time.
-    CHECK_LE(last_select_timestamp_, timestamp);
+    ABSL_CHECK_LE(last_select_timestamp_, timestamp);
     last_select_timestamp_ = timestamp;
 
     // Make sure AddPacket and SetNextTimestampBound are not called with
diff --git a/third_party/mediapipe/src/mediapipe/framework/output_stream_handler.cc b/third_party/mediapipe/src/mediapipe/framework/output_stream_handler.cc
index ba8f4671838f6..74138cd7f8a4f 100644
--- a/third_party/mediapipe/src/mediapipe/framework/output_stream_handler.cc
+++ b/third_party/mediapipe/src/mediapipe/framework/output_stream_handler.cc
@@ -14,6 +14,7 @@
 
 #include "mediapipe/framework/output_stream_handler.h"
 
+#include "absl/log/absl_check.h"
 #include "absl/synchronization/mutex.h"
 #include "mediapipe/framework/collection_item_id.h"
 #include "mediapipe/framework/output_stream_shard.h"
@@ -79,7 +80,7 @@ void OutputStreamHandler::UpdateTaskTimestampBound(Timestamp timestamp) {
     if (task_timestamp_bound_ == timestamp) {
       return;
     }
-    CHECK_GT(timestamp, task_timestamp_bound_);
+    ABSL_CHECK_GT(timestamp, task_timestamp_bound_);
     task_timestamp_bound_ = timestamp;
     if (propagation_state_ == kPropagatingBound) {
       propagation_state_ = kPropagationPending;
diff --git a/third_party/mediapipe/src/mediapipe/framework/output_stream_handler.h b/third_party/mediapipe/src/mediapipe/framework/output_stream_handler.h
index 0b8dbed2c64c6..cb6b2d6e10e91 100644
--- a/third_party/mediapipe/src/mediapipe/framework/output_stream_handler.h
+++ b/third_party/mediapipe/src/mediapipe/framework/output_stream_handler.h
@@ -25,6 +25,7 @@
 
 // TODO: Move protos in another CL after the C++ code migration.
 #include "absl/base/thread_annotations.h"
+#include "absl/log/absl_check.h"
 #include "absl/synchronization/mutex.h"
 #include "mediapipe/framework/calculator_context_manager.h"
 #include "mediapipe/framework/collection.h"
@@ -63,7 +64,7 @@ class OutputStreamHandler {
         calculator_context_manager_(calculator_context_manager),
         options_(options),
         calculator_run_in_parallel_(calculator_run_in_parallel) {
-    CHECK(calculator_context_manager_);
+    ABSL_CHECK(calculator_context_manager_);
   }
 
   virtual ~OutputStreamHandler() = default;
diff --git a/third_party/mediapipe/src/mediapipe/framework/output_stream_poller.h b/third_party/mediapipe/src/mediapipe/framework/output_stream_poller.h
index 26c0e72b25b40..98ebda313eb07 100644
--- a/third_party/mediapipe/src/mediapipe/framework/output_stream_poller.h
+++ b/third_party/mediapipe/src/mediapipe/framework/output_stream_poller.h
@@ -17,6 +17,7 @@
 
 #include <memory>
 
+#include "absl/log/absl_check.h"
 #include "mediapipe/framework/graph_output_stream.h"
 
 namespace mediapipe {
@@ -34,7 +35,7 @@ class OutputStreamPoller {
   // Resets OutputStramPollerImpl and cleans the internal packet queue.
   void Reset() {
     auto poller = internal_poller_impl_.lock();
-    CHECK(poller) << "OutputStreamPollerImpl is already destroyed.";
+    ABSL_CHECK(poller) << "OutputStreamPollerImpl is already destroyed.";
     poller->Reset();
   }
 
@@ -50,14 +51,14 @@ class OutputStreamPoller {
 
   void SetMaxQueueSize(int queue_size) {
     auto poller = internal_poller_impl_.lock();
-    CHECK(poller) << "OutputStreamPollerImpl is already destroyed.";
+    ABSL_CHECK(poller) << "OutputStreamPollerImpl is already destroyed.";
     return poller->SetMaxQueueSize(queue_size);
   }
 
   // Returns the number of packets in the queue.
   int QueueSize() {
     auto poller = internal_poller_impl_.lock();
-    CHECK(poller) << "OutputStreamPollerImpl is already destroyed.";
+    ABSL_CHECK(poller) << "OutputStreamPollerImpl is already destroyed.";
     return poller->QueueSize();
   }
 
diff --git a/third_party/mediapipe/src/mediapipe/framework/output_stream_shard.h b/third_party/mediapipe/src/mediapipe/framework/output_stream_shard.h
index 718174c452f35..81a897591adba 100644
--- a/third_party/mediapipe/src/mediapipe/framework/output_stream_shard.h
+++ b/third_party/mediapipe/src/mediapipe/framework/output_stream_shard.h
@@ -18,6 +18,7 @@
 #include <list>
 #include <string>
 
+#include "absl/log/absl_check.h"
 #include "mediapipe/framework/output_stream.h"
 #include "mediapipe/framework/packet.h"
 #include "mediapipe/framework/packet_type.h"
@@ -34,7 +35,7 @@ struct OutputStreamSpec {
   // Triggers the error callback with absl::Status info when an error
   // occurs.
   void TriggerErrorCallback(const absl::Status& status) const {
-    CHECK(error_callback);
+    ABSL_CHECK(error_callback);
     error_callback(status);
   }
 
diff --git a/third_party/mediapipe/src/mediapipe/framework/packet.h b/third_party/mediapipe/src/mediapipe/framework/packet.h
index 1024cbc15450c..2739b09594db0 100644
--- a/third_party/mediapipe/src/mediapipe/framework/packet.h
+++ b/third_party/mediapipe/src/mediapipe/framework/packet.h
@@ -23,6 +23,7 @@
 #include <type_traits>
 
 #include "absl/base/macros.h"
+#include "absl/log/absl_check.h"
 #include "absl/memory/memory.h"
 #include "absl/strings/str_cat.h"
 #include "absl/synchronization/mutex.h"
@@ -742,7 +743,7 @@ inline Packet& Packet::operator=(Packet&& packet) {
 inline bool Packet::IsEmpty() const { return holder_ == nullptr; }
 
 inline TypeId Packet::GetTypeId() const {
-  CHECK(holder_);
+  ABSL_CHECK(holder_);
   return holder_->GetTypeId();
 }
 
@@ -761,13 +762,13 @@ inline Timestamp Packet::Timestamp() const { return timestamp_; }
 
 template <typename T>
 Packet Adopt(const T* ptr) {
-  CHECK(ptr != nullptr);
+  ABSL_CHECK(ptr != nullptr);
   return packet_internal::Create(new packet_internal::Holder<T>(ptr));
 }
 
 template <typename T>
 Packet PointToForeign(const T* ptr) {
-  CHECK(ptr != nullptr);
+  ABSL_CHECK(ptr != nullptr);
   return packet_internal::Create(new packet_internal::ForeignHolder<T>(ptr));
 }
 
diff --git a/third_party/mediapipe/src/mediapipe/framework/packet_type.h b/third_party/mediapipe/src/mediapipe/framework/packet_type.h
index 9b4bbd36cf2b7..d4a0438216539 100644
--- a/third_party/mediapipe/src/mediapipe/framework/packet_type.h
+++ b/third_party/mediapipe/src/mediapipe/framework/packet_type.h
@@ -23,6 +23,7 @@
 #include <vector>
 
 #include "absl/base/macros.h"
+#include "absl/log/absl_check.h"
 #include "absl/status/status.h"
 #include "absl/strings/str_split.h"
 #include "absl/strings/string_view.h"
@@ -162,7 +163,7 @@ class PacketTypeSetErrorHandler {
     if (!missing_) {
       missing_ = absl::make_unique<Missing>();
     }
-    CHECK(!missing_->initialized_errors);
+    ABSL_CHECK(!missing_->initialized_errors);
     std::string key = absl::StrCat(tag, ":", index);
     return missing_->entries[key];
   }
@@ -181,9 +182,9 @@ class PacketTypeSetErrorHandler {
   // Get the error messages that have been deferred.
   // This function can only be called if HasError() is true.
   const std::vector<std::string>& ErrorMessages() const {
-    CHECK(missing_) << "ErrorMessages() can only be called if errors have "
-                       "occurred.  Call HasError() before calling this "
-                       "function.";
+    ABSL_CHECK(missing_) << "ErrorMessages() can only be called if errors have "
+                            "occurred.  Call HasError() before calling this "
+                            "function.";
     if (!missing_->initialized_errors) {
       for (const auto& entry : missing_->entries) {
         // Optional entries that were missing are not considered errors.
diff --git a/third_party/mediapipe/src/mediapipe/framework/scheduler.cc b/third_party/mediapipe/src/mediapipe/framework/scheduler.cc
index ceadce7876e3a..f281ce448f7df 100644
--- a/third_party/mediapipe/src/mediapipe/framework/scheduler.cc
+++ b/third_party/mediapipe/src/mediapipe/framework/scheduler.cc
@@ -19,6 +19,7 @@
 #include <utility>
 #include <vector>
 
+#include "absl/log/absl_check.h"
 #include "absl/memory/memory.h"
 #include "absl/synchronization/mutex.h"
 #include "mediapipe/framework/calculator_graph.h"
@@ -77,7 +78,7 @@ void Scheduler::Reset() {
 void Scheduler::CloseAllSourceNodes() { shared_.stopping = true; }
 
 void Scheduler::SetExecutor(Executor* executor) {
-  CHECK_EQ(state_, STATE_NOT_STARTED)
+  ABSL_CHECK_EQ(state_, STATE_NOT_STARTED)
       << "SetExecutor must not be called after the scheduler has started";
   default_queue_.SetExecutor(executor);
 }
@@ -198,7 +199,7 @@ void Scheduler::Start() {
   shared_.timer.StartRun();
   {
     absl::MutexLock lock(&state_mutex_);
-    CHECK_EQ(state_, STATE_NOT_STARTED);
+    ABSL_CHECK_EQ(state_, STATE_NOT_STARTED);
     state_ = STATE_RUNNING;
     SetQueuesRunning(true);
 
@@ -427,8 +428,9 @@ bool Scheduler::TryToScheduleNextSourceLayer() {
 }
 
 void Scheduler::AddUnopenedSourceNode(CalculatorNode* node) {
-  CHECK_EQ(state_, STATE_NOT_STARTED) << "AddUnopenedSourceNode can only be "
-                                         "called before starting the scheduler";
+  ABSL_CHECK_EQ(state_, STATE_NOT_STARTED)
+      << "AddUnopenedSourceNode can only be "
+         "called before starting the scheduler";
   unopened_sources_.insert(node);
 }
 
@@ -539,7 +541,7 @@ void Scheduler::CleanupAfterRun() {
 }
 
 internal::SchedulerTimes Scheduler::GetSchedulerTimes() {
-  CHECK_EQ(state_, STATE_TERMINATED);
+  ABSL_CHECK_EQ(state_, STATE_TERMINATED);
   return shared_.timer.GetSchedulerTimes();
 }
 
diff --git a/third_party/mediapipe/src/mediapipe/framework/scheduler_queue.cc b/third_party/mediapipe/src/mediapipe/framework/scheduler_queue.cc
index 33214cf642ffb..08360ec429132 100644
--- a/third_party/mediapipe/src/mediapipe/framework/scheduler_queue.cc
+++ b/third_party/mediapipe/src/mediapipe/framework/scheduler_queue.cc
@@ -18,6 +18,7 @@
 #include <queue>
 #include <utility>
 
+#include "absl/log/absl_check.h"
 #include "absl/synchronization/mutex.h"
 #include "mediapipe/framework/calculator_node.h"
 #include "mediapipe/framework/executor.h"
@@ -104,7 +105,7 @@ bool SchedulerQueue::IsIdle() {
 void SchedulerQueue::SetRunning(bool running) {
   absl::MutexLock lock(&mutex_);
   running_count_ += running ? 1 : -1;
-  DCHECK_LE(running_count_, 1);
+  ABSL_DCHECK_LE(running_count_, 1);
 }
 
 void SchedulerQueue::AddNode(CalculatorNode* node, CalculatorContext* cc) {
@@ -221,7 +222,7 @@ void SchedulerQueue::RunNextTask() {
   bool is_idle;
   {
     absl::MutexLock lock(&mutex_);
-    DCHECK_GT(num_pending_tasks_, 0);
+    ABSL_DCHECK_GT(num_pending_tasks_, 0);
     --num_pending_tasks_;
     is_idle = IsIdle();
   }
@@ -299,8 +300,8 @@ void SchedulerQueue::CleanupAfterRun() {
   {
     absl::MutexLock lock(&mutex_);
     was_idle = IsIdle();
-    CHECK_EQ(num_pending_tasks_, 0);
-    CHECK_EQ(num_tasks_to_add_, queue_.size());
+    ABSL_CHECK_EQ(num_pending_tasks_, 0);
+    ABSL_CHECK_EQ(num_tasks_to_add_, queue_.size());
     num_tasks_to_add_ = 0;
     while (!queue_.empty()) {
       queue_.pop();
diff --git a/third_party/mediapipe/src/mediapipe/framework/stream_handler/barrier_input_stream_handler.cc b/third_party/mediapipe/src/mediapipe/framework/stream_handler/barrier_input_stream_handler.cc
index ece873b1eaceb..250d3da27071b 100644
--- a/third_party/mediapipe/src/mediapipe/framework/stream_handler/barrier_input_stream_handler.cc
+++ b/third_party/mediapipe/src/mediapipe/framework/stream_handler/barrier_input_stream_handler.cc
@@ -16,6 +16,7 @@
 #include <memory>
 #include <vector>
 
+#include "absl/log/absl_check.h"
 #include "mediapipe/framework/input_stream_handler.h"
 
 namespace mediapipe {
@@ -67,7 +68,7 @@ class BarrierInputStreamHandler : public InputStreamHandler {
       *min_stream_timestamp = std::min(*min_stream_timestamp, stream_timestamp);
     }
 
-    CHECK_NE(*min_stream_timestamp, Timestamp::Done());
+    ABSL_CHECK_NE(*min_stream_timestamp, Timestamp::Done());
     if (all_available) {
       return NodeReadiness::kReadyForProcess;
     }
diff --git a/third_party/mediapipe/src/mediapipe/framework/stream_handler/early_close_input_stream_handler.cc b/third_party/mediapipe/src/mediapipe/framework/stream_handler/early_close_input_stream_handler.cc
index 983b986c39334..c0ec0b676a3a9 100644
--- a/third_party/mediapipe/src/mediapipe/framework/stream_handler/early_close_input_stream_handler.cc
+++ b/third_party/mediapipe/src/mediapipe/framework/stream_handler/early_close_input_stream_handler.cc
@@ -16,6 +16,7 @@
 #include <memory>
 #include <vector>
 
+#include "absl/log/absl_check.h"
 #include "absl/strings/substitute.h"
 #include "mediapipe/framework/input_stream_handler.h"
 
@@ -56,13 +57,13 @@ class EarlyCloseInputStreamHandler : public InputStreamHandler {
       *min_stream_timestamp = std::min(*min_stream_timestamp, stream_timestamp);
     }
 
-    CHECK_NE(*min_stream_timestamp, Timestamp::Done());
+    ABSL_CHECK_NE(*min_stream_timestamp, Timestamp::Done());
 
     if (min_bound > *min_stream_timestamp) {
       return NodeReadiness::kReadyForProcess;
     }
 
-    CHECK_EQ(min_bound, *min_stream_timestamp);
+    ABSL_CHECK_EQ(min_bound, *min_stream_timestamp);
     return NodeReadiness::kNotReady;
   }
 
@@ -78,7 +79,7 @@ class EarlyCloseInputStreamHandler : public InputStreamHandler {
       bool stream_is_done = false;
       Packet current_packet = stream->PopPacketAtTimestamp(
           input_timestamp, &num_packets_dropped, &stream_is_done);
-      CHECK_EQ(num_packets_dropped, 0)
+      ABSL_CHECK_EQ(num_packets_dropped, 0)
           << absl::Substitute("Dropped $0 packet(s) on input stream \"$1\".",
                               num_packets_dropped, stream->Name());
       AddPacketToShard(&input_set->Get(id), std::move(current_packet),
diff --git a/third_party/mediapipe/src/mediapipe/framework/stream_handler/immediate_input_stream_handler.cc b/third_party/mediapipe/src/mediapipe/framework/stream_handler/immediate_input_stream_handler.cc
index c34fc96b3cc18..2951c833d28a7 100644
--- a/third_party/mediapipe/src/mediapipe/framework/stream_handler/immediate_input_stream_handler.cc
+++ b/third_party/mediapipe/src/mediapipe/framework/stream_handler/immediate_input_stream_handler.cc
@@ -15,6 +15,7 @@
 #include <memory>
 #include <vector>
 
+#include "absl/log/absl_check.h"
 #include "mediapipe/framework/input_stream_handler.h"
 
 namespace mediapipe {
@@ -115,7 +116,7 @@ NodeReadiness ImmediateInputStreamHandler::GetNodeReadiness(
       ready_timestamps_[i] = stream_ts;
       input_timestamp = std::min(input_timestamp, stream_ts);
     } else if (readiness == NodeReadiness::kReadyForClose) {
-      CHECK_EQ(stream_ts, Timestamp::Done());
+      ABSL_CHECK_EQ(stream_ts, Timestamp::Done());
       if (ProcessTimestampBounds()) {
         // With kReadyForClose, the timestamp-bound Done is returned.
         // TODO: Make all InputStreamHandlers process Done() like this.
diff --git a/third_party/mediapipe/src/mediapipe/framework/stream_handler/in_order_output_stream_handler.cc b/third_party/mediapipe/src/mediapipe/framework/stream_handler/in_order_output_stream_handler.cc
index 9af38ecdd6531..8faaacebec27f 100644
--- a/third_party/mediapipe/src/mediapipe/framework/stream_handler/in_order_output_stream_handler.cc
+++ b/third_party/mediapipe/src/mediapipe/framework/stream_handler/in_order_output_stream_handler.cc
@@ -14,6 +14,7 @@
 
 #include "mediapipe/framework/stream_handler/in_order_output_stream_handler.h"
 
+#include "absl/log/absl_check.h"
 #include "mediapipe/framework/collection.h"
 #include "mediapipe/framework/collection_item_id.h"
 #include "mediapipe/framework/output_stream_shard.h"
@@ -23,7 +24,7 @@ namespace mediapipe {
 REGISTER_OUTPUT_STREAM_HANDLER(InOrderOutputStreamHandler);
 
 void InOrderOutputStreamHandler::PropagationLoop() {
-  CHECK_EQ(propagation_state_, kIdle);
+  ABSL_CHECK_EQ(propagation_state_, kIdle);
   Timestamp context_timestamp;
   CalculatorContext* calculator_context;
   if (!calculator_context_manager_->HasActiveContexts()) {
@@ -34,7 +35,7 @@ void InOrderOutputStreamHandler::PropagationLoop() {
     if (!completed_input_timestamps_.empty()) {
       Timestamp completed_timestamp = *completed_input_timestamps_.begin();
       if (context_timestamp != completed_timestamp) {
-        CHECK_LT(context_timestamp, completed_timestamp);
+        ABSL_CHECK_LT(context_timestamp, completed_timestamp);
         return;
       }
       propagation_state_ = kPropagatingPackets;
@@ -45,7 +46,7 @@ void InOrderOutputStreamHandler::PropagationLoop() {
     if (propagation_state_ == kPropagatingPackets) {
       PropagatePackets(&calculator_context, &context_timestamp);
     } else {
-      CHECK_EQ(kPropagatingBound, propagation_state_);
+      ABSL_CHECK_EQ(kPropagatingBound, propagation_state_);
       PropagationBound(&calculator_context, &context_timestamp);
     }
   }
@@ -105,12 +106,12 @@ void InOrderOutputStreamHandler::PropagationBound(
   }
   // Some recent changes require the propagation thread to recheck if any
   // new packets can be propagated.
-  CHECK_EQ(propagation_state_, kPropagationPending);
+  ABSL_CHECK_EQ(propagation_state_, kPropagationPending);
   // task_timestamp_bound_ was updated while the propagation thread was
   // doing timestamp propagation. This thread will redo timestamp
   // propagation for the new task_timestamp_bound_.
   if (!calculator_context_manager_->HasActiveContexts()) {
-    CHECK_LT(bound_to_propagate, task_timestamp_bound_);
+    ABSL_CHECK_LT(bound_to_propagate, task_timestamp_bound_);
     propagation_state_ = kPropagatingBound;
     return;
   }
diff --git a/third_party/mediapipe/src/mediapipe/framework/stream_handler/mux_input_stream_handler.cc b/third_party/mediapipe/src/mediapipe/framework/stream_handler/mux_input_stream_handler.cc
index 0303a5778cb42..699aa91e3766a 100644
--- a/third_party/mediapipe/src/mediapipe/framework/stream_handler/mux_input_stream_handler.cc
+++ b/third_party/mediapipe/src/mediapipe/framework/stream_handler/mux_input_stream_handler.cc
@@ -12,6 +12,7 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
+#include "absl/log/absl_check.h"
 #include "absl/strings/substitute.h"
 #include "absl/synchronization/mutex.h"
 #include "mediapipe/framework/collection_item_id.h"
@@ -73,8 +74,8 @@ class MuxInputStreamHandler : public InputStreamHandler {
     Packet control_packet = control_stream->QueueHead();
     CHECK(!control_packet.IsEmpty());
     int control_value = control_packet.Get<int>();
-    CHECK_LE(0, control_value);
-    CHECK_LT(control_value, input_stream_managers_.NumEntries() - 1);
+    ABSL_CHECK_LE(0, control_value);
+    ABSL_CHECK_LT(control_value, input_stream_managers_.NumEntries() - 1);
     const auto& data_stream = input_stream_managers_.Get(
         input_stream_managers_.BeginId() + control_value);
 
@@ -100,7 +101,7 @@ class MuxInputStreamHandler : public InputStreamHandler {
       // indicated as timestamp boun update.
       return NodeReadiness::kReadyForProcess;
     }
-    CHECK_EQ(stream_timestamp, *min_stream_timestamp);
+    ABSL_CHECK_EQ(stream_timestamp, *min_stream_timestamp);
     return NodeReadiness::kReadyForProcess;
   }
 
@@ -118,7 +119,7 @@ class MuxInputStreamHandler : public InputStreamHandler {
     bool stream_is_done = false;
     Packet control_packet = control_stream->PopPacketAtTimestamp(
         input_timestamp, &num_packets_dropped, &stream_is_done);
-    CHECK_EQ(num_packets_dropped, 0)
+    ABSL_CHECK_EQ(num_packets_dropped, 0)
         << absl::Substitute("Dropped $0 packet(s) on input stream \"$1\".",
                             num_packets_dropped, control_stream->Name());
     CHECK(!control_packet.IsEmpty());
@@ -128,13 +129,13 @@ class MuxInputStreamHandler : public InputStreamHandler {
 
     const CollectionItemId data_stream_id =
         input_stream_managers_.BeginId() + control_value;
-    CHECK_LE(input_stream_managers_.BeginId(), data_stream_id);
-    CHECK_LT(data_stream_id, control_stream_id);
+    ABSL_CHECK_LE(input_stream_managers_.BeginId(), data_stream_id);
+    ABSL_CHECK_LT(data_stream_id, control_stream_id);
     auto& data_stream = input_stream_managers_.Get(data_stream_id);
     stream_is_done = false;
     Packet data_packet = data_stream->PopPacketAtTimestamp(
         input_timestamp, &num_packets_dropped, &stream_is_done);
-    CHECK_EQ(num_packets_dropped, 0)
+    ABSL_CHECK_EQ(num_packets_dropped, 0)
         << absl::Substitute("Dropped $0 packet(s) on input stream \"$1\".",
                             num_packets_dropped, data_stream->Name());
     AddPacketToShard(&input_set->Get(data_stream_id), std::move(data_packet),
diff --git a/third_party/mediapipe/src/mediapipe/framework/stream_handler/sync_set_input_stream_handler.cc b/third_party/mediapipe/src/mediapipe/framework/stream_handler/sync_set_input_stream_handler.cc
index 1001d64f73e36..adb4c05b3b74e 100644
--- a/third_party/mediapipe/src/mediapipe/framework/stream_handler/sync_set_input_stream_handler.cc
+++ b/third_party/mediapipe/src/mediapipe/framework/stream_handler/sync_set_input_stream_handler.cc
@@ -15,6 +15,7 @@
 #include <algorithm>
 
 // TODO: Move protos in another CL after the C++ code migration.
+#include "absl/log/absl_check.h"
 #include "absl/strings/substitute.h"
 #include "absl/synchronization/mutex.h"
 #include "mediapipe/framework/collection_item_id.h"
@@ -102,7 +103,7 @@ void SyncSetInputStreamHandler::PrepareForRun(
     std::set<CollectionItemId> used_ids;
     for (const auto& sync_set : handler_options.sync_set()) {
       std::vector<CollectionItemId> stream_ids;
-      CHECK_LT(0, sync_set.tag_index_size());
+      ABSL_CHECK_LT(0, sync_set.tag_index_size());
       for (const auto& tag_index : sync_set.tag_index()) {
         std::string tag;
         int index;
@@ -185,7 +186,7 @@ void SyncSetInputStreamHandler::FillInputSet(Timestamp input_timestamp,
                                              InputStreamShardSet* input_set) {
   // Assume that all current packets are already cleared.
   absl::MutexLock lock(&mutex_);
-  CHECK_LE(0, ready_sync_set_index_);
+  ABSL_CHECK_LE(0, ready_sync_set_index_);
   sync_sets_[ready_sync_set_index_].FillInputSet(input_timestamp, input_set);
   for (int i = 0; i < sync_sets_.size(); ++i) {
     if (i != ready_sync_set_index_) {
diff --git a/third_party/mediapipe/src/mediapipe/framework/stream_handler/timestamp_align_input_stream_handler.cc b/third_party/mediapipe/src/mediapipe/framework/stream_handler/timestamp_align_input_stream_handler.cc
index ae075d788552b..cb78618cbc3a2 100644
--- a/third_party/mediapipe/src/mediapipe/framework/stream_handler/timestamp_align_input_stream_handler.cc
+++ b/third_party/mediapipe/src/mediapipe/framework/stream_handler/timestamp_align_input_stream_handler.cc
@@ -17,6 +17,7 @@
 #include <utility>
 #include <vector>
 
+#include "absl/log/absl_check.h"
 #include "absl/strings/substitute.h"
 #include "absl/synchronization/mutex.h"
 #include "mediapipe/framework/collection_item_id.h"
@@ -178,7 +179,7 @@ NodeReadiness TimestampAlignInputStreamHandler::GetNodeReadiness(
     return NodeReadiness::kReadyForProcess;
   }
 
-  CHECK_EQ(min_bound, *min_stream_timestamp);
+  ABSL_CHECK_EQ(min_bound, *min_stream_timestamp);
   return NodeReadiness::kNotReady;
 }
 
@@ -198,7 +199,7 @@ void TimestampAlignInputStreamHandler::FillInputSet(
         if (id == timestamp_base_stream_id_) {
           current_packet = stream->PopPacketAtTimestamp(
               input_timestamp, &num_packets_dropped, &stream_is_done);
-          CHECK_EQ(num_packets_dropped, 0) << absl::Substitute(
+          ABSL_CHECK_EQ(num_packets_dropped, 0) << absl::Substitute(
               "Dropped $0 packet(s) on input stream \"$1\".",
               num_packets_dropped, stream->Name());
         }
@@ -218,10 +219,10 @@ void TimestampAlignInputStreamHandler::FillInputSet(
     Packet current_packet = stream->PopPacketAtTimestamp(
         stream_timestamp, &num_packets_dropped, &stream_is_done);
     if (!current_packet.IsEmpty()) {
-      CHECK_EQ(current_packet.Timestamp(), stream_timestamp);
+      ABSL_CHECK_EQ(current_packet.Timestamp(), stream_timestamp);
       current_packet = current_packet.At(input_timestamp);
     }
-    CHECK_EQ(num_packets_dropped, 0)
+    ABSL_CHECK_EQ(num_packets_dropped, 0)
         << absl::Substitute("Dropped $0 packet(s) on input stream \"$1\".",
                             num_packets_dropped, stream->Name());
     AddPacketToShard(&input_set->Get(id), std::move(current_packet),
diff --git a/third_party/mediapipe/src/mediapipe/framework/timestamp.h b/third_party/mediapipe/src/mediapipe/framework/timestamp.h
index d125d28bb58d8..8949dcc807dcd 100644
--- a/third_party/mediapipe/src/mediapipe/framework/timestamp.h
+++ b/third_party/mediapipe/src/mediapipe/framework/timestamp.h
@@ -47,6 +47,7 @@
 #include <cmath>
 #include <string>
 
+#include "absl/log/absl_check.h"
 #include "mediapipe/framework/deps/safe_int.h"
 #include "mediapipe/framework/port/integral_types.h"
 #include "mediapipe/framework/port/logging.h"
@@ -270,14 +271,14 @@ std::ostream& operator<<(std::ostream& os, TimestampDiff arg);
 inline Timestamp::Timestamp() : timestamp_(kint64min) {}
 
 inline Timestamp::Timestamp(int64 timestamp) : timestamp_(timestamp) {
-  CHECK(!IsSpecialValue())
+  ABSL_CHECK(!IsSpecialValue())
       << "Cannot directly create a Timestamp with a special value: "
       << CreateNoErrorChecking(timestamp);
 }
 
 inline Timestamp::Timestamp(TimestampBaseType timestamp)
     : timestamp_(timestamp) {
-  CHECK(!IsSpecialValue())
+  ABSL_CHECK(!IsSpecialValue())
       << "Cannot directly create a Timestamp with a special value: "
       << CreateNoErrorChecking(timestamp.value());
 }
diff --git a/third_party/mediapipe/src/mediapipe/framework/type_map.h b/third_party/mediapipe/src/mediapipe/framework/type_map.h
index 42f6fe6bf2fb9..f958a658f82f2 100644
--- a/third_party/mediapipe/src/mediapipe/framework/type_map.h
+++ b/third_party/mediapipe/src/mediapipe/framework/type_map.h
@@ -64,6 +64,7 @@
 #include <vector>
 
 #include "absl/base/macros.h"
+#include "absl/log/absl_check.h"
 #include "absl/synchronization/mutex.h"
 #include "mediapipe/framework/demangle.h"
 #include "mediapipe/framework/port/status.h"
@@ -127,7 +128,7 @@ class StaticMap {
   }
 
   static void GetKeys(std::vector<KeyType>* keys) {
-    CHECK(keys);
+    ABSL_CHECK(keys);
     keys->clear();
     const MapType& internal_map = GetMap()->internal_map_;
     for (typename MapType::const_iterator i = internal_map.begin();
@@ -158,12 +159,12 @@ class StaticMap {
 
       // Type has been already registered.
       const MediaPipeTypeData& existing_data = it->second.second;
-      CHECK_EQ(existing_data.type_id, value.type_id)
+      ABSL_CHECK_EQ(existing_data.type_id, value.type_id)
           << "Found inconsistent type ids (" << existing_data.type_id << " vs "
           << value.type_id
           << ") during mediapipe type registration. Previous definition at "
           << it->second.first << " and current definition at " << file_and_line;
-      CHECK_EQ(existing_data.type_string, value.type_string)
+      ABSL_CHECK_EQ(existing_data.type_string, value.type_string)
           << "Found inconsistent type strings (" << existing_data.type_string
           << " vs " << value.type_string
           << ") during mediapipe type registration. Previous registration at "
@@ -171,7 +172,7 @@ class StaticMap {
           << file_and_line;
       if (value.serialize_fn && value.deserialize_fn) {
         // Doesn't allow to redefine the existing type serialization functions.
-        CHECK(!existing_data.serialize_fn && !existing_data.deserialize_fn)
+        ABSL_CHECK(!existing_data.serialize_fn && !existing_data.deserialize_fn)
             << "Attempting to redefine serialization functions of type "
             << value.type_string << ", that have been defined at "
             << it->second.first << ", at " << file_and_line;
diff --git a/third_party/mediapipe/src/mediapipe/gpu/MPPMetalHelper.mm b/third_party/mediapipe/src/mediapipe/gpu/MPPMetalHelper.mm
index c0703e6ee6533..db8bb0a5399e0 100644
--- a/third_party/mediapipe/src/mediapipe/gpu/MPPMetalHelper.mm
+++ b/third_party/mediapipe/src/mediapipe/gpu/MPPMetalHelper.mm
@@ -20,6 +20,7 @@
 #import "mediapipe/gpu/metal_shared_resources.h"
 #import "GTMDefines.h"
 
+#include "absl/log/absl_check.h"
 #include "mediapipe/framework/port/ret_check.h"
 
 @interface MPPMetalHelper () {
@@ -78,7 +79,7 @@ class MetalHelperLegacySupport {
 - (instancetype)initWithSidePackets:(const mediapipe::PacketSet&)inputSidePackets {
   auto cc = mediapipe::MetalHelperLegacySupport::GetCalculatorContext();
   if (cc) {
-    CHECK_EQ(&inputSidePackets, &cc->InputSidePackets());
+    ABSL_CHECK_EQ(&inputSidePackets, &cc->InputSidePackets());
     return [self initWithCalculatorContext:cc];
   }
 
@@ -96,7 +97,7 @@ class MetalHelperLegacySupport {
 + (absl::Status)setupInputSidePackets:(mediapipe::PacketTypeSet*)inputSidePackets {
   auto cc = mediapipe::MetalHelperLegacySupport::GetCalculatorContract();
   if (cc) {
-    CHECK_EQ(inputSidePackets, &cc->InputSidePackets());
+    ABSL_CHECK_EQ(inputSidePackets, &cc->InputSidePackets());
     return [self updateContract:cc];
   }
 
@@ -180,7 +181,7 @@ class MetalHelperLegacySupport {
       NULL, _gpuResources->metal_shared().resources().mtlTextureCache,
       mediapipe::GetCVPixelBufferRef(gpuBuffer), NULL, metalPixelFormat, width, height, plane,
       &texture);
-  CHECK_EQ(err, kCVReturnSuccess);
+  ABSL_CHECK_EQ(err, kCVReturnSuccess);
   return texture;
 }
 
diff --git a/third_party/mediapipe/src/mediapipe/gpu/cv_pixel_buffer_pool_wrapper.cc b/third_party/mediapipe/src/mediapipe/gpu/cv_pixel_buffer_pool_wrapper.cc
index 6e077ae6ebb9e..b0689cd6a9a67 100644
--- a/third_party/mediapipe/src/mediapipe/gpu/cv_pixel_buffer_pool_wrapper.cc
+++ b/third_party/mediapipe/src/mediapipe/gpu/cv_pixel_buffer_pool_wrapper.cc
@@ -17,6 +17,7 @@
 #include <tuple>
 
 #include "CoreFoundation/CFBase.h"
+#include "absl/log/absl_check.h"
 #include "mediapipe/framework/port/logging.h"
 #include "mediapipe/objc/CFHolder.h"
 #include "mediapipe/objc/util.h"
@@ -27,7 +28,7 @@ CvPixelBufferPoolWrapper::CvPixelBufferPoolWrapper(
     int width, int height, GpuBufferFormat format, CFTimeInterval maxAge,
     CvTextureCacheManager* texture_caches) {
   OSType cv_format = CVPixelFormatForGpuBufferFormat(format);
-  CHECK_NE(cv_format, -1) << "unsupported pixel format";
+  ABSL_CHECK_NE(cv_format, -1) << "unsupported pixel format";
   pool_ = MakeCFHolderAdopting(
       /* keep count is 0 because the age param keeps buffers around anyway */
       CreateCVPixelBufferPool(width, height, cv_format, 0, maxAge));
@@ -73,7 +74,7 @@ void CvPixelBufferPoolWrapper::Flush() { CVPixelBufferPoolFlush(*pool_, 0); }
 CFHolder<CVPixelBufferRef> CvPixelBufferPoolWrapper::CreateBufferWithoutPool(
     const internal::GpuBufferSpec& spec) {
   OSType cv_format = CVPixelFormatForGpuBufferFormat(spec.format);
-  CHECK_NE(cv_format, -1) << "unsupported pixel format";
+  ABSL_CHECK_NE(cv_format, -1) << "unsupported pixel format";
   CVPixelBufferRef buffer;
   CVReturn err = CreateCVPixelBufferWithoutPool(spec.width, spec.height,
                                                 cv_format, &buffer);
diff --git a/third_party/mediapipe/src/mediapipe/gpu/cv_texture_cache_manager.cc b/third_party/mediapipe/src/mediapipe/gpu/cv_texture_cache_manager.cc
index b977a8993c4a8..5e06ab6dfc19b 100644
--- a/third_party/mediapipe/src/mediapipe/gpu/cv_texture_cache_manager.cc
+++ b/third_party/mediapipe/src/mediapipe/gpu/cv_texture_cache_manager.cc
@@ -14,6 +14,7 @@
 
 #include "mediapipe/gpu/cv_texture_cache_manager.h"
 
+#include "absl/log/absl_check.h"
 #include "mediapipe/framework/port/logging.h"
 
 namespace mediapipe {
@@ -48,7 +49,7 @@ void CvTextureCacheManager::UnregisterTextureCache(CVTextureCacheType cache) {
 }
 
 CvTextureCacheManager::~CvTextureCacheManager() {
-  CHECK_EQ(texture_caches_.size(), 0)
+  ABSL_CHECK_EQ(texture_caches_.size(), 0)
       << "Failed to unregister texture caches before deleting manager";
 }
 
diff --git a/third_party/mediapipe/src/mediapipe/gpu/gl_calculator_helper.cc b/third_party/mediapipe/src/mediapipe/gpu/gl_calculator_helper.cc
index 974525a91387f..0a422f308ec54 100644
--- a/third_party/mediapipe/src/mediapipe/gpu/gl_calculator_helper.cc
+++ b/third_party/mediapipe/src/mediapipe/gpu/gl_calculator_helper.cc
@@ -14,6 +14,7 @@
 
 #include "mediapipe/gpu/gl_calculator_helper.h"
 
+#include "absl/log/absl_check.h"
 #include "mediapipe/framework/formats/image.h"
 #include "mediapipe/framework/formats/image_frame.h"
 #include "mediapipe/framework/legacy_calculator_support.h"
@@ -71,7 +72,7 @@ absl::Status GlCalculatorHelper::SetupInputSidePackets(
     PacketTypeSet* input_side_packets) {
   auto cc = LegacyCalculatorSupport::Scoped<CalculatorContract>::current();
   if (cc) {
-    CHECK_EQ(input_side_packets, &cc->InputSidePackets());
+    ABSL_CHECK_EQ(input_side_packets, &cc->InputSidePackets());
     return UpdateContract(cc);
   }
 
diff --git a/third_party/mediapipe/src/mediapipe/gpu/gl_context.cc b/third_party/mediapipe/src/mediapipe/gpu/gl_context.cc
index d7381babddd16..c596430bc1948 100644
--- a/third_party/mediapipe/src/mediapipe/gpu/gl_context.cc
+++ b/third_party/mediapipe/src/mediapipe/gpu/gl_context.cc
@@ -34,6 +34,7 @@
 
 #ifndef __EMSCRIPTEN__
 #include "absl/debugging/leak_check.h"
+#include "absl/log/absl_check.h"
 #include "mediapipe/gpu/gl_thread_collector.h"
 #endif
 
@@ -69,17 +70,17 @@ static void SetThreadName(const char* name) {
 }
 
 GlContext::DedicatedThread::DedicatedThread() {
-  CHECK_EQ(pthread_create(&gl_thread_id_, nullptr, ThreadBody, this), 0);
+  ABSL_CHECK_EQ(pthread_create(&gl_thread_id_, nullptr, ThreadBody, this), 0);
 }
 
 GlContext::DedicatedThread::~DedicatedThread() {
   if (IsCurrentThread()) {
     CHECK(self_destruct_);
-    CHECK_EQ(pthread_detach(gl_thread_id_), 0);
+    ABSL_CHECK_EQ(pthread_detach(gl_thread_id_), 0);
   } else {
     // Give an invalid job to signal termination.
     PutJob({});
-    CHECK_EQ(pthread_join(gl_thread_id_, nullptr), 0);
+    ABSL_CHECK_EQ(pthread_join(gl_thread_id_, nullptr), 0);
   }
 }
 
diff --git a/third_party/mediapipe/src/mediapipe/gpu/gl_texture_buffer.cc b/third_party/mediapipe/src/mediapipe/gpu/gl_texture_buffer.cc
index 4e5ce4ee4002c..8c7df3a0bc1d9 100644
--- a/third_party/mediapipe/src/mediapipe/gpu/gl_texture_buffer.cc
+++ b/third_party/mediapipe/src/mediapipe/gpu/gl_texture_buffer.cc
@@ -20,6 +20,7 @@
 #include "mediapipe/gpu/gpu_buffer_storage_image_frame.h"
 
 #if MEDIAPIPE_GPU_BUFFER_USE_CV_PIXEL_BUFFER
+#include "absl/log/absl_check.h"
 #include "mediapipe/gpu/gl_texture_util.h"
 #include "mediapipe/gpu/gpu_buffer_storage_cv_pixel_buffer.h"
 #endif  // MEDIAPIPE_GPU_BUFFER_USE_CV_PIXEL_BUFFER
@@ -152,7 +153,7 @@ bool GlTextureBuffer::CreateInternal(const void* data, int alignment) {
   CHECK(!deletion_callback_);
   deletion_callback_ = [this,
                         context](std::shared_ptr<GlSyncPoint> sync_token) {
-    CHECK_NE(name_, 0);
+    ABSL_CHECK_NE(name_, 0);
     GLuint name_to_delete = name_;
     context->RunWithoutWaiting([name_to_delete]() {
       // Note that we do not wait for consumers to be done before deleting the
@@ -264,7 +265,7 @@ GlTextureView GlTextureBuffer::GetReadView(internal::types<GlTextureView>,
                                            int plane) const {
   auto gl_context = GlContext::GetCurrent();
   CHECK(gl_context);
-  CHECK_EQ(plane, 0);
+  ABSL_CHECK_EQ(plane, 0);
   // Note that this method is only supposed to be called by GpuBuffer, which
   // ensures this condition is satisfied.
   DCHECK(!weak_from_this().expired())
@@ -285,7 +286,7 @@ GlTextureView GlTextureBuffer::GetWriteView(internal::types<GlTextureView>,
                                             int plane) {
   auto gl_context = GlContext::GetCurrent();
   CHECK(gl_context);
-  CHECK_EQ(plane, 0);
+  ABSL_CHECK_EQ(plane, 0);
   // Note that this method is only supposed to be called by GpuBuffer, which
   // ensures this condition is satisfied.
   DCHECK(!weak_from_this().expired())
diff --git a/third_party/mediapipe/src/mediapipe/gpu/gpu_buffer_format.cc b/third_party/mediapipe/src/mediapipe/gpu/gpu_buffer_format.cc
index e88aa602ed9a6..e9f8d0b9fcdd2 100644
--- a/third_party/mediapipe/src/mediapipe/gpu/gpu_buffer_format.cc
+++ b/third_party/mediapipe/src/mediapipe/gpu/gpu_buffer_format.cc
@@ -15,6 +15,7 @@
 #include "mediapipe/gpu/gpu_buffer_format.h"
 
 #include "absl/container/flat_hash_map.h"
+#include "absl/log/absl_check.h"
 #include "mediapipe/framework/deps/no_destructor.h"
 #include "mediapipe/framework/port/logging.h"
 
@@ -194,11 +195,11 @@ const GlTextureInfo& GlTextureInfoForGpuBufferFormat(GpuBufferFormat format,
       << static_cast<std::underlying_type_t<decltype(format)>>(format);
   const auto& planes = iter->second;
 #ifndef __APPLE__
-  CHECK_EQ(planes.size(), 1)
+  ABSL_CHECK_EQ(planes.size(), 1)
       << "multiplanar formats are not supported on this platform";
 #endif
-  CHECK_GE(plane, 0) << "invalid plane number";
-  CHECK_LT(plane, planes.size()) << "invalid plane number";
+  ABSL_CHECK_GE(plane, 0) << "invalid plane number";
+  ABSL_CHECK_LT(plane, planes.size()) << "invalid plane number";
   return planes[plane];
 }
 #endif  // MEDIAPIPE_DISABLE_GPU
diff --git a/third_party/mediapipe/src/mediapipe/gpu/gpu_buffer_storage_cv_pixel_buffer.cc b/third_party/mediapipe/src/mediapipe/gpu/gpu_buffer_storage_cv_pixel_buffer.cc
index 7cac32b7f1903..642ce23b56846 100644
--- a/third_party/mediapipe/src/mediapipe/gpu/gpu_buffer_storage_cv_pixel_buffer.cc
+++ b/third_party/mediapipe/src/mediapipe/gpu/gpu_buffer_storage_cv_pixel_buffer.cc
@@ -2,6 +2,7 @@
 
 #include <memory>
 
+#include "absl/log/absl_check.h"
 #include "mediapipe/gpu/gl_context.h"
 #include "mediapipe/gpu/gpu_buffer_storage_image_frame.h"
 #include "mediapipe/objc/util.h"
@@ -17,7 +18,7 @@ typedef CVOpenGLESTextureRef CVTextureType;
 GpuBufferStorageCvPixelBuffer::GpuBufferStorageCvPixelBuffer(
     int width, int height, GpuBufferFormat format) {
   OSType cv_format = CVPixelFormatForGpuBufferFormat(format);
-  CHECK_NE(cv_format, -1) << "unsupported pixel format";
+  ABSL_CHECK_NE(cv_format, -1) << "unsupported pixel format";
   CVPixelBufferRef buffer;
   CVReturn err =
       CreateCVPixelBufferWithoutPool(width, height, cv_format, &buffer);
diff --git a/third_party/mediapipe/src/mediapipe/modules/objectron/calculators/box.cc b/third_party/mediapipe/src/mediapipe/modules/objectron/calculators/box.cc
index bd2ce57f95273..9b3e434840cb9 100644
--- a/third_party/mediapipe/src/mediapipe/modules/objectron/calculators/box.cc
+++ b/third_party/mediapipe/src/mediapipe/modules/objectron/calculators/box.cc
@@ -15,6 +15,7 @@
 #include "mediapipe/modules/objectron/calculators/box.h"
 
 #include "Eigen/Core"
+#include "absl/log/absl_check.h"
 #include "mediapipe/framework/port/logging.h"
 
 namespace mediapipe {
@@ -107,12 +108,12 @@ void Box::Adjust(const std::vector<float>& variables) {
 }
 
 float* Box::GetVertex(size_t vertex_id) {
-  CHECK_LT(vertex_id, kNumKeypoints);
+  ABSL_CHECK_LT(vertex_id, kNumKeypoints);
   return bounding_box_[vertex_id].data();
 }
 
 const float* Box::GetVertex(size_t vertex_id) const {
-  CHECK_LT(vertex_id, kNumKeypoints);
+  ABSL_CHECK_LT(vertex_id, kNumKeypoints);
   return bounding_box_[vertex_id].data();
 }
 
@@ -135,7 +136,7 @@ bool Box::InsideTest(const Eigen::Vector3f& point, int check_axis) const {
 }
 
 void Box::Deserialize(const Object& obj) {
-  CHECK_EQ(obj.keypoints_size(), kNumKeypoints);
+  ABSL_CHECK_EQ(obj.keypoints_size(), kNumKeypoints);
   Model::Deserialize(obj);
 }
 
@@ -222,7 +223,7 @@ std::pair<Vector3f, Vector3f> Box::GetGroundPlane() const {
 
 template <typename T>
 void Box::Fit(const std::vector<T>& vertices) {
-  CHECK_EQ(vertices.size(), kNumKeypoints);
+  ABSL_CHECK_EQ(vertices.size(), kNumKeypoints);
   scale_.setZero();
   // The scale would remain invariant under rotation and translation.
   // We can safely estimate the scale from the oriented box.
diff --git a/third_party/mediapipe/src/mediapipe/modules/objectron/calculators/decoder.cc b/third_party/mediapipe/src/mediapipe/modules/objectron/calculators/decoder.cc
index 0af34585b2470..ba6e98a5d22b1 100644
--- a/third_party/mediapipe/src/mediapipe/modules/objectron/calculators/decoder.cc
+++ b/third_party/mediapipe/src/mediapipe/modules/objectron/calculators/decoder.cc
@@ -19,6 +19,7 @@
 
 #include "Eigen/Core"
 #include "Eigen/Dense"
+#include "absl/log/absl_check.h"
 #include "absl/status/status.h"
 #include "mediapipe/framework/port/canonical_errors.h"
 #include "mediapipe/framework/port/logging.h"
@@ -46,10 +47,10 @@ inline void SetPoint3d(const Eigen::Vector3f& point_vec, Point3D* point_3d) {
 
 FrameAnnotation Decoder::DecodeBoundingBoxKeypoints(
     const cv::Mat& heatmap, const cv::Mat& offsetmap) const {
-  CHECK_EQ(1, heatmap.channels());
-  CHECK_EQ(kNumOffsetmaps, offsetmap.channels());
-  CHECK_EQ(heatmap.cols, offsetmap.cols);
-  CHECK_EQ(heatmap.rows, offsetmap.rows);
+  ABSL_CHECK_EQ(1, heatmap.channels());
+  ABSL_CHECK_EQ(kNumOffsetmaps, offsetmap.channels());
+  ABSL_CHECK_EQ(heatmap.cols, offsetmap.cols);
+  ABSL_CHECK_EQ(heatmap.rows, offsetmap.rows);
 
   const float offset_scale = std::min(offsetmap.cols, offsetmap.rows);
   const std::vector<cv::Point> center_points = ExtractCenterKeypoints(heatmap);
@@ -204,7 +205,7 @@ absl::Status Decoder::Lift2DTo3D(
   CHECK(estimated_box != nullptr);
 
   for (auto& annotation : *estimated_box->mutable_annotations()) {
-    CHECK_EQ(kNumKeypoints, annotation.keypoints_size());
+    ABSL_CHECK_EQ(kNumKeypoints, annotation.keypoints_size());
 
     // Fill input 2D Points;
     std::vector<Vector2f> input_points_2d;
diff --git a/third_party/mediapipe/src/mediapipe/modules/objectron/calculators/epnp.cc b/third_party/mediapipe/src/mediapipe/modules/objectron/calculators/epnp.cc
index 8bd7151fad955..03b78c728484b 100644
--- a/third_party/mediapipe/src/mediapipe/modules/objectron/calculators/epnp.cc
+++ b/third_party/mediapipe/src/mediapipe/modules/objectron/calculators/epnp.cc
@@ -14,6 +14,8 @@
 
 #include "mediapipe/modules/objectron/calculators/epnp.h"
 
+#include "absl/log/absl_check.h"
+
 namespace mediapipe {
 
 namespace {
@@ -126,7 +128,7 @@ absl::Status SolveEpnp(const float focal_x, const float focal_y,
   if (eigen_solver.info() != Eigen::Success) {
     return absl::AbortedError("Eigen decomposition failed.");
   }
-  CHECK_EQ(12, eigen_solver.eigenvalues().size());
+  ABSL_CHECK_EQ(12, eigen_solver.eigenvalues().size());
 
   // Eigenvalues are sorted in increasing order for SelfAdjointEigenSolver
   // only! If you use other Eigen Solvers, it's not guaranteed to be in
diff --git a/third_party/mediapipe/src/mediapipe/modules/objectron/calculators/model.cc b/third_party/mediapipe/src/mediapipe/modules/objectron/calculators/model.cc
index 40aca39d9edc1..d6fe9ed6c5f9a 100644
--- a/third_party/mediapipe/src/mediapipe/modules/objectron/calculators/model.cc
+++ b/third_party/mediapipe/src/mediapipe/modules/objectron/calculators/model.cc
@@ -14,6 +14,7 @@
 
 #include "mediapipe/modules/objectron/calculators/model.h"
 
+#include "absl/log/absl_check.h"
 #include "mediapipe/framework/port/logging.h"
 
 namespace mediapipe {
@@ -66,9 +67,9 @@ const Eigen::Ref<const Eigen::Matrix3f> Model::GetRotation() const {
 const std::string& Model::GetCategory() const { return category_; }
 
 void Model::Deserialize(const Object& obj) {
-  CHECK_EQ(obj.rotation_size(), 9);
-  CHECK_EQ(obj.translation_size(), 3);
-  CHECK_EQ(obj.scale_size(), 3);
+  ABSL_CHECK_EQ(obj.rotation_size(), 9);
+  ABSL_CHECK_EQ(obj.translation_size(), 3);
+  ABSL_CHECK_EQ(obj.scale_size(), 3);
   category_ = obj.category();
 
   using RotationMatrix = Eigen::Matrix<float, 3, 3, Eigen::RowMajor>;
diff --git a/third_party/mediapipe/src/mediapipe/modules/objectron/calculators/tensor_util.cc b/third_party/mediapipe/src/mediapipe/modules/objectron/calculators/tensor_util.cc
index 0004edd800fc5..e48256575304c 100644
--- a/third_party/mediapipe/src/mediapipe/modules/objectron/calculators/tensor_util.cc
+++ b/third_party/mediapipe/src/mediapipe/modules/objectron/calculators/tensor_util.cc
@@ -14,6 +14,7 @@
 
 #include "mediapipe/modules/objectron/calculators/tensor_util.h"
 
+#include "absl/log/absl_check.h"
 #include "mediapipe/framework/port/logging.h"
 
 namespace mediapipe {
@@ -21,7 +22,8 @@ namespace mediapipe {
 cv::Mat ConvertTfliteTensorToCvMat(const TfLiteTensor& tensor) {
   // Check tensor is BxCxWxH (size = 4) and the batch size is one(data[0] = 1)
   CHECK(tensor.dims->size == 4 && tensor.dims->data[0] == 1);
-  CHECK_EQ(kTfLiteFloat32, tensor.type) << "tflite_tensor type is not float";
+  ABSL_CHECK_EQ(kTfLiteFloat32, tensor.type)
+      << "tflite_tensor type is not float";
 
   const size_t num_output_channels = tensor.dims->data[3];
   const int dims = 2;
@@ -33,8 +35,8 @@ cv::Mat ConvertTfliteTensorToCvMat(const TfLiteTensor& tensor) {
 cv::Mat ConvertTensorToCvMat(const mediapipe::Tensor& tensor) {
   // Check tensor is BxCxWxH (size = 4) and the batch size is one(data[0] = 1)
   CHECK(tensor.shape().dims.size() == 4 && tensor.shape().dims[0] == 1);
-  CHECK_EQ(mediapipe::Tensor::ElementType::kFloat32 == tensor.element_type(),
-           true)
+  ABSL_CHECK_EQ(
+      mediapipe::Tensor::ElementType::kFloat32 == tensor.element_type(), true)
       << "tensor type is not float";
 
   const size_t num_output_channels = tensor.shape().dims[3];
diff --git a/third_party/mediapipe/src/mediapipe/modules/objectron/calculators/tensors_to_objects_calculator.cc b/third_party/mediapipe/src/mediapipe/modules/objectron/calculators/tensors_to_objects_calculator.cc
index 6989c34ce88ae..d0fc612318d61 100644
--- a/third_party/mediapipe/src/mediapipe/modules/objectron/calculators/tensors_to_objects_calculator.cc
+++ b/third_party/mediapipe/src/mediapipe/modules/objectron/calculators/tensors_to_objects_calculator.cc
@@ -17,6 +17,7 @@
 #include <vector>
 
 #include "Eigen/Dense"
+#include "absl/log/absl_check.h"
 #include "absl/memory/memory.h"
 #include "absl/strings/str_format.h"
 #include "absl/types/span.h"
@@ -170,7 +171,7 @@ absl::Status TensorsToObjectsCalculator::LoadOptions(CalculatorContext* cc) {
   num_keypoints_ = options_.num_keypoints();
 
   // Currently only support 2D when num_values_per_keypoint equals to 2.
-  CHECK_EQ(options_.num_values_per_keypoint(), 2);
+  ABSL_CHECK_EQ(options_.num_values_per_keypoint(), 2);
 
   return absl::OkStatus();
 }
diff --git a/third_party/mediapipe/src/mediapipe/modules/objectron/calculators/tflite_tensors_to_objects_calculator.cc b/third_party/mediapipe/src/mediapipe/modules/objectron/calculators/tflite_tensors_to_objects_calculator.cc
index d74b59a254658..98aeb7362fa06 100644
--- a/third_party/mediapipe/src/mediapipe/modules/objectron/calculators/tflite_tensors_to_objects_calculator.cc
+++ b/third_party/mediapipe/src/mediapipe/modules/objectron/calculators/tflite_tensors_to_objects_calculator.cc
@@ -17,6 +17,7 @@
 #include <vector>
 
 #include "Eigen/Dense"
+#include "absl/log/absl_check.h"
 #include "absl/memory/memory.h"
 #include "absl/strings/str_format.h"
 #include "absl/types/span.h"
@@ -178,7 +179,7 @@ absl::Status TfLiteTensorsToObjectsCalculator::LoadOptions(
   num_keypoints_ = options_.num_keypoints();
 
   // Currently only support 2D when num_values_per_keypoint equals to 2.
-  CHECK_EQ(options_.num_values_per_keypoint(), 2);
+  ABSL_CHECK_EQ(options_.num_values_per_keypoint(), 2);
 
   return absl::OkStatus();
 }
diff --git a/third_party/mediapipe/src/mediapipe/tasks/cc/text/custom_ops/ragged/ragged_tensor_to_tensor_tflite.cc b/third_party/mediapipe/src/mediapipe/tasks/cc/text/custom_ops/ragged/ragged_tensor_to_tensor_tflite.cc
index a0eadd7154634..3f0ed01a1df38 100644
--- a/third_party/mediapipe/src/mediapipe/tasks/cc/text/custom_ops/ragged/ragged_tensor_to_tensor_tflite.cc
+++ b/third_party/mediapipe/src/mediapipe/tasks/cc/text/custom_ops/ragged/ragged_tensor_to_tensor_tflite.cc
@@ -18,6 +18,7 @@ limitations under the License.
 #include <cstdint>
 #include <memory>
 
+#include "absl/log/absl_check.h"
 #include "flatbuffers/flexbuffers.h"
 #include "tensorflow/core/util/ragged_to_dense_util_common.h"
 #include "tensorflow/lite/c/common.h"
@@ -357,7 +358,7 @@ void CalculateOutputIndexValueRowID(const TfLiteTensor& value_rowids,
   };
   int current_output_column = 0;
   int current_value_rowid = value_rowids_val(0);
-  // DCHECK_LT(current_value_rowid, parent_output_index.size());
+  // ABSL_DCHECK_LT(current_value_rowid, parent_output_index.size());
   int current_output_index = parent_output_index[current_value_rowid];
   result->push_back(current_output_index);
   for (int i = 1; i < index_size; ++i) {
@@ -374,12 +375,12 @@ void CalculateOutputIndexValueRowID(const TfLiteTensor& value_rowids,
     } else {
       current_output_column = 0;
       current_value_rowid = next_value_rowid;
-      // DCHECK_LT(next_value_rowid, parent_output_index.size());
+      // ABSL_DCHECK_LT(next_value_rowid, parent_output_index.size());
       current_output_index = parent_output_index[next_value_rowid];
     }
     result->push_back(current_output_index);
   }
-  // DCHECK_EQ(result->size(), value_rowids.size());
+  // ABSL_DCHECK_EQ(result->size(), value_rowids.size());
 }
 
 void CalculateOutputIndexRowSplit(const TfLiteTensor& row_split,
@@ -420,7 +421,7 @@ void CalculateOutputIndexRowSplit(const TfLiteTensor& row_split,
     }
   }
   // if (row_split_size > 0) {
-  //  DCHECK_EQ(result->size(), row_split(row_split_size - 1));
+  //  ABSL_DCHECK_EQ(result->size(), row_split(row_split_size - 1));
   //}
 }
 
diff --git a/third_party/mediapipe/src/mediapipe/util/annotation_renderer.cc b/third_party/mediapipe/src/mediapipe/util/annotation_renderer.cc
index d8516f9bc36c7..e1aa4846792b4 100644
--- a/third_party/mediapipe/src/mediapipe/util/annotation_renderer.cc
+++ b/third_party/mediapipe/src/mediapipe/util/annotation_renderer.cc
@@ -19,6 +19,7 @@
 #include <algorithm>
 #include <cmath>
 
+#include "absl/log/absl_check.h"
 #include "mediapipe/framework/port/logging.h"
 #include "mediapipe/framework/port/vector.h"
 #include "mediapipe/util/color.pb.h"
@@ -49,8 +50,8 @@ bool NormalizedtoPixelCoordinates(double normalized_x, double normalized_y,
                                   int* y_px) {
   CHECK(x_px != nullptr);
   CHECK(y_px != nullptr);
-  CHECK_GT(image_width, 0);
-  CHECK_GT(image_height, 0);
+  ABSL_CHECK_GT(image_width, 0);
+  ABSL_CHECK_GT(image_height, 0);
 
   if (normalized_x < 0 || normalized_x > 1.0 || normalized_y < 0 ||
       normalized_y > 1.0) {
diff --git a/third_party/mediapipe/src/mediapipe/util/image_frame_util.cc b/third_party/mediapipe/src/mediapipe/util/image_frame_util.cc
index bf2773fdc7152..d2769427e626b 100644
--- a/third_party/mediapipe/src/mediapipe/util/image_frame_util.cc
+++ b/third_party/mediapipe/src/mediapipe/util/image_frame_util.cc
@@ -20,6 +20,7 @@
 #include <string>
 #include <vector>
 
+#include "absl/log/absl_check.h"
 #include "absl/strings/str_cat.h"
 #include "absl/strings/str_join.h"
 #include "absl/strings/string_view.h"
@@ -47,7 +48,7 @@ void RescaleImageFrame(const ImageFrame& source_frame, const int width,
                        const int open_cv_interpolation_algorithm,
                        ImageFrame* destination_frame) {
   CHECK(destination_frame);
-  CHECK_EQ(ImageFormat::SRGB, source_frame.Format());
+  ABSL_CHECK_EQ(ImageFormat::SRGB, source_frame.Format());
 
   cv::Mat source_mat = ::mediapipe::formats::MatView(&source_frame);
   destination_frame->Reset(source_frame.Format(), width, height,
@@ -106,7 +107,7 @@ void ImageFrameToYUVImage(const ImageFrame& image_frame, YUVImage* yuv_image) {
                         u, uv_stride,                                      //
                         v, uv_stride,                                      //
                         width, height);
-  CHECK_EQ(0, rv);
+  ABSL_CHECK_EQ(0, rv);
 }
 
 void ImageFrameToYUVNV12Image(const ImageFrame& image_frame,
@@ -136,7 +137,7 @@ void ImageFrameToYUVNV12Image(const ImageFrame& image_frame,
       yuv_i420_image.stride(2), yuv_nv12_image->mutable_data(0),
       yuv_nv12_image->stride(0), yuv_nv12_image->mutable_data(1),
       yuv_nv12_image->stride(1), width, height);
-  CHECK_EQ(0, rv);
+  ABSL_CHECK_EQ(0, rv);
 }
 
 void YUVImageToImageFrame(const YUVImage& yuv_image, ImageFrame* image_frame,
@@ -161,7 +162,7 @@ void YUVImageToImageFrame(const YUVImage& yuv_image, ImageFrame* image_frame,
                            image_frame->MutablePixelData(),
                            image_frame->WidthStep(), width, height);
   }
-  CHECK_EQ(0, rv);
+  ABSL_CHECK_EQ(0, rv);
 }
 
 void YUVImageToImageFrameFromFormat(const YUVImage& yuv_image,
diff --git a/third_party/mediapipe/src/mediapipe/util/resource_cache.h b/third_party/mediapipe/src/mediapipe/util/resource_cache.h
index 2b3ccbc7d6749..da0e4adfb0bf9 100644
--- a/third_party/mediapipe/src/mediapipe/util/resource_cache.h
+++ b/third_party/mediapipe/src/mediapipe/util/resource_cache.h
@@ -19,6 +19,7 @@
 
 #include "absl/container/flat_hash_map.h"
 #include "absl/functional/function_ref.h"
+#include "absl/log/absl_check.h"
 #include "mediapipe/framework/port/logging.h"
 
 namespace mediapipe {
@@ -40,10 +41,12 @@ class ResourceCache {
       std::tie(map_it, std::ignore) =
           map_.try_emplace(key, std::make_unique<Entry>(key));
       entry = map_it->second.get();
-      CHECK_EQ(entry->request_count, 0);
+      ABSL_CHECK_EQ(entry->request_count, 0);
       entry->request_count = 1;
       entry_list_.Append(entry);
-      if (entry->prev != nullptr) CHECK_GE(entry->prev->request_count, 1);
+      if (entry->prev != nullptr) {
+        ABSL_CHECK_GE(entry->prev->request_count, 1);
+      }
     } else {
       entry = map_it->second.get();
       ++entry->request_count;
diff --git a/third_party/mediapipe/src/mediapipe/util/sequence/media_sequence.cc b/third_party/mediapipe/src/mediapipe/util/sequence/media_sequence.cc
index 21d030fffd72a..372a2c6115d88 100644
--- a/third_party/mediapipe/src/mediapipe/util/sequence/media_sequence.cc
+++ b/third_party/mediapipe/src/mediapipe/util/sequence/media_sequence.cc
@@ -17,6 +17,7 @@
 #include <cmath>
 #include <limits>
 
+#include "absl/log/absl_check.h"
 #include "absl/strings/str_split.h"
 #include "mediapipe/framework/port/opencv_imgcodecs_inc.h"
 #include "mediapipe/framework/port/ret_check.h"
@@ -534,7 +535,7 @@ std::unique_ptr<mediapipe::Matrix> GetAudioFromFeatureAt(
       << "GetAudioAt requires num_channels context to be specified as key: "
       << merge_prefix(prefix, kFeatureNumChannelsKey);
   int num_channels = GetFeatureNumChannels(prefix, sequence);
-  CHECK_EQ(flat_data.size() % num_channels, 0)
+  ABSL_CHECK_EQ(flat_data.size() % num_channels, 0)
       << "The data size is not a multiple of the number of channels: "
       << flat_data.size() << " % " << num_channels << " = "
       << flat_data.size() % num_channels << " for sequence index " << index;
diff --git a/third_party/mediapipe/src/mediapipe/util/sequence/media_sequence_util.h b/third_party/mediapipe/src/mediapipe/util/sequence/media_sequence_util.h
index 1737f91a0e701..2e738281b2cde 100644
--- a/third_party/mediapipe/src/mediapipe/util/sequence/media_sequence_util.h
+++ b/third_party/mediapipe/src/mediapipe/util/sequence/media_sequence_util.h
@@ -92,6 +92,7 @@
 #include <string>
 #include <vector>
 
+#include "absl/log/absl_check.h"
 #include "mediapipe/framework/port/integral_types.h"
 #include "mediapipe/framework/port/logging.h"
 #include "mediapipe/framework/port/proto_ns.h"
@@ -220,7 +221,7 @@ inline const proto_ns::RepeatedField<float>& GetFloatsAt(
     const tensorflow::SequenceExample& sequence, const std::string& key,
     const int index) {
   const tensorflow::FeatureList& fl = GetFeatureList(sequence, key);
-  CHECK_LT(index, fl.feature_size())
+  ABSL_CHECK_LT(index, fl.feature_size())
       << "Sequence: \n " << sequence.DebugString();
   return fl.feature().Get(index).float_list().value();
 }
@@ -231,7 +232,7 @@ inline const proto_ns::RepeatedField<int64>& GetInt64sAt(
     const tensorflow::SequenceExample& sequence, const std::string& key,
     const int index) {
   const tensorflow::FeatureList& fl = GetFeatureList(sequence, key);
-  CHECK_LT(index, fl.feature_size())
+  ABSL_CHECK_LT(index, fl.feature_size())
       << "Sequence: \n " << sequence.DebugString();
   return fl.feature().Get(index).int64_list().value();
 }
@@ -242,7 +243,7 @@ inline const proto_ns::RepeatedPtrField<std::string>& GetBytesAt(
     const tensorflow::SequenceExample& sequence, const std::string& key,
     const int index) {
   const tensorflow::FeatureList& fl = GetFeatureList(sequence, key);
-  CHECK_LT(index, fl.feature_size())
+  ABSL_CHECK_LT(index, fl.feature_size())
       << "Sequence: \n " << sequence.DebugString();
   return fl.feature().Get(index).bytes_list().value();
 }
diff --git a/third_party/mediapipe/src/mediapipe/util/time_series_util.cc b/third_party/mediapipe/src/mediapipe/util/time_series_util.cc
index 87f69475a2ccf..128cc11756fda 100644
--- a/third_party/mediapipe/src/mediapipe/util/time_series_util.cc
+++ b/third_party/mediapipe/src/mediapipe/util/time_series_util.cc
@@ -19,6 +19,7 @@
 #include <iostream>
 #include <string>
 
+#include "absl/log/absl_check.h"
 #include "absl/strings/str_cat.h"
 #include "mediapipe/framework/calculator_framework.h"
 #include "mediapipe/framework/formats/time_series_header.pb.h"
@@ -127,7 +128,7 @@ int64_t SecondsToSamples(double time_in_seconds, double sample_rate) {
 }
 
 double SamplesToSeconds(int64_t num_samples, double sample_rate) {
-  DCHECK_NE(sample_rate, 0.0);
+  ABSL_DCHECK_NE(sample_rate, 0.0);
   return (num_samples / sample_rate);
 }
 
diff --git a/third_party/mediapipe/src/mediapipe/util/tracking/box_detector.cc b/third_party/mediapipe/src/mediapipe/util/tracking/box_detector.cc
index 58d855537c8d1..44567d7941744 100644
--- a/third_party/mediapipe/src/mediapipe/util/tracking/box_detector.cc
+++ b/third_party/mediapipe/src/mediapipe/util/tracking/box_detector.cc
@@ -16,6 +16,7 @@
 
 #include <vector>
 
+#include "absl/log/absl_check.h"
 #include "absl/memory/memory.h"
 #include "mediapipe/framework/port/opencv_calib3d_inc.h"
 #include "mediapipe/framework/port/opencv_imgproc_inc.h"
@@ -46,7 +47,7 @@ cv::Mat ConvertDescriptorsToMat(const std::vector<std::string> &descriptors) {
   CHECK(!descriptors.empty()) << "empty descriptors.";
 
   const int descriptors_dims = descriptors[0].size();
-  CHECK_GT(descriptors_dims, 0);
+  ABSL_CHECK_GT(descriptors_dims, 0);
 
   cv::Mat mat(descriptors.size(), descriptors_dims, CV_8U);
 
@@ -59,13 +60,13 @@ cv::Mat ConvertDescriptorsToMat(const std::vector<std::string> &descriptors) {
 
 cv::Mat GetDescriptorsWithIndices(const cv::Mat &frame_descriptors,
                                   const std::vector<int> &indices) {
-  CHECK_GT(frame_descriptors.rows, 0);
+  ABSL_CHECK_GT(frame_descriptors.rows, 0);
 
   const int num_inlier_descriptors = indices.size();
-  CHECK_GT(num_inlier_descriptors, 0);
+  ABSL_CHECK_GT(num_inlier_descriptors, 0);
 
   const int descriptors_dims = frame_descriptors.cols;
-  CHECK_GT(descriptors_dims, 0);
+  ABSL_CHECK_GT(descriptors_dims, 0);
 
   cv::Mat mat(num_inlier_descriptors, descriptors_dims, CV_32F);
 
@@ -301,7 +302,7 @@ void BoxDetectorInterface::DetectAndAddBox(
   orb_extractor_->detect(resize_image, keypoints);
   orb_extractor_->compute(resize_image, keypoints, descriptors);
 
-  CHECK_EQ(keypoints.size(), descriptors.rows);
+  ABSL_CHECK_EQ(keypoints.size(), descriptors.rows);
 
   float inv_scale = 1.0f / std::max(resize_image.cols, resize_image.rows);
   std::vector<Vector2_f> v_keypoints(keypoints.size());
@@ -681,15 +682,15 @@ void BoxDetectorInterface::AddBoxDetectorIndex(const BoxDetectorIndex &index) {
         continue;
       }
 
-      CHECK_EQ(frame_entry.keypoints_size(),
-               frame_entry.descriptors_size() * 2);
+      ABSL_CHECK_EQ(frame_entry.keypoints_size(),
+                    frame_entry.descriptors_size() * 2);
 
       const int num_features = frame_entry.descriptors_size();
-      CHECK_GT(num_features, 0);
+      ABSL_CHECK_GT(num_features, 0);
       std::vector<Vector2_f> features(num_features);
 
       const int descriptors_dims = frame_entry.descriptors(0).data().size();
-      CHECK_GT(descriptors_dims, 0);
+      ABSL_CHECK_GT(descriptors_dims, 0);
 
       cv::Mat descriptors_mat(num_features, descriptors_dims / sizeof(float),
                               CV_32F);
@@ -713,7 +714,7 @@ std::vector<FeatureCorrespondence>
 BoxDetectorOpencvBfImpl::MatchFeatureDescriptors(
     const std::vector<Vector2_f> &features, const cv::Mat &descriptors,
     int box_idx) {
-  CHECK_EQ(features.size(), descriptors.rows);
+  ABSL_CHECK_EQ(features.size(), descriptors.rows);
 
   std::vector<FeatureCorrespondence> correspondence_result(
       frame_box_[box_idx].size());
diff --git a/third_party/mediapipe/src/mediapipe/util/tracking/box_tracker.cc b/third_party/mediapipe/src/mediapipe/util/tracking/box_tracker.cc
index 2d1af779ee50e..61a9437b7e61f 100644
--- a/third_party/mediapipe/src/mediapipe/util/tracking/box_tracker.cc
+++ b/third_party/mediapipe/src/mediapipe/util/tracking/box_tracker.cc
@@ -19,6 +19,7 @@
 #include <fstream>
 #include <limits>
 
+#include "absl/log/absl_check.h"
 #include "absl/strings/str_cat.h"
 #include "absl/synchronization/mutex.h"
 #include "absl/time/clock.h"
@@ -36,7 +37,7 @@ static constexpr int kInitCheckpoint = -1;
 
 void MotionBoxStateQuadToVertices(const MotionBoxState::Quad& quad,
                                   std::vector<Vector2_f>* vertices) {
-  CHECK_EQ(TimedBox::kNumQuadVertices * 2, quad.vertices_size());
+  ABSL_CHECK_EQ(TimedBox::kNumQuadVertices * 2, quad.vertices_size());
   CHECK(vertices != nullptr);
   vertices->clear();
   for (int i = 0; i < TimedBox::kNumQuadVertices; ++i) {
@@ -47,7 +48,7 @@ void MotionBoxStateQuadToVertices(const MotionBoxState::Quad& quad,
 
 void VerticesToMotionBoxStateQuad(const std::vector<Vector2_f>& vertices,
                                   MotionBoxState::Quad* quad) {
-  CHECK_EQ(TimedBox::kNumQuadVertices, vertices.size());
+  ABSL_CHECK_EQ(TimedBox::kNumQuadVertices, vertices.size());
   CHECK(quad != nullptr);
   for (const Vector2_f& vertex : vertices) {
     quad->add_vertices(vertex.x());
@@ -113,7 +114,7 @@ namespace {
 
 TimedBox BlendTimedBoxes(const TimedBox& lhs, const TimedBox& rhs,
                          int64_t time_msec) {
-  CHECK_LT(lhs.time_msec, rhs.time_msec);
+  ABSL_CHECK_LT(lhs.time_msec, rhs.time_msec);
   const double alpha =
       (time_msec - lhs.time_msec) * 1.0 / (rhs.time_msec - lhs.time_msec);
   return TimedBox::Blend(lhs, rhs, alpha);
@@ -245,10 +246,10 @@ BoxTracker::BoxTracker(
 
 void BoxTracker::AddTrackingDataChunk(const TrackingDataChunk* chunk,
                                       bool copy_data) {
-  CHECK_GT(chunk->item_size(), 0) << "Empty chunk.";
+  ABSL_CHECK_GT(chunk->item_size(), 0) << "Empty chunk.";
   int64_t chunk_time_msec = chunk->item(0).timestamp_usec() / 1000;
   int chunk_idx = ChunkIdxFromTime(chunk_time_msec);
-  CHECK_GE(chunk_idx, tracking_data_.size()) << "Chunk is out of order.";
+  ABSL_CHECK_GE(chunk_idx, tracking_data_.size()) << "Chunk is out of order.";
   if (chunk_idx > tracking_data_.size()) {
     LOG(INFO) << "Resize tracking_data_ to " << chunk_idx;
     tracking_data_.resize(chunk_idx);
@@ -688,7 +689,7 @@ bool BoxTracker::WaitForChunkFile(int id, int checkpoint,
 
 int BoxTracker::ClosestFrameIndex(int64_t msec,
                                   const TrackingDataChunk& chunk) const {
-  CHECK_GT(chunk.item_size(), 0);
+  ABSL_CHECK_GT(chunk.item_size(), 0);
   typedef TrackingDataChunk::Item Item;
   Item item_to_find;
   item_to_find.set_timestamp_usec(msec * 1000);
@@ -749,8 +750,8 @@ void BoxTracker::TrackingImpl(const TrackingImplArgs& a) {
   MotionBox motion_box(track_step_options);
   const int chunk_data_size = a.chunk_data->item_size();
 
-  CHECK_GE(a.start_frame, 0);
-  CHECK_LT(a.start_frame, chunk_data_size);
+  ABSL_CHECK_GE(a.start_frame, 0);
+  ABSL_CHECK_LT(a.start_frame, chunk_data_size);
 
   VLOG(1) << " a.start_frame = " << a.start_frame << " @"
           << a.chunk_data->item(a.start_frame).timestamp_usec() << " with "
diff --git a/third_party/mediapipe/src/mediapipe/util/tracking/camera_motion.cc b/third_party/mediapipe/src/mediapipe/util/tracking/camera_motion.cc
index e753be71208a8..b2c137c8c0a00 100644
--- a/third_party/mediapipe/src/mediapipe/util/tracking/camera_motion.cc
+++ b/third_party/mediapipe/src/mediapipe/util/tracking/camera_motion.cc
@@ -16,6 +16,7 @@
 
 #include <numeric>
 
+#include "absl/log/absl_check.h"
 #include "absl/strings/str_format.h"
 #include "mediapipe/util/tracking/region_flow.h"
 
@@ -76,8 +77,8 @@ void CameraMotionToMixtureHomography(const CameraMotion& camera_motion,
 
 CameraMotion ComposeCameraMotion(const CameraMotion& lhs,
                                  const CameraMotion& rhs) {
-  CHECK_EQ(lhs.frame_width(), rhs.frame_width());
-  CHECK_EQ(lhs.frame_height(), rhs.frame_height());
+  ABSL_CHECK_EQ(lhs.frame_width(), rhs.frame_width());
+  ABSL_CHECK_EQ(lhs.frame_height(), rhs.frame_height());
 
   CameraMotion result = rhs;
   if (lhs.has_translation() || rhs.has_translation()) {
@@ -185,7 +186,7 @@ void SubtractCameraMotionFromFeatures(
     const std::vector<CameraMotion>& camera_motions,
     std::vector<RegionFlowFeatureList*>* feature_lists) {
   CHECK(feature_lists != nullptr);
-  CHECK_GE(camera_motions.size(), feature_lists->size());
+  ABSL_CHECK_GE(camera_motions.size(), feature_lists->size());
   if (feature_lists->empty()) {
     return;
   }
diff --git a/third_party/mediapipe/src/mediapipe/util/tracking/camera_motion.h b/third_party/mediapipe/src/mediapipe/util/tracking/camera_motion.h
index cadee78cbc1e5..379920b1ec216 100644
--- a/third_party/mediapipe/src/mediapipe/util/tracking/camera_motion.h
+++ b/third_party/mediapipe/src/mediapipe/util/tracking/camera_motion.h
@@ -17,6 +17,7 @@
 
 #include <vector>
 
+#include "absl/log/absl_check.h"
 #include "mediapipe/util/tracking/camera_motion.pb.h"
 #include "mediapipe/util/tracking/motion_models.h"
 #include "mediapipe/util/tracking/region_flow.pb.h"
@@ -236,7 +237,7 @@ void DownsampleMotionModels(
     std::vector<Model>* downsampled_models,
     std::vector<CameraMotion::Type>* downsampled_types) {
   if (model_type) {
-    CHECK_EQ(models.size(), model_type->size());
+    ABSL_CHECK_EQ(models.size(), model_type->size());
     CHECK(downsampled_models) << "Expecting output models.";
   }
 
diff --git a/third_party/mediapipe/src/mediapipe/util/tracking/flow_packager.cc b/third_party/mediapipe/src/mediapipe/util/tracking/flow_packager.cc
index dceacbcd9b366..01ee6f60cef93 100644
--- a/third_party/mediapipe/src/mediapipe/util/tracking/flow_packager.cc
+++ b/third_party/mediapipe/src/mediapipe/util/tracking/flow_packager.cc
@@ -20,6 +20,7 @@
 #include <cmath>
 #include <memory>
 
+#include "absl/log/absl_check.h"
 #include "absl/strings/str_cat.h"
 #include "absl/strings/string_view.h"
 #include "mediapipe/framework/port/logging.h"
@@ -36,8 +37,8 @@ namespace mediapipe {
 FlowPackager::FlowPackager(const FlowPackagerOptions& options)
     : options_(options) {
   if (options_.binary_tracking_data_support()) {
-    CHECK_LE(options.domain_width(), 256);
-    CHECK_LE(options.domain_height(), 256);
+    ABSL_CHECK_LE(options.domain_width(), 256);
+    ABSL_CHECK_LE(options.domain_height(), 256);
   }
 }
 
@@ -135,8 +136,8 @@ void FlowPackager::PackFlow(const RegionFlowFeatureList& feature_list,
                             const CameraMotion* camera_motion,
                             TrackingData* tracking_data) const {
   CHECK(tracking_data);
-  CHECK_GT(feature_list.frame_width(), 0);
-  CHECK_GT(feature_list.frame_height(), 0);
+  ABSL_CHECK_GT(feature_list.frame_width(), 0);
+  ABSL_CHECK_GT(feature_list.frame_height(), 0);
 
   // Scale flow to output domain.
   const float dim_x_scale =
@@ -231,12 +232,12 @@ void FlowPackager::PackFlow(const RegionFlowFeatureList& feature_list,
     const int curr_col = loc.x();
 
     if (curr_col != last_col) {
-      CHECK_LT(last_col, curr_col);
-      CHECK_EQ(-1, col_start[curr_col]);
+      ABSL_CHECK_LT(last_col, curr_col);
+      ABSL_CHECK_EQ(-1, col_start[curr_col]);
       col_start[curr_col] = data->row_indices_size() - 1;
       last_col = curr_col;
     } else {
-      CHECK_LE(last_row, loc.y());
+      ABSL_CHECK_LE(last_row, loc.y());
     }
     last_row = loc.y();
   }
@@ -247,7 +248,7 @@ void FlowPackager::PackFlow(const RegionFlowFeatureList& feature_list,
   // Fill unset values with previously set value. Propagate end value.
   for (int i = options_.domain_width() - 1; i > 0; --i) {
     if (col_start[i] < 0) {
-      DCHECK_GE(col_start[i + 1], 0);
+      ABSL_DCHECK_GE(col_start[i + 1], 0);
       col_start[i] = col_start[i + 1];
     }
   }
@@ -261,11 +262,11 @@ void FlowPackager::PackFlow(const RegionFlowFeatureList& feature_list,
     const int r_start = data->col_starts(c);
     const int r_end = data->col_starts(c + 1);
     for (int r = r_start; r < r_end - 1; ++r) {
-      CHECK_LE(data->row_indices(r), data->row_indices(r + 1));
+      ABSL_CHECK_LE(data->row_indices(r), data->row_indices(r + 1));
     }
   }
 
-  CHECK_EQ(data->vector_data_size(), 2 * data->row_indices_size());
+  ABSL_CHECK_EQ(data->vector_data_size(), 2 * data->row_indices_size());
 
   *data->mutable_actively_discarded_tracked_ids() =
       feature_list.actively_discarded_tracked_ids();
@@ -313,7 +314,7 @@ void FlowPackager::EncodeTrackingData(const TrackingData& tracking_data,
 
   const int32_t domain_width = tracking_data.domain_width();
   const int32_t domain_height = tracking_data.domain_height();
-  CHECK_LT(domain_height, 256) << "Only heights below 256 are supported.";
+  ABSL_CHECK_LT(domain_height, 256) << "Only heights below 256 are supported.";
   const float frame_aspect = tracking_data.frame_aspect();
 
   // Limit vector value from above (to 20% frame diameter) and below (small
@@ -393,7 +394,7 @@ void FlowPackager::EncodeTrackingData(const TrackingData& tracking_data,
           flow_compressed_8.push_back(flow_y);
         }
 
-        DCHECK_LT(motion_data.row_indices(r), 256);
+        ABSL_DCHECK_LT(motion_data.row_indices(r), 256);
         row_idx.push_back(motion_data.row_indices(r));
       }
     }
@@ -470,7 +471,7 @@ void FlowPackager::EncodeTrackingData(const TrackingData& tracking_data,
         // Delta compress.
         int delta_row = motion_data.row_indices(r) -
                         (r == r_start ? 0 : motion_data.row_indices(r - 1));
-        CHECK_GE(delta_row, 0);
+        ABSL_CHECK_GE(delta_row, 0);
 
         bool combined = false;
         if (r > r_start) {
@@ -520,9 +521,9 @@ void FlowPackager::EncodeTrackingData(const TrackingData& tracking_data,
     }
 
     if (options_.high_fidelity_16bit_encode()) {
-      CHECK_EQ(2 * encoded, flow_compressed_16.size());
+      ABSL_CHECK_EQ(2 * encoded, flow_compressed_16.size());
     } else {
-      CHECK_EQ(2 * encoded, flow_compressed_8.size());
+      ABSL_CHECK_EQ(2 * encoded, flow_compressed_8.size());
     }
 
     // Adjust column start by compressions.
@@ -530,11 +531,11 @@ void FlowPackager::EncodeTrackingData(const TrackingData& tracking_data,
     for (int k = 0; k < domain_width; ++k) {
       curr_adjust -= compressions_per_column[k];
       col_starts[k + 1] += curr_adjust;
-      CHECK_LE(col_starts[k], col_starts[k + 1]);
+      ABSL_CHECK_LE(col_starts[k], col_starts[k + 1]);
     }
 
-    CHECK_EQ(row_idx.size(), col_starts.back());
-    CHECK_EQ(num_vectors, row_idx.size() + compressible);
+    ABSL_CHECK_EQ(row_idx.size(), col_starts.back());
+    ABSL_CHECK_EQ(num_vectors, row_idx.size() + compressible);
   }
 
   // Delta compress col_starts.
@@ -542,7 +543,7 @@ void FlowPackager::EncodeTrackingData(const TrackingData& tracking_data,
   col_start_delta[0] = col_starts[0];
   for (int k = 1; k < domain_width + 1; ++k) {
     const int delta = col_starts[k] - col_starts[k - 1];
-    CHECK_LT(delta, 256) << "Only up to 255 items per column supported.";
+    ABSL_CHECK_LT(delta, 256) << "Only up to 255 items per column supported.";
     col_start_delta[k] = delta;
   }
 
@@ -618,8 +619,8 @@ void FlowPackager::DecodeTrackingData(const BinaryTrackingData& container_data,
   DecodeFromStringView(PopSubstring(4, &data), &domain_height);
   DecodeFromStringView(PopSubstring(4, &data), &frame_aspect);
 
-  CHECK_LE(domain_width, 256);
-  CHECK_LE(domain_height, 256);
+  ABSL_CHECK_LE(domain_width, 256);
+  ABSL_CHECK_LE(domain_height, 256);
 
   DecodeVectorFromStringView(
       PopSubstring(4 * HomographyAdapter::NumParameters(), &data),
@@ -662,7 +663,7 @@ void FlowPackager::DecodeTrackingData(const BinaryTrackingData& container_data,
 
   // Should not have more row indices than vectors. (One for each in baseline
   // profile, less in high profile).
-  CHECK_LE(row_idx_size, num_vectors);
+  ABSL_CHECK_LE(row_idx_size, num_vectors);
   DecodeVectorFromStringView(PopSubstring(row_idx_size, &data), &row_idx);
 
   // Records for each vector whether to advance pointer in the vector data array
@@ -707,7 +708,7 @@ void FlowPackager::DecodeTrackingData(const BinaryTrackingData& container_data,
       }
     }
     row_idx.swap(row_idx_unpacked);
-    CHECK_EQ(num_vectors, row_idx.size());
+    ABSL_CHECK_EQ(num_vectors, row_idx.size());
 
     // Adjust column start by expansions.
     int curr_adjust = 0;
@@ -717,7 +718,7 @@ void FlowPackager::DecodeTrackingData(const BinaryTrackingData& container_data,
     }
   }
 
-  CHECK_EQ(num_vectors, col_starts.back());
+  ABSL_CHECK_EQ(num_vectors, col_starts.back());
 
   int vector_data_size;
   DecodeFromStringView(PopSubstring(4, &data), &vector_data_size);
@@ -749,7 +750,7 @@ void FlowPackager::DecodeTrackingData(const BinaryTrackingData& container_data,
         motion_data->add_vector_data(prev_flow_y * flow_denom);
       }
     }
-    CHECK_EQ(vector_data_size, counter);
+    ABSL_CHECK_EQ(vector_data_size, counter);
   } else {
     std::vector<int8_t> vector_data;
     DecodeVectorFromStringView(
@@ -775,7 +776,7 @@ void FlowPackager::DecodeTrackingData(const BinaryTrackingData& container_data,
         motion_data->add_vector_data(prev_flow_y * flow_denom);
       }
     }
-    CHECK_EQ(vector_data_size, counter);
+    ABSL_CHECK_EQ(vector_data_size, counter);
   }
 
   for (auto idx : row_idx) {
@@ -799,8 +800,8 @@ void FlowPackager::BinaryTrackingDataToContainer(
 
 void FlowPackager::BinaryTrackingDataFromContainer(
     const TrackingContainer& container, BinaryTrackingData* binary_data) const {
-  CHECK_EQ("TRAK", container.header());
-  CHECK_EQ(1, container.version()) << "Unsupported version.";
+  ABSL_CHECK_EQ("TRAK", container.header());
+  ABSL_CHECK_EQ(1, container.version()) << "Unsupported version.";
   *binary_data->mutable_data() = container.data();
 }
 
@@ -808,8 +809,8 @@ void FlowPackager::DecodeMetaData(const TrackingContainer& container_data,
                                   MetaData* meta_data) const {
   CHECK(meta_data != nullptr);
 
-  CHECK_EQ("META", container_data.header());
-  CHECK_EQ(1, container_data.version()) << "Unsupported version.";
+  ABSL_CHECK_EQ("META", container_data.header());
+  ABSL_CHECK_EQ(1, container_data.version()) << "Unsupported version.";
 
   absl::string_view data(container_data.data());
 
@@ -840,7 +841,7 @@ void FlowPackager::FinalizeTrackingContainerFormat(
 
   std::vector<uint32_t> msecs(num_frames, 0);
   if (timestamps) {
-    CHECK_EQ(num_frames, timestamps->size());
+    ABSL_CHECK_EQ(num_frames, timestamps->size());
     msecs = *timestamps;
   }
   std::vector<int> sizes(num_frames, 0);
@@ -884,7 +885,7 @@ void FlowPackager::FinalizeTrackingContainerProto(
 
   std::vector<uint32_t> msecs(num_frames, 0);
   if (timestamps) {
-    CHECK_EQ(num_frames, timestamps->size());
+    ABSL_CHECK_EQ(num_frames, timestamps->size());
     msecs = *timestamps;
   }
 
@@ -909,8 +910,8 @@ void FlowPackager::InitializeMetaData(int num_frames,
                                       const std::vector<int>& data_sizes,
                                       MetaData* meta_data) const {
   meta_data->set_num_frames(num_frames);
-  CHECK_EQ(num_frames, msecs.size());
-  CHECK_EQ(num_frames, data_sizes.size());
+  ABSL_CHECK_EQ(num_frames, msecs.size());
+  ABSL_CHECK_EQ(num_frames, data_sizes.size());
 
   int curr_offset = 0;
   for (int f = 0; f < num_frames; ++f) {
@@ -925,7 +926,7 @@ void FlowPackager::AddContainerToString(const TrackingContainer& container,
                                         std::string* binary_data) {
   CHECK(binary_data != nullptr);
   std::string header_string(container.header());
-  CHECK_EQ(4, header_string.size());
+  ABSL_CHECK_EQ(4, header_string.size());
 
   std::vector<char> header{header_string[0], header_string[1], header_string[2],
                            header_string[3]};
@@ -938,8 +939,8 @@ std::string FlowPackager::SplitContainerFromString(
     absl::string_view* binary_data, TrackingContainer* container) {
   CHECK(binary_data != nullptr);
   CHECK(container != nullptr);
-  CHECK_GE(binary_data->size(), 12) << "Data does not contain "
-                                    << "valid container";
+  ABSL_CHECK_GE(binary_data->size(), 12) << "Data does not contain "
+                                         << "valid container";
 
   container->set_header(PopSubstring(4, binary_data));
 
@@ -979,18 +980,18 @@ void FlowPackager::TrackingContainerFormatFromBinary(
 
   absl::string_view data(binary);
 
-  CHECK_EQ("META", SplitContainerFromString(
-                       &data, container_format->mutable_meta_data()));
+  ABSL_CHECK_EQ("META", SplitContainerFromString(
+                            &data, container_format->mutable_meta_data()));
   MetaData meta_data;
   DecodeMetaData(container_format->meta_data(), &meta_data);
 
   for (int f = 0; f < meta_data.num_frames(); ++f) {
     TrackingContainer* container = container_format->add_track_data();
-    CHECK_EQ("TRAK", SplitContainerFromString(&data, container));
+    ABSL_CHECK_EQ("TRAK", SplitContainerFromString(&data, container));
   }
 
-  CHECK_EQ("TERM", SplitContainerFromString(
-                       &data, container_format->mutable_term_data()));
+  ABSL_CHECK_EQ("TERM", SplitContainerFromString(
+                            &data, container_format->mutable_term_data()));
 }
 
 void FlowPackager::SortRegionFlowFeatureList(
diff --git a/third_party/mediapipe/src/mediapipe/util/tracking/image_util.cc b/third_party/mediapipe/src/mediapipe/util/tracking/image_util.cc
index a44c00b01f4c8..a7e4a2f40f21f 100644
--- a/third_party/mediapipe/src/mediapipe/util/tracking/image_util.cc
+++ b/third_party/mediapipe/src/mediapipe/util/tracking/image_util.cc
@@ -17,6 +17,7 @@
 #include <algorithm>
 #include <vector>
 
+#include "absl/log/absl_check.h"
 #include "mediapipe/framework/port/logging.h"
 #include "mediapipe/util/tracking/motion_models.h"
 #include "mediapipe/util/tracking/region_flow.h"
@@ -26,7 +27,7 @@ namespace mediapipe {
 // Returns median of the L1 color distance between img_1 and img_2
 float FrameDifferenceMedian(const cv::Mat& img_1, const cv::Mat& img_2) {
   CHECK(img_1.size() == img_2.size());
-  CHECK_EQ(img_1.channels(), img_2.channels());
+  ABSL_CHECK_EQ(img_1.channels(), img_2.channels());
 
   std::vector<float> color_diffs;
   color_diffs.reserve(img_1.cols * img_1.rows);
diff --git a/third_party/mediapipe/src/mediapipe/util/tracking/image_util.h b/third_party/mediapipe/src/mediapipe/util/tracking/image_util.h
index ba58d343bc053..f1e7eda36169e 100644
--- a/third_party/mediapipe/src/mediapipe/util/tracking/image_util.h
+++ b/third_party/mediapipe/src/mediapipe/util/tracking/image_util.h
@@ -17,6 +17,7 @@
 
 #include <vector>
 
+#include "absl/log/absl_check.h"
 #include "mediapipe/framework/port/opencv_core_inc.h"
 #include "mediapipe/framework/port/opencv_imgproc_inc.h"
 #include "mediapipe/framework/port/vector.h"
@@ -75,7 +76,7 @@ void CopyMatBorder(cv::Mat* mat) {
     }
 
     // src and dst should point to same column from here.
-    DCHECK_EQ(0, (src_ptr - dst_ptr) * sizeof(T) % mat->step[0]);
+    ABSL_DCHECK_EQ(0, (src_ptr - dst_ptr) * sizeof(T) % mat->step[0]);
 
     // Top row copy.
     memcpy(dst_ptr, src_ptr, width * channels * sizeof(dst_ptr[0]));
@@ -122,7 +123,7 @@ void CopyMatBorder(cv::Mat* mat) {
     }
 
     // src and dst should point to same column from here.
-    DCHECK_EQ(0, (dst_ptr - src_ptr) * sizeof(T) % mat->step[0]);
+    ABSL_DCHECK_EQ(0, (dst_ptr - src_ptr) * sizeof(T) % mat->step[0]);
     memcpy(dst_ptr, src_ptr, width * channels * sizeof(dst_ptr[0]));
     src_ptr += width * channels;  // Points one behind the end.
     dst_ptr += width * channels;
diff --git a/third_party/mediapipe/src/mediapipe/util/tracking/motion_analysis.cc b/third_party/mediapipe/src/mediapipe/util/tracking/motion_analysis.cc
index 67973cbcf7612..d750977485b55 100644
--- a/third_party/mediapipe/src/mediapipe/util/tracking/motion_analysis.cc
+++ b/third_party/mediapipe/src/mediapipe/util/tracking/motion_analysis.cc
@@ -20,6 +20,7 @@
 #include <deque>
 #include <memory>
 
+#include "absl/log/absl_check.h"
 #include "absl/strings/str_format.h"
 #include "mediapipe/framework/port/integral_types.h"
 #include "mediapipe/framework/port/logging.h"
@@ -92,8 +93,8 @@ MotionAnalysis::MotionAnalysis(const MotionAnalysisOptions& options,
       use_spatial_bias;
 
   if (compute_feature_descriptors_) {
-    CHECK_EQ(RegionFlowComputationOptions::FORMAT_RGB,
-             options_.flow_options().image_format())
+    ABSL_CHECK_EQ(RegionFlowComputationOptions::FORMAT_RGB,
+                  options_.flow_options().image_format())
         << "Feature descriptors only support RGB currently.";
     prev_frame_.reset(new cv::Mat(frame_height_, frame_width_, CV_8UC3));
   }
@@ -479,7 +480,7 @@ int MotionAnalysis::GetResults(
 
   const int num_features_lists = buffer_->BufferSize("features");
   const int num_new_feature_lists = num_features_lists - overlap_start_;
-  CHECK_GE(num_new_feature_lists, 0);
+  ABSL_CHECK_GE(num_new_feature_lists, 0);
 
   if (!flush && num_new_feature_lists < options_.estimation_clip_size()) {
     // Nothing to compute, return.
@@ -487,7 +488,7 @@ int MotionAnalysis::GetResults(
   }
 
   const bool compute_saliency = options_.compute_motion_saliency();
-  CHECK_EQ(compute_saliency, saliency != nullptr)
+  ABSL_CHECK_EQ(compute_saliency, saliency != nullptr)
       << "Computing saliency requires saliency output and vice versa";
 
   // Estimate motions for newly buffered RegionFlowFeatureLists, which also
@@ -528,7 +529,7 @@ int MotionAnalysis::OutputResults(
     std::vector<std::unique_ptr<CameraMotion>>* camera_motion,
     std::vector<std::unique_ptr<SalientPointFrame>>* saliency) {
   const bool compute_saliency = options_.compute_motion_saliency();
-  CHECK_EQ(compute_saliency, saliency != nullptr)
+  ABSL_CHECK_EQ(compute_saliency, saliency != nullptr)
       << "Computing saliency requires saliency output and vice versa";
   CHECK(buffer_->HaveEqualSize({"features", "motion"}));
 
@@ -598,7 +599,7 @@ int MotionAnalysis::OutputResults(
 
   // Reset for next chunk.
   prev_overlap_start_ = num_output_frames - new_overlap_start;
-  CHECK_GE(prev_overlap_start_, 0);
+  ABSL_CHECK_GE(prev_overlap_start_, 0);
 
   CHECK(buffer_->TruncateBuffer(flush));
 
@@ -612,8 +613,8 @@ void MotionAnalysis::RenderResults(const RegionFlowFeatureList& feature_list,
                                    cv::Mat* rendered_results) {
 #ifndef NO_RENDERING
   CHECK(rendered_results != nullptr);
-  CHECK_EQ(frame_width_, rendered_results->cols);
-  CHECK_EQ(frame_height_, rendered_results->rows);
+  ABSL_CHECK_EQ(frame_width_, rendered_results->cols);
+  ABSL_CHECK_EQ(frame_height_, rendered_results->rows);
 
   const auto viz_options = options_.visualization_options();
 
@@ -797,7 +798,7 @@ void MotionAnalysis::VisualizeBlurAnalysisRegions(cv::Mat* input_view) {
 
 void MotionAnalysis::ComputeSaliency() {
   MEASURE_TIME << "Saliency computation.";
-  CHECK_EQ(overlap_start_, buffer_->BufferSize("saliency"));
+  ABSL_CHECK_EQ(overlap_start_, buffer_->BufferSize("saliency"));
 
   const int num_features_lists = buffer_->BufferSize("features");
 
diff --git a/third_party/mediapipe/src/mediapipe/util/tracking/motion_estimation.cc b/third_party/mediapipe/src/mediapipe/util/tracking/motion_estimation.cc
index b608b470559d8..1da649682670f 100644
--- a/third_party/mediapipe/src/mediapipe/util/tracking/motion_estimation.cc
+++ b/third_party/mediapipe/src/mediapipe/util/tracking/motion_estimation.cc
@@ -31,6 +31,7 @@
 #include "Eigen/SVD"
 #include "absl/container/node_hash_map.h"
 #include "absl/container/node_hash_set.h"
+#include "absl/log/absl_check.h"
 #include "absl/strings/str_cat.h"
 #include "mediapipe/framework/port/logging.h"
 #include "mediapipe/util/tracking/camera_motion.h"
@@ -175,7 +176,7 @@ class InlierMask {
                    std::vector<float>* motion_prior) {
     CHECK(motion_prior != nullptr);
     const int num_features = feature_list.feature_size();
-    CHECK_EQ(num_features, motion_prior->size());
+    ABSL_CHECK_EQ(num_features, motion_prior->size());
 
     // Return, if prior is too low.
     const float kMinTranslationPrior = 0.5f;
@@ -185,7 +186,7 @@ class InlierMask {
     }
     const float prev_magnitude = translation_.Norm();
 
-    CHECK_EQ(num_features, motion_prior->size());
+    ABSL_CHECK_EQ(num_features, motion_prior->size());
     const float inv_prev_magnitude =
         prev_magnitude < options_.min_translation_norm()
             ? (1.0f / options_.min_translation_norm())
@@ -398,21 +399,21 @@ struct MotionEstimation::SingleTrackClipData {
   void CheckInitialization() const {
     CHECK(feature_lists != nullptr);
     CHECK(camera_motions != nullptr);
-    CHECK_EQ(feature_lists->size(), camera_motions->size());
+    ABSL_CHECK_EQ(feature_lists->size(), camera_motions->size());
     if (feature_lists->empty()) {
       return;
     }
 
-    CHECK_EQ(num_frames(), irls_weight_input.size());
-    CHECK_EQ(num_frames(), homog_irls_weight_input.size());
+    ABSL_CHECK_EQ(num_frames(), irls_weight_input.size());
+    ABSL_CHECK_EQ(num_frames(), homog_irls_weight_input.size());
     if (irls_weight_backup) {
-      CHECK_EQ(num_frames(), irls_weight_backup->size());
+      ABSL_CHECK_EQ(num_frames(), irls_weight_backup->size());
     }
 
     for (int k = 0; k < num_frames(); ++k) {
       const int num_features = (*feature_lists)[k]->feature_size();
-      CHECK_EQ(num_features, irls_weight_input[k].size());
-      CHECK_EQ(num_features, homog_irls_weight_input[k].size());
+      ABSL_CHECK_EQ(num_features, irls_weight_input[k].size());
+      ABSL_CHECK_EQ(num_features, homog_irls_weight_input[k].size());
     }
   }
 
@@ -500,15 +501,15 @@ void MotionEstimation::InitializeWithOptions(
   }
 
   // Check for deprecated options.
-  CHECK_NE(options.estimate_similarity(), true)
+  ABSL_CHECK_NE(options.estimate_similarity(), true)
       << "Option estimate_similarity is deprecated, use static function "
       << "EstimateSimilarityModelL2 instead.";
-  CHECK_NE(options.linear_similarity_estimation(),
-           MotionEstimationOptions::ESTIMATION_LS_L2_RANSAC)
+  ABSL_CHECK_NE(options.linear_similarity_estimation(),
+                MotionEstimationOptions::ESTIMATION_LS_L2_RANSAC)
       << "Option ESTIMATION_LS_L2_RANSAC is deprecated, use "
       << "ESTIMATION_LS_IRLS instead.";
-  CHECK_NE(options.linear_similarity_estimation(),
-           MotionEstimationOptions::ESTIMATION_LS_L1)
+  ABSL_CHECK_NE(options.linear_similarity_estimation(),
+                MotionEstimationOptions::ESTIMATION_LS_L1)
       << "Option ESTIMATION_LS_L1 is deprecated, use static function "
       << "EstimateLinearSimilarityL1 instead.";
 
@@ -825,7 +826,7 @@ void MotionEstimation::EstimateMotionsParallelImpl(
   CHECK(camera_motions != nullptr);
 
   const int num_frames = feature_lists->size();
-  CHECK_EQ(num_frames, camera_motions->size());
+  ABSL_CHECK_EQ(num_frames, camera_motions->size());
 
   // Initialize camera_motions.
   for (int f = 0; f < num_frames; ++f) {
@@ -866,7 +867,7 @@ void MotionEstimation::EstimateMotionsParallelImpl(
   const int num_motion_models =
       use_joint_tracks ? options_.joint_track_estimation().num_motion_models()
                        : 1;
-  CHECK_GT(num_motion_models, 0);
+  ABSL_CHECK_GT(num_motion_models, 0);
 
   // Several single track clip datas, we seek to process.
   std::vector<SingleTrackClipData> clip_datas(num_motion_models);
@@ -1080,7 +1081,8 @@ void MotionEstimation::EstimateMotionsParallelImpl(
   // Estimate mixtures across a spectrum a different regularizers, from the
   // weakest to the most regularized one.
   const int num_mixture_levels = options_.mixture_regularizer_levels();
-  CHECK_LE(num_mixture_levels, 10) << "Only up to 10 mixtures are supported.";
+  ABSL_CHECK_LE(num_mixture_levels, 10)
+      << "Only up to 10 mixtures are supported.";
 
   // Initialize to weakest regularizer.
   float regularizer = options_.mixture_regularizer();
@@ -1124,8 +1126,8 @@ void MotionEstimation::EstimateMotionsParallelImpl(
   // Check that mixture spectrum has sufficient entries.
   for (const CameraMotion& motion : *camera_motions) {
     if (motion.mixture_homography_spectrum_size() > 0) {
-      CHECK_EQ(motion.mixture_homography_spectrum_size(),
-               options_.mixture_regularizer_levels());
+      ABSL_CHECK_EQ(motion.mixture_homography_spectrum_size(),
+                    options_.mixture_regularizer_levels());
     }
   }
 
@@ -1570,7 +1572,7 @@ class IrlsInitializationInvoker {
 
       // Initialize priors from irls weights.
       if (use_prior_weights) {
-        CHECK_LT(frame, clip_data_->prior_weights.size());
+        ABSL_CHECK_LT(frame, clip_data_->prior_weights.size());
 
         if (clip_data_->prior_weights[frame].priors.empty()) {
           clip_data_->prior_weights[frame].priors.resize(
@@ -1610,7 +1612,7 @@ void MotionEstimation::LongFeatureInitialization(
     return;
   }
 
-  CHECK_EQ(num_features, irls_weights->size());
+  ABSL_CHECK_EQ(num_features, irls_weights->size());
 
   // Determine actual scale to be applied to each feature.
   std::vector<float> feature_scales(num_features);
@@ -1644,7 +1646,7 @@ void MotionEstimation::FeatureDensityNormalization(
     std::vector<float>* irls_weights) const {
   CHECK(irls_weights);
   const int num_features = feature_list.feature_size();
-  CHECK_EQ(num_features, irls_weights->size());
+  ABSL_CHECK_EQ(num_features, irls_weights->size());
 
   // Compute mask index for each feature.
   std::vector<int> bin_indices;
@@ -1707,13 +1709,13 @@ void MotionEstimation::FeatureDensityNormalization(
 
     float normalizer = 0;
     int bin_idx = int_grid_y * mask_size + int_grid_x;
-    CHECK_LT(bin_idx, max_bins);
+    ABSL_CHECK_LT(bin_idx, max_bins);
     // See above.
     normalizer += bin_normalizer[bin_idx] * (1 - dx_plus_dy + dxdy);
     normalizer += bin_normalizer[bin_idx + inc_x] * (dx - dxdy);
 
     bin_idx += mask_size * inc_y;
-    CHECK_LT(bin_idx, max_bins);
+    ABSL_CHECK_LT(bin_idx, max_bins);
     normalizer += bin_normalizer[bin_idx] * (dy - dxdy);
     normalizer += bin_normalizer[bin_idx + inc_x] * dxdy;
 
@@ -1738,8 +1740,8 @@ void MotionEstimation::IrlsInitialization(
     SingleTrackClipData* clip_data) const {
   if (options_.estimation_policy() ==
       MotionEstimationOptions::TEMPORAL_LONG_FEATURE_BIAS) {
-    CHECK_NE(frame, -1) << "Only per frame processing for this policy "
-                        << "supported.";
+    ABSL_CHECK_NE(frame, -1) << "Only per frame processing for this policy "
+                             << "supported.";
   }
 
   IrlsInitializationInvoker invoker(type, max_unstable_type, model_options,
@@ -1763,8 +1765,8 @@ void MotionEstimation::IrlsInitialization(
 
     for_function(0, clip_data->num_frames(), 1, invoker);
   } else {
-    CHECK_GE(frame, 0);
-    CHECK_LT(frame, clip_data->num_frames());
+    ABSL_CHECK_GE(frame, 0);
+    ABSL_CHECK_LT(frame, clip_data->num_frames());
     invoker(BlockedRange(frame, frame + 1, 1));
   }
 }
@@ -1960,7 +1962,7 @@ void MotionEstimation::BiasLongFeatures(
     prior_weights->priors.resize(num_features, 1.0f);
   }
 
-  CHECK_EQ(num_features, prior_weights->priors.size());
+  ABSL_CHECK_EQ(num_features, prior_weights->priors.size());
   for (int k = 0; k < num_features; ++k) {
     prior_weights->priors[k] *= bias[k];
     auto* feature = feature_list->mutable_feature(k);
@@ -1993,7 +1995,7 @@ void MotionEstimation::ComputeSpatialBias(
   BuildFeatureGrid(NormalizedDomain().x(), NormalizedDomain().y(),
                    bias_options.grid_size(), {feature_view}, FeatureLocation,
                    &feature_taps_3, nullptr, nullptr, &feature_grids);
-  CHECK_EQ(1, feature_grids.size());
+  ABSL_CHECK_EQ(1, feature_grids.size());
   const FeatureGrid<RegionFlowFeature>& single_grid = feature_grids[0];
 
   const float long_track_threshold = bias_options.long_track_threshold();
@@ -2118,7 +2120,7 @@ void MotionEstimation::UpdateLongFeatureBias(
   const auto& bias_options = options_.long_feature_bias_options();
   const int num_irls_observations = bias_options.num_irls_observations();
 
-  CHECK_GT(num_irls_observations, 0) << "Specify value > 0";
+  ABSL_CHECK_GT(num_irls_observations, 0) << "Specify value > 0";
   const float inv_num_irls_observations = 1.0f / num_irls_observations;
 
   SpatialBiasMap spatial_bias;
@@ -2137,7 +2139,7 @@ void MotionEstimation::UpdateLongFeatureBias(
 
   // Scale applied to irls weight for linear interpolation between inlier and
   // outlier bias.
-  CHECK_GT(bias_options.inlier_irls_weight(), 0);
+  ABSL_CHECK_GT(bias_options.inlier_irls_weight(), 0);
   const float irls_scale = 1.0f / bias_options.inlier_irls_weight();
   const float long_track_scale =
       1.0f / bias_options.long_track_confidence_fraction();
@@ -2434,9 +2436,9 @@ void MotionEstimation::CheckModelStability(
   CHECK(camera_motions != nullptr);
   const int num_frames = feature_lists->size();
   if (reset_irls_weights) {
-    DCHECK_EQ(num_frames, reset_irls_weights->size());
+    ABSL_DCHECK_EQ(num_frames, reset_irls_weights->size());
   }
-  DCHECK_EQ(num_frames, camera_motions->size());
+  ABSL_DCHECK_EQ(num_frames, camera_motions->size());
 
   for (int f = 0; f < num_frames; ++f) {
     CameraMotion& camera_motion = (*camera_motions)[f];
@@ -2470,7 +2472,7 @@ void MotionEstimation::CheckSingleModelStability(
                               camera_motion->translation_variance(),
                               *feature_list)) {
         // Translation can never be singular.
-        CHECK_EQ(
+        ABSL_CHECK_EQ(
             0, camera_motion->flags() & CameraMotion::FLAG_SINGULAR_ESTIMATION);
       } else {
         // Invalid model.
@@ -2697,7 +2699,7 @@ void MotionEstimation::DetermineShotBoundaries(
     const std::vector<RegionFlowFeatureList*>& feature_lists,
     std::vector<CameraMotion>* camera_motions) const {
   CHECK(camera_motions != nullptr);
-  CHECK_EQ(feature_lists.size(), camera_motions->size());
+  ABSL_CHECK_EQ(feature_lists.size(), camera_motions->size());
   const auto& shot_options = options_.shot_boundary_options();
 
   // Verify empty feature frames and invalid models via visual consistency.
@@ -3493,11 +3495,11 @@ void MotionEstimation::ComputeSimilarityInliers(
   float threshold = std::max<float>(similarity_bounds.inlier_threshold(),
                                     similarity_bounds.frac_inlier_threshold() *
                                         hypot(frame_width_, frame_height_));
-  CHECK_GT(threshold, 0);
+  ABSL_CHECK_GT(threshold, 0);
 
   threshold = 1.0f / threshold;
   float strict_threshold = similarity_bounds.strict_inlier_threshold();
-  CHECK_GT(strict_threshold, 0);
+  ABSL_CHECK_GT(strict_threshold, 0);
   strict_threshold = 1.0f / strict_threshold;
 
   if (!options_.irls_use_l0_norm()) {
@@ -3761,12 +3763,12 @@ bool HomographyL2QRSolve(
     Eigen::Matrix<T, 8, 1>* solution) {
   CHECK(matrix);
   CHECK(solution);
-  CHECK_EQ(8, matrix->cols());
+  ABSL_CHECK_EQ(8, matrix->cols());
   const int num_rows =
       2 * feature_list.feature_size() + (perspective_regularizer == 0 ? 0 : 1);
-  CHECK_EQ(num_rows, matrix->rows());
-  CHECK_EQ(1, solution->cols());
-  CHECK_EQ(8, solution->rows());
+  ABSL_CHECK_EQ(num_rows, matrix->rows());
+  ABSL_CHECK_EQ(1, solution->cols());
+  ABSL_CHECK_EQ(8, solution->rows());
 
   // Compute homography from features (H * location = prev_location).
   *matrix = Eigen::Matrix<T, Eigen::Dynamic, 8>::Zero(matrix->rows(), 8);
@@ -4066,11 +4068,12 @@ bool MixtureHomographyL2DLTSolve(
   const int num_dof = 8 * num_models;
   const int num_constraints = num_dof - 8;
 
-  CHECK_EQ(matrix->cols(), num_dof);
+  ABSL_CHECK_EQ(matrix->cols(), num_dof);
   // 2 Rows (x,y) per feature.
-  CHECK_EQ(matrix->rows(), 2 * feature_list.feature_size() + num_constraints);
-  CHECK_EQ(solution->cols(), 1);
-  CHECK_EQ(solution->rows(), num_dof);
+  ABSL_CHECK_EQ(matrix->rows(),
+                2 * feature_list.feature_size() + num_constraints);
+  ABSL_CHECK_EQ(solution->cols(), 1);
+  ABSL_CHECK_EQ(solution->rows(), num_dof);
 
   // Compute homography from features. (H * location = prev_location)
   *matrix = Eigen::MatrixXf::Zero(matrix->rows(), matrix->cols());
@@ -4162,11 +4165,12 @@ bool TransMixtureHomographyL2DLTSolve(
   const int num_dof = 6 + 2 * num_models;
   const int num_constraints = 2 * (num_models - 1);
 
-  CHECK_EQ(matrix->cols(), num_dof);
+  ABSL_CHECK_EQ(matrix->cols(), num_dof);
   // 2 Rows (x,y) per feature.
-  CHECK_EQ(matrix->rows(), 2 * feature_list.feature_size() + num_constraints);
-  CHECK_EQ(solution->cols(), 1);
-  CHECK_EQ(solution->rows(), num_dof);
+  ABSL_CHECK_EQ(matrix->rows(),
+                2 * feature_list.feature_size() + num_constraints);
+  ABSL_CHECK_EQ(solution->cols(), 1);
+  ABSL_CHECK_EQ(solution->rows(), num_dof);
 
   // Compute homography from features. (H * location = prev_location)
   *matrix = Eigen::MatrixXf::Zero(matrix->rows(), matrix->cols());
@@ -4261,11 +4265,12 @@ bool SkewRotMixtureHomographyL2DLTSolve(
   const int num_dof = 4 + 4 * num_models;
   const int num_constraints = 4 * (num_models - 1);
 
-  CHECK_EQ(matrix->cols(), num_dof);
+  ABSL_CHECK_EQ(matrix->cols(), num_dof);
   // 2 Rows (x,y) per feature.
-  CHECK_EQ(matrix->rows(), 2 * feature_list.feature_size() + num_constraints);
-  CHECK_EQ(solution->cols(), 1);
-  CHECK_EQ(solution->rows(), num_dof);
+  ABSL_CHECK_EQ(matrix->rows(),
+                2 * feature_list.feature_size() + num_constraints);
+  ABSL_CHECK_EQ(solution->cols(), 1);
+  ABSL_CHECK_EQ(solution->rows(), num_dof);
 
   // Compute homography from features. (H * location = prev_location)
   *matrix = Eigen::MatrixXf::Zero(matrix->rows(), matrix->cols());
@@ -4669,7 +4674,7 @@ float MotionEstimation::GridCoverage(
 
   const std::vector<float>& grid_cell_weights =
       thread_storage->GridCoverageInitializationWeights();
-  CHECK_EQ(mask_size, grid_cell_weights.size());
+  ABSL_CHECK_EQ(mask_size, grid_cell_weights.size());
 
   const float max_inlier_score = 1.75f * min_inlier_score;
   const float mid_inlier_score = 0.5 * (min_inlier_score + max_inlier_score);
@@ -4694,7 +4699,7 @@ float MotionEstimation::GridCoverage(
           normalized_domain_.x() / grid_size * overlap_x / num_overlaps;
       std::vector<std::vector<float>>& irls_mask =
           *thread_storage->EmptyGridCoverageIrlsMask();
-      CHECK_EQ(mask_size, irls_mask.size());
+      ABSL_CHECK_EQ(mask_size, irls_mask.size());
 
       // Bin features.
       for (const auto& feature : feature_list.feature()) {
@@ -4738,7 +4743,7 @@ float MotionEstimation::GridCoverage(
 
   const float cell_weight_sum =
       std::accumulate(grid_cell_weights.begin(), grid_cell_weights.end(), 0.0f);
-  CHECK_GT(cell_weight_sum, 0);
+  ABSL_CHECK_GT(cell_weight_sum, 0);
 
   return std::inner_product(max_coverage.begin(), max_coverage.end(),
                             grid_cell_weights.begin(), 0.0f) /
@@ -5088,8 +5093,8 @@ bool MotionEstimation::MixtureHomographyFromFeature(
   // Compute weights if necessary.
   // Compute scale to index mixture weights from normalization.
   CHECK(row_weights_.get() != nullptr);
-  CHECK_EQ(row_weights_->YScale(), frame_height_ / normalized_domain_.y());
-  CHECK_EQ(row_weights_->NumModels(), num_mixtures);
+  ABSL_CHECK_EQ(row_weights_->YScale(), frame_height_ / normalized_domain_.y());
+  ABSL_CHECK_EQ(row_weights_->NumModels(), num_mixtures);
 
   const MotionEstimationOptions::MixtureModelMode mixture_mode =
       options_.mixture_model_mode();
@@ -5444,7 +5449,7 @@ void MotionEstimation::DetermineOverlayIndices(
   // Two stage estimation: First translation only, followed by
   // overlay analysis.
   const int num_frames = feature_lists->size();
-  CHECK_EQ(num_frames, camera_motions->size());
+  ABSL_CHECK_EQ(num_frames, camera_motions->size());
 
   std::vector<CameraMotion> translation_motions(num_frames);
   const int irls_per_round = options_.irls_rounds();
@@ -5521,7 +5526,7 @@ float MotionEstimation::OverlayAnalysis(
     std::vector<int>* overlay_indices) const {
   CHECK(feature_lists != nullptr);
   CHECK(overlay_indices != nullptr);
-  CHECK_EQ(feature_lists->size(), translations.size());
+  ABSL_CHECK_EQ(feature_lists->size(), translations.size());
   overlay_indices->clear();
 
   const int grid_size =
@@ -5717,7 +5722,7 @@ void TemporalIRLSPush(const FeatureGrid<RegionFlowFeature>& curr_grid,
     }
 
     // Only zero if spatial AND feature sigma = 0.
-    DCHECK_GT(weight_sum, 0);
+    ABSL_DCHECK_GT(weight_sum, 0);
     feature->mutable_internal_irls()->set_weight_sum(weight_sum);
     feature->mutable_internal_irls()->set_value_sum(value_sum);
   }
@@ -5829,7 +5834,7 @@ void TemporalIRLSPull(const FeatureGrid<RegionFlowFeature>& curr_grid,
       }
     }
 
-    CHECK_GT(weight_sum, 0) << feature->irls_weight();
+    ABSL_CHECK_GT(weight_sum, 0) << feature->irls_weight();
     feature->mutable_internal_irls()->set_weight_sum(weight_sum);
     feature->mutable_internal_irls()->set_value_sum(value_sum);
   }
diff --git a/third_party/mediapipe/src/mediapipe/util/tracking/motion_models.cc b/third_party/mediapipe/src/mediapipe/util/tracking/motion_models.cc
index eb6a8b314db6b..5d6645f9fe177 100644
--- a/third_party/mediapipe/src/mediapipe/util/tracking/motion_models.cc
+++ b/third_party/mediapipe/src/mediapipe/util/tracking/motion_models.cc
@@ -22,6 +22,7 @@
 
 #include "Eigen/Core"
 #include "Eigen/Dense"
+#include "absl/log/absl_check.h"
 #include "absl/strings/str_format.h"
 
 // Set to true to use catmull rom mixture weights instead of Gaussian weights
@@ -43,10 +44,10 @@ AffineModel ModelAdapter<TranslationModel>::ToAffine(
 
 TranslationModel ModelAdapter<TranslationModel>::FromAffine(
     const AffineModel& model) {
-  DCHECK_EQ(model.a(), 1);
-  DCHECK_EQ(model.b(), 0);
-  DCHECK_EQ(model.c(), 0);
-  DCHECK_EQ(model.d(), 1);
+  ABSL_DCHECK_EQ(model.a(), 1);
+  ABSL_DCHECK_EQ(model.b(), 0);
+  ABSL_DCHECK_EQ(model.c(), 0);
+  ABSL_DCHECK_EQ(model.d(), 1);
 
   return TranslationAdapter::FromArgs(model.dx(), model.dy());
 }
@@ -235,7 +236,7 @@ std::string ModelAdapter<SimilarityModel>::ToString(
 SimilarityModel ModelAdapter<SimilarityModel>::NormalizationTransform(
     float frame_width, float frame_height) {
   const float scale = std::hypot(frame_width, frame_height);
-  DCHECK_NE(scale, 0);
+  ABSL_DCHECK_NE(scale, 0);
   return SimilarityAdapter::FromArgs(0, 0, 1.0 / scale, 0);
 }
 
@@ -262,8 +263,8 @@ AffineModel ModelAdapter<LinearSimilarityModel>::ToAffine(
 
 LinearSimilarityModel ModelAdapter<LinearSimilarityModel>::FromAffine(
     const AffineModel& model) {
-  DCHECK_EQ(model.a(), model.d());
-  DCHECK_EQ(model.b(), -model.c());
+  ABSL_DCHECK_EQ(model.a(), model.d());
+  ABSL_DCHECK_EQ(model.b(), -model.c());
 
   return LinearSimilarityAdapter::FromArgs(model.dx(), model.dy(), model.a(),
                                            -model.b());
@@ -330,7 +331,7 @@ LinearSimilarityModel
 ModelAdapter<LinearSimilarityModel>::NormalizationTransform(
     float frame_width, float frame_height) {
   const float scale = std::hypot(frame_width, frame_height);
-  DCHECK_NE(scale, 0);
+  ABSL_DCHECK_NE(scale, 0);
   return LinearSimilarityAdapter::FromArgs(0, 0, 1.0 / scale, 0);
 }
 
@@ -368,7 +369,7 @@ std::string ModelAdapter<AffineModel>::ToString(const AffineModel& model) {
 AffineModel ModelAdapter<AffineModel>::NormalizationTransform(
     float frame_width, float frame_height) {
   const float scale = std::hypot(frame_width, frame_height);
-  DCHECK_NE(scale, 0);
+  ABSL_DCHECK_NE(scale, 0);
   return AffineAdapter::FromArgs(0, 0, 1.0f / scale, 0, 0, 1.0f / scale);
 }
 
@@ -379,8 +380,8 @@ Homography ModelAdapter<AffineModel>::ToHomography(const AffineModel& model) {
 }
 
 AffineModel ModelAdapter<AffineModel>::FromHomography(const Homography& model) {
-  DCHECK_EQ(model.h_20(), 0);
-  DCHECK_EQ(model.h_21(), 0);
+  ABSL_DCHECK_EQ(model.h_20(), 0);
+  ABSL_DCHECK_EQ(model.h_21(), 0);
 
   float params[6] = {model.h_02(), model.h_12(),   // dx, dy
                      model.h_00(), model.h_01(),   // a, b
@@ -582,8 +583,8 @@ std::string ModelAdapter<Homography>::ToString(const Homography& model) {
 }
 
 AffineModel ModelAdapter<Homography>::ToAffine(const Homography& model) {
-  DCHECK_EQ(model.h_20(), 0);
-  DCHECK_EQ(model.h_21(), 0);
+  ABSL_DCHECK_EQ(model.h_20(), 0);
+  ABSL_DCHECK_EQ(model.h_21(), 0);
   AffineModel affine_model;
   affine_model.set_a(model.h_00());
   affine_model.set_b(model.h_01());
@@ -629,7 +630,7 @@ void ModelAdapter<Homography>::GetJacobianAtPoint(const Vector2_f& pt,
 Homography ModelAdapter<Homography>::NormalizationTransform(
     float frame_width, float frame_height) {
   const float scale = std::hypot(frame_width, frame_height);
-  DCHECK_NE(scale, 0);
+  ABSL_DCHECK_NE(scale, 0);
   return HomographyAdapter::FromArgs(1.0f / scale, 0, 0, 0, 1.0f / scale, 0, 0,
                                      0);
 }
@@ -860,7 +861,7 @@ MixtureRowWeights::MixtureRowWeights(int frame_height, int margin, float sigma,
         weight_ptr[int_pos] += spline_weights[0];  // Double knot.
       }
 
-      CHECK_LT(int_pos, num_models - 1);
+      ABSL_CHECK_LT(int_pos, num_models - 1);
       weight_ptr[int_pos + 1] += spline_weights[2];
       if (int_pos + 1 < num_models - 1) {
         weight_ptr[int_pos + 2] += spline_weights[3];
@@ -897,7 +898,7 @@ MixtureRowWeights::MixtureRowWeights(int frame_height, int margin, float sigma,
       }
 
       // Normalize.
-      DCHECK_GT(weight_sum, 0);
+      ABSL_DCHECK_GT(weight_sum, 0);
       const float inv_weight_sum = 1.0f / weight_sum;
       for (int j = 0; j < num_models; ++j) {
         weight_ptr[j] *= inv_weight_sum;
diff --git a/third_party/mediapipe/src/mediapipe/util/tracking/motion_models.h b/third_party/mediapipe/src/mediapipe/util/tracking/motion_models.h
index 567831ad5e755..4edf28abf2a7c 100644
--- a/third_party/mediapipe/src/mediapipe/util/tracking/motion_models.h
+++ b/third_party/mediapipe/src/mediapipe/util/tracking/motion_models.h
@@ -21,6 +21,7 @@
 #include <vector>
 
 #include "absl/container/node_hash_map.h"
+#include "absl/log/absl_check.h"
 #include "mediapipe/framework/port/logging.h"
 #include "mediapipe/framework/port/singleton.h"
 #include "mediapipe/framework/port/vector.h"
@@ -762,8 +763,8 @@ Model UniformModelParameters(const float value) {
 template <class Model>
 Model BlendModels(const Model& a, const Model& b, float weight_b) {
   Model blended;
-  DCHECK_GE(weight_b, 0);
-  DCHECK_LE(weight_b, 1);
+  ABSL_DCHECK_GE(weight_b, 0);
+  ABSL_DCHECK_LE(weight_b, 1);
   const float weight_a = 1 - weight_b;
   for (int p = 0; p < ModelAdapter<Model>::NumParameters(); ++p) {
     const float pa = ModelAdapter<Model>::GetParameter(a, p);
@@ -822,8 +823,8 @@ class MixtureRowWeights {
 
   const float* RowWeights(float y) const {
     int bin_y = y * y_scale_ + 0.5;
-    DCHECK_LT(bin_y, frame_height_ + margin_);
-    DCHECK_GE(bin_y, -margin_);
+    ABSL_DCHECK_LT(bin_y, frame_height_ + margin_);
+    ABSL_DCHECK_GE(bin_y, -margin_);
     return &weights_[(bin_y + margin_) * num_models_];
   }
 
@@ -1398,7 +1399,7 @@ inline Homography ModelAdapter<Homography>::Compose(const Homography& lhs,
   Homography result;
   const float z =
       lhs.h_20() * rhs.h_02() + lhs.h_21() * rhs.h_12() + 1.0f * 1.0f;
-  CHECK_NE(z, 0) << "Degenerate homography. See proto.";
+  ABSL_CHECK_NE(z, 0) << "Degenerate homography. See proto.";
   const float inv_z = 1.0 / z;
 
   result.set_h_00((lhs.h_00() * rhs.h_00() + lhs.h_01() * rhs.h_10() +
@@ -1631,7 +1632,7 @@ MixtureModelAdapterBase<MixtureTraits>::LinearModel(
     }
 
     const double denom = sum_xx - inv_models * sum_x * sum_x;
-    CHECK_NE(denom, 0);  // As num_models > 1.
+    ABSL_CHECK_NE(denom, 0);  // As num_models > 1.
     const double a = (sum_xy - inv_models * sum_x * sum_y) * denom;
     const double b = inv_models * (sum_y - a * sum_x);
 
@@ -1688,7 +1689,7 @@ Vector2_f MixtureModelAdapter<MixtureTraits>::TransformPoint(
         BaseModelAdapter::TransformPoint3(model.model(i), pt3 * weights[i]);
   }
 
-  DCHECK_NE(result.z(), 0) << "Degenerate mapping.";
+  ABSL_DCHECK_NE(result.z(), 0) << "Degenerate mapping.";
   return Vector2_f(result.x() / result.z(), result.y() / result.z());
 }
 
@@ -1818,7 +1819,7 @@ inline Vector2_f MixtureModelAdapter<HomographyTraits>::TransformPoint(
       LOG(FATAL) << "Unknown type.";
   }
 
-  DCHECK_NE(result.z(), 0) << "Degenerate mapping.";
+  ABSL_DCHECK_NE(result.z(), 0) << "Degenerate mapping.";
   return Vector2_f(result.x() / result.z(), result.y() / result.z());
 }
 
diff --git a/third_party/mediapipe/src/mediapipe/util/tracking/motion_saliency.cc b/third_party/mediapipe/src/mediapipe/util/tracking/motion_saliency.cc
index 5adafca4c579f..9e2911e4a4d95 100644
--- a/third_party/mediapipe/src/mediapipe/util/tracking/motion_saliency.cc
+++ b/third_party/mediapipe/src/mediapipe/util/tracking/motion_saliency.cc
@@ -24,6 +24,7 @@
 #include <memory>
 #include <vector>
 
+#include "absl/log/absl_check.h"
 #include "mediapipe/framework/port/logging.h"
 #include "mediapipe/util/tracking/camera_motion.h"
 #include "mediapipe/util/tracking/measure_time.h"
@@ -45,11 +46,11 @@ void MotionSaliency::SaliencyFromFeatures(
     std::vector<float>* irls_weights,  // optional.
     SalientPointFrame* salient_frame) {
   CHECK(salient_frame);
-  CHECK_EQ(frame_width_, feature_list.frame_width());
-  CHECK_EQ(frame_height_, feature_list.frame_height());
+  ABSL_CHECK_EQ(frame_width_, feature_list.frame_width());
+  ABSL_CHECK_EQ(frame_height_, feature_list.frame_height());
 
   if (irls_weights) {
-    CHECK_EQ(feature_list.feature_size(), irls_weights->size());
+    ABSL_CHECK_EQ(feature_list.feature_size(), irls_weights->size());
   }
 
   if (feature_list.feature_size() < 1) {
@@ -106,7 +107,7 @@ void MotionSaliency::SaliencyFromPoints(const std::vector<Vector2_f>* points,
                                         SalientPointFrame* salient_frame) {
   // TODO: Handle vectors of size zero.
   CHECK(salient_frame);
-  CHECK_EQ(points->size(), weights->size());
+  ABSL_CHECK_EQ(points->size(), weights->size());
 
   float max_weight = *std::max_element(weights->begin(), weights->end());
 
@@ -477,7 +478,7 @@ void MotionSaliency::SalientModeFinding(std::vector<SalientLocation>* locations,
       nullptr, &grid_dims, &feature_grids);
 
   // Just one frame input, expect one grid as output.
-  CHECK_EQ(1, feature_grids.size());
+  ABSL_CHECK_EQ(1, feature_grids.size());
   const auto& feature_grid = feature_grids[0];
 
   // Setup Gaussian LUT for smoothing in space, using 2^10 discretization bins.
@@ -595,8 +596,8 @@ void MotionSaliency::SalientModeFinding(std::vector<SalientLocation>* locations,
         if (angle < 0) {
           angle += M_PI;
         }
-        CHECK_GE(angle, 0);
-        CHECK_LE(angle, M_PI + 1e-3);
+        ABSL_CHECK_GE(angle, 0);
+        ABSL_CHECK_LE(angle, M_PI + 1e-3);
       }
 
       SalientMode irls_mode;
@@ -665,7 +666,7 @@ void ForegroundWeightsFromFeatures(const RegionFlowFeatureList& feature_list,
 
   constexpr float kEpsilon = 1e-4f;
 
-  CHECK_GT(foreground_threshold, 0.0f);
+  ABSL_CHECK_GT(foreground_threshold, 0.0f);
   if (camera_motion) {
     foreground_threshold *=
         std::max(kEpsilon, InlierCoverage(*camera_motion, false));
@@ -694,7 +695,7 @@ void ForegroundWeightsFromFeatures(const RegionFlowFeatureList& feature_list,
           std::max(kEpsilon, std::pow(foreground_measure, foreground_gamma)));
     }
   }
-  CHECK_EQ(feature_list.feature_size(), weights->size());
+  ABSL_CHECK_EQ(feature_list.feature_size(), weights->size());
 }
 
 }  // namespace mediapipe
diff --git a/third_party/mediapipe/src/mediapipe/util/tracking/parallel_invoker.h b/third_party/mediapipe/src/mediapipe/util/tracking/parallel_invoker.h
index 823522310ba2f..734e99054cd57 100644
--- a/third_party/mediapipe/src/mediapipe/util/tracking/parallel_invoker.h
+++ b/third_party/mediapipe/src/mediapipe/util/tracking/parallel_invoker.h
@@ -71,6 +71,7 @@
 
 #include <memory>
 
+#include "absl/log/absl_check.h"
 #include "absl/synchronization/mutex.h"
 #include "mediapipe/framework/port/logging.h"
 
@@ -282,9 +283,10 @@ inline void CheckAndSetInvokerOptions() {
   }
 #endif  // PARALLEL_INVOKER_ACTIVE
 
-  CHECK_LT(flags_parallel_invoker_mode, PARALLEL_INVOKER_MAX_VALUE)
+  ABSL_CHECK_LT(flags_parallel_invoker_mode, PARALLEL_INVOKER_MAX_VALUE)
+      << "Invalid invoker mode specified.";
+  ABSL_CHECK_GE(flags_parallel_invoker_mode, 0)
       << "Invalid invoker mode specified.";
-  CHECK_GE(flags_parallel_invoker_mode, 0) << "Invalid invoker mode specified.";
 }
 
 // Performs parallel iteration from [start to end), scheduling grain_size
@@ -301,7 +303,7 @@ void ParallelFor(size_t start, size_t end, size_t grain_size,
 #if defined(__APPLE__)
     case PARALLEL_INVOKER_GCD: {
       int iterations_remain = (end - start + grain_size - 1) / grain_size;
-      CHECK_GT(iterations_remain, 0);
+      ABSL_CHECK_GT(iterations_remain, 0);
       if (iterations_remain == 1) {
         // Execute invoker serially.
         invoker(BlockedRange(start, std::min(end, start + grain_size), 1));
@@ -313,7 +315,7 @@ void ParallelFor(size_t start, size_t end, size_t grain_size,
         dispatch_apply_f(iterations_remain, concurrent_queue, &context,
                          ParallelForGCDTask<Invoker>);
 #if CHECK_GCD_PARALLEL_WORK_COUNT
-        CHECK_EQ(iterations_remain, context.count());
+        ABSL_CHECK_EQ(iterations_remain, context.count());
 #endif
       }
       break;
@@ -322,7 +324,7 @@ void ParallelFor(size_t start, size_t end, size_t grain_size,
 
     case PARALLEL_INVOKER_THREAD_POOL: {
       int iterations_remain = (end - start + grain_size - 1) / grain_size;
-      CHECK_GT(iterations_remain, 0);
+      ABSL_CHECK_GT(iterations_remain, 0);
       if (iterations_remain == 1) {
         // Execute invoker serially.
         invoker(BlockedRange(start, std::min(end, start + grain_size), 1));
@@ -413,7 +415,7 @@ void ParallelFor2D(size_t start_row, size_t end_row, size_t start_col,
     case PARALLEL_INVOKER_GCD: {
       const int iterations_remain =
           (end_row - start_row + grain_size - 1) / grain_size;
-      CHECK_GT(iterations_remain, 0);
+      ABSL_CHECK_GT(iterations_remain, 0);
       if (iterations_remain == 1) {
         // Execute invoker serially.
         invoker(BlockedRange2D(BlockedRange(start_row, end_row, 1),
@@ -427,7 +429,7 @@ void ParallelFor2D(size_t start_row, size_t end_row, size_t start_col,
         dispatch_apply_f(iterations_remain, concurrent_queue, &context,
                          ParallelForGCDTask2D<Invoker>);
 #if CHECK_GCD_PARALLEL_WORK_COUNT
-        CHECK_EQ(iterations_remain, context.count());
+        ABSL_CHECK_EQ(iterations_remain, context.count());
 #endif
       }
       break;
@@ -436,7 +438,7 @@ void ParallelFor2D(size_t start_row, size_t end_row, size_t start_col,
 
     case PARALLEL_INVOKER_THREAD_POOL: {
       int iterations_remain = end_row - start_row;  // Guarded by loop_mutex
-      CHECK_GT(iterations_remain, 0);
+      ABSL_CHECK_GT(iterations_remain, 0);
       if (iterations_remain == 1) {
         // Execute invoker serially.
         invoker(BlockedRange2D(BlockedRange(start_row, end_row, 1),
diff --git a/third_party/mediapipe/src/mediapipe/util/tracking/push_pull_filtering.h b/third_party/mediapipe/src/mediapipe/util/tracking/push_pull_filtering.h
index f9b2c6c3cc077..cdf451f5bbbf5 100644
--- a/third_party/mediapipe/src/mediapipe/util/tracking/push_pull_filtering.h
+++ b/third_party/mediapipe/src/mediapipe/util/tracking/push_pull_filtering.h
@@ -33,6 +33,7 @@
 #include <string>
 #include <vector>
 
+#include "absl/log/absl_check.h"
 #include "mediapipe/framework/port/opencv_core_inc.h"
 #include "mediapipe/util/tracking/image_util.h"
 #include "mediapipe/util/tracking/push_pull_filtering.pb.h"
@@ -148,7 +149,7 @@ class PushPullFiltering {
   // Returns domain size of n-th pyramid level (including border depending on
   // filter_type).
   cv::Size NthPyramidDomain(int level) {
-    CHECK_LT(level, PyramidLevels());
+    ABSL_CHECK_LT(level, PyramidLevels());
     return downsample_pyramid_[level].size();
   }
 
@@ -469,14 +470,14 @@ template <int C, class FilterWeightMultiplier>
 void PushPullFiltering<C, FilterWeightMultiplier>::InitializeImagePyramid(
     const cv::Mat& input_frame, std::vector<cv::Mat>* pyramid) {
   CHECK(pyramid != nullptr);
-  CHECK_GT(pyramid->size(), 0);
+  ABSL_CHECK_GT(pyramid->size(), 0);
 
   cv::Mat base_level((*pyramid)[0],
                      cv::Range(border_, (*pyramid)[0].rows - border_),
                      cv::Range(border_, (*pyramid)[0].cols - border_));
-  CHECK_EQ(base_level.rows, input_frame.rows);
-  CHECK_EQ(base_level.cols, input_frame.cols);
-  CHECK_EQ(base_level.type(), input_frame.type());
+  ABSL_CHECK_EQ(base_level.rows, input_frame.rows);
+  ABSL_CHECK_EQ(base_level.cols, input_frame.cols);
+  ABSL_CHECK_EQ(base_level.type(), input_frame.type());
 
   input_frame.copyTo(base_level);
   CopyNecessaryBorder<uint8, 3>(&(*pyramid)[0]);
@@ -743,11 +744,11 @@ void PushPullFiltering<C, FilterWeightMultiplier>::PerformPushPull(
     cv::Point2i origin, int readout_level,
     const std::vector<float>* data_weights, const cv::Mat* input_frame,
     cv::Mat* results) {
-  CHECK_EQ(data_locations.size(), data_values.size());
+  ABSL_CHECK_EQ(data_locations.size(), data_values.size());
   CHECK(results != nullptr);
 
   if (data_weights) {
-    CHECK_EQ(data_weights->size(), data_locations.size());
+    ABSL_CHECK_EQ(data_weights->size(), data_locations.size());
   }
 
   origin.x += border_;
@@ -760,13 +761,13 @@ void PushPullFiltering<C, FilterWeightMultiplier>::PerformPushPull(
     mip_map[i] = &downsample_pyramid_[i];
   }
 
-  CHECK_GE(readout_level, 0);
-  CHECK_LT(readout_level, PyramidLevels());
+  ABSL_CHECK_GE(readout_level, 0);
+  ABSL_CHECK_LT(readout_level, PyramidLevels());
 
   // CHECK if passed results matrix is compatible w.r.t. type and domain.
-  CHECK_EQ(downsample_pyramid_[readout_level].cols, results->cols);
-  CHECK_EQ(downsample_pyramid_[readout_level].rows, results->rows);
-  CHECK_EQ(downsample_pyramid_[readout_level].type(), results->type());
+  ABSL_CHECK_EQ(downsample_pyramid_[readout_level].cols, results->cols);
+  ABSL_CHECK_EQ(downsample_pyramid_[readout_level].rows, results->rows);
+  ABSL_CHECK_EQ(downsample_pyramid_[readout_level].type(), results->type());
 
   // Use caller-allocated results Mat.
   mip_map[readout_level] = results;
@@ -815,18 +816,18 @@ void PushPullFiltering<C, FilterWeightMultiplier>::PerformPushPullMat(
     mip_map[i] = &downsample_pyramid_[i];
   }
 
-  CHECK_GE(readout_level, 0);
-  CHECK_LT(readout_level, PyramidLevels());
+  ABSL_CHECK_GE(readout_level, 0);
+  ABSL_CHECK_LT(readout_level, PyramidLevels());
 
   // CHECK if passed mip_map at level[0] is compatible w.r.t. type and domain.
-  CHECK_EQ(mip_map_level_0.cols, results->cols);
-  CHECK_EQ(mip_map_level_0.rows, results->rows);
-  CHECK_EQ(mip_map_level_0.type(), results->type());
+  ABSL_CHECK_EQ(mip_map_level_0.cols, results->cols);
+  ABSL_CHECK_EQ(mip_map_level_0.rows, results->rows);
+  ABSL_CHECK_EQ(mip_map_level_0.type(), results->type());
 
   // CHECK if passed results matrix is compatible w.r.t. type and domain.
-  CHECK_EQ(downsample_pyramid_[readout_level].cols, results->cols);
-  CHECK_EQ(downsample_pyramid_[readout_level].rows, results->rows);
-  CHECK_EQ(downsample_pyramid_[readout_level].type(), results->type());
+  ABSL_CHECK_EQ(downsample_pyramid_[readout_level].cols, results->cols);
+  ABSL_CHECK_EQ(downsample_pyramid_[readout_level].rows, results->rows);
+  ABSL_CHECK_EQ(downsample_pyramid_[readout_level].type(), results->type());
 
   // Use caller-allocated results Mat.
   mip_map[readout_level] = results;
@@ -1049,7 +1050,7 @@ void PushPullFiltering<C, FilterWeightMultiplier>::PullDownSampling(
           }
         }
 
-        DCHECK_GE(weight_sum, 0);
+        ABSL_DCHECK_GE(weight_sum, 0);
 
         if (weight_sum >= kBilateralEps * kBilateralEps) {
           const float inv_weight_sum = 1.f / weight_sum;
diff --git a/third_party/mediapipe/src/mediapipe/util/tracking/region_flow.cc b/third_party/mediapipe/src/mediapipe/util/tracking/region_flow.cc
index cdd6bcd88d0dc..1babddde897f9 100644
--- a/third_party/mediapipe/src/mediapipe/util/tracking/region_flow.cc
+++ b/third_party/mediapipe/src/mediapipe/util/tracking/region_flow.cc
@@ -22,6 +22,7 @@
 
 #include "absl/container/node_hash_map.h"
 #include "absl/container/node_hash_set.h"
+#include "absl/log/absl_check.h"
 #include "absl/strings/str_cat.h"
 #include "mediapipe/framework/port/integral_types.h"
 #include "mediapipe/util/tracking/measure_time.h"
@@ -76,8 +77,8 @@ void GetRegionFlowFeatureList(const RegionFlowFrame& region_flow_frame,
 
 float RegionFlowFeatureDistance(const PatchDescriptor& patch_desc_1,
                                 const PatchDescriptor& patch_desc_2) {
-  DCHECK_EQ(patch_desc_1.data_size(), patch_desc_2.data_size());
-  DCHECK_GE(patch_desc_1.data_size(), 3);
+  ABSL_DCHECK_EQ(patch_desc_1.data_size(), patch_desc_2.data_size());
+  ABSL_DCHECK_GE(patch_desc_1.data_size(), 3);
 
   constexpr int kNumMeans = 3;
   float sq_distance_sum = 0;
@@ -212,7 +213,7 @@ void GetRegionFlowFeatureIRLSWeights(
 void SetRegionFlowFeatureIRLSWeights(const std::vector<float>& irls_weights,
                                      RegionFlowFeatureList* flow_feature_list) {
   CHECK(flow_feature_list != nullptr);
-  CHECK_EQ(irls_weights.size(), flow_feature_list->feature_size());
+  ABSL_CHECK_EQ(irls_weights.size(), flow_feature_list->feature_size());
   int idx = 0;
   for (auto feature = flow_feature_list->mutable_feature()->begin();
        feature != flow_feature_list->mutable_feature()->end();
@@ -515,7 +516,7 @@ void CopyToEmptyFeatureList(RegionFlowFeatureList* src,
   src->mutable_feature()->Swap(empty_list.mutable_feature());
 
   // src_features should be empty as in the beginning.
-  CHECK_EQ(0, empty_list.feature_size());
+  ABSL_CHECK_EQ(0, empty_list.feature_size());
 }
 
 void IntersectRegionFlowFeatureList(
@@ -607,10 +608,10 @@ void LongFeatureStream::AddFeatures(const RegionFlowFeatureList& feature_list,
     if (find_pos != tracks_.end()) {
       // Track is present, add to it.
       if (check_connectivity) {
-        CHECK_LT((FeatureLocation(find_pos->second.back()) -
-                  FeatureMatchLocation(feature))
-                     .Norm2(),
-                 1e-4);
+        ABSL_CHECK_LT((FeatureLocation(find_pos->second.back()) -
+                       FeatureMatchLocation(feature))
+                          .Norm2(),
+                      1e-4);
       }
       find_pos->second.push_back(feature);
     } else {
diff --git a/third_party/mediapipe/src/mediapipe/util/tracking/region_flow.h b/third_party/mediapipe/src/mediapipe/util/tracking/region_flow.h
index 2f9b34227629c..db70a2b8ec71e 100644
--- a/third_party/mediapipe/src/mediapipe/util/tracking/region_flow.h
+++ b/third_party/mediapipe/src/mediapipe/util/tracking/region_flow.h
@@ -24,6 +24,7 @@
 #include <utility>
 #include <vector>
 
+#include "absl/log/absl_check.h"
 #include "mediapipe/framework/port/logging.h"
 #include "mediapipe/framework/port/vector.h"
 #include "mediapipe/util/tracking/motion_models.h"
@@ -82,9 +83,9 @@ inline float PatchDescriptorColorStdevL1(const PatchDescriptor& descriptor) {
   constexpr int kRedIdx = 3;
   constexpr int kGreenIdx = 6;
   constexpr int kBlueIdx = 8;
-  DCHECK_GE(descriptor.data(kRedIdx), 0);
-  DCHECK_GE(descriptor.data(kGreenIdx), 0);
-  DCHECK_GE(descriptor.data(kBlueIdx), 0);
+  ABSL_DCHECK_GE(descriptor.data(kRedIdx), 0);
+  ABSL_DCHECK_GE(descriptor.data(kGreenIdx), 0);
+  ABSL_DCHECK_GE(descriptor.data(kBlueIdx), 0);
 
   if (descriptor.data_size() > kBlueIdx) {
     return std::sqrt(descriptor.data(kRedIdx)) +
@@ -591,7 +592,7 @@ void BuildFeatureGrid(
     Vector2_i* num_grid_bins,                       // Optional.
     std::vector<FeatureGrid<Feature>>* feature_grids) {
   CHECK(feature_grids);
-  CHECK_GT(grid_resolution, 0.0f);
+  ABSL_CHECK_GT(grid_resolution, 0.0f);
 
   const int num_frames = feature_views.size();
   const int grid_dim_x = std::ceil(frame_width / grid_resolution);
@@ -612,8 +613,8 @@ void BuildFeatureGrid(
       Vector2_f feature_loc = evaluator(*feature);
       const int x = feature_loc.x() * grid_scale;
       const int y = feature_loc.y() * grid_scale;
-      DCHECK_LT(y, grid_dim_y);
-      DCHECK_LT(x, grid_dim_x);
+      ABSL_DCHECK_LT(y, grid_dim_y);
+      ABSL_DCHECK_LT(x, grid_dim_x);
       const int grid_loc = y * grid_dim_x + x;
       curr_grid[grid_loc].push_back(feature);
     }
diff --git a/third_party/mediapipe/src/mediapipe/util/tracking/region_flow_computation.cc b/third_party/mediapipe/src/mediapipe/util/tracking/region_flow_computation.cc
index b6704cc61fd28..2446e726ee89d 100644
--- a/third_party/mediapipe/src/mediapipe/util/tracking/region_flow_computation.cc
+++ b/third_party/mediapipe/src/mediapipe/util/tracking/region_flow_computation.cc
@@ -28,6 +28,7 @@
 #include "Eigen/Core"
 #include "absl/container/flat_hash_map.h"
 #include "absl/container/node_hash_set.h"
+#include "absl/log/absl_check.h"
 #include "absl/memory/memory.h"
 #include "mediapipe/framework/port/logging.h"
 #include "mediapipe/framework/port/opencv_core_inc.h"
@@ -207,19 +208,19 @@ class PatchDescriptorInvoker {
          ++feature_idx) {
       RegionFlowFeature* feature = features_->mutable_feature(feature_idx);
       Vector2_i pt(FeatureIntLocation(*feature));
-      DCHECK_GE(pt.x(), radius_);
-      DCHECK_GE(pt.y(), radius_);
-      DCHECK_LT(pt.x(), rgb_frame_.cols - radius_);
-      DCHECK_LT(pt.y(), rgb_frame_.rows - radius_);
+      ABSL_DCHECK_GE(pt.x(), radius_);
+      ABSL_DCHECK_GE(pt.y(), radius_);
+      ABSL_DCHECK_LT(pt.x(), rgb_frame_.cols - radius_);
+      ABSL_DCHECK_LT(pt.y(), rgb_frame_.rows - radius_);
       GetPatchDescriptorAtPoint(rgb_frame_, pt, radius_, &lab_window,
                                 feature->mutable_feature_descriptor());
 
       if (prev_rgb_frame_) {
         Vector2_i pt_match(FeatureMatchIntLocation(*feature));
-        DCHECK_GE(pt_match.x(), radius_);
-        DCHECK_GE(pt_match.y(), radius_);
-        DCHECK_LT(pt_match.x(), rgb_frame_.cols - radius_);
-        DCHECK_LT(pt_match.y(), rgb_frame_.rows - radius_);
+        ABSL_DCHECK_GE(pt_match.x(), radius_);
+        ABSL_DCHECK_GE(pt_match.y(), radius_);
+        ABSL_DCHECK_LT(pt_match.x(), rgb_frame_.cols - radius_);
+        ABSL_DCHECK_LT(pt_match.y(), rgb_frame_.rows - radius_);
         GetPatchDescriptorAtPoint(*prev_rgb_frame_, pt_match, radius_,
                                   &lab_window,
                                   feature->mutable_feature_match_descriptor());
@@ -247,17 +248,18 @@ void ComputeRegionFlowFeatureDescriptors(
     int patch_descriptor_radius, RegionFlowFeatureList* flow_feature_list) {
   const int rows = rgb_frame.rows;
   const int cols = rgb_frame.cols;
-  CHECK_EQ(rgb_frame.depth(), CV_8U);
-  CHECK_EQ(rgb_frame.channels(), 3);
+  ABSL_CHECK_EQ(rgb_frame.depth(), CV_8U);
+  ABSL_CHECK_EQ(rgb_frame.channels(), 3);
 
   if (prev_rgb_frame) {
-    CHECK_EQ(prev_rgb_frame->depth(), CV_8U);
-    CHECK_EQ(prev_rgb_frame->channels(), 3);
-    CHECK_EQ(prev_rgb_frame->rows, rows);
-    CHECK_EQ(prev_rgb_frame->cols, cols);
+    ABSL_CHECK_EQ(prev_rgb_frame->depth(), CV_8U);
+    ABSL_CHECK_EQ(prev_rgb_frame->channels(), 3);
+    ABSL_CHECK_EQ(prev_rgb_frame->rows, rows);
+    ABSL_CHECK_EQ(prev_rgb_frame->cols, cols);
   }
 
-  CHECK_LE(patch_descriptor_radius, flow_feature_list->distance_from_border());
+  ABSL_CHECK_LE(patch_descriptor_radius,
+                flow_feature_list->distance_from_border());
 
   ParallelFor(
       0, flow_feature_list->feature_size(), 1,
@@ -380,7 +382,7 @@ struct RegionFlowComputation::FrameTrackingData {
       iwidth = (iwidth + 1) / 2;
       iheight = (iheight + 1) / 2;
     }
-    CHECK_GE(extraction_levels, 1);
+    ABSL_CHECK_GE(extraction_levels, 1);
     // Frame is the same as first extraction level.
     frame = extraction_pyramid[0];
 
@@ -458,7 +460,7 @@ struct RegionFlowComputation::FrameTrackingData {
   }
 
   void RemoveFeature(int pos) {
-    DCHECK_LT(pos, features.size());
+    ABSL_DCHECK_LT(pos, features.size());
     features.erase(features.begin() + pos);
     feature_source_map.erase(feature_source_map.begin() + pos);
     corner_responses.erase(corner_responses.begin() + pos);
@@ -616,8 +618,8 @@ RegionFlowComputation::RegionFlowComputation(
     }
   }
 
-  CHECK_NE(options.tracking_options().output_flow_direction(),
-           TrackingOptions::CONSECUTIVELY)
+  ABSL_CHECK_NE(options.tracking_options().output_flow_direction(),
+                TrackingOptions::CONSECUTIVELY)
       << "Output direction must be either set to FORWARD or BACKWARD.";
   use_downsampling_ = options_.downsample_mode() !=
                       RegionFlowComputationOptions::DOWNSAMPLE_NONE;
@@ -650,7 +652,7 @@ RegionFlowComputation::RegionFlowComputation(
     }
     case RegionFlowComputationOptions::DOWNSAMPLE_BY_FACTOR:
     case RegionFlowComputationOptions::DOWNSAMPLE_TO_INPUT_SIZE: {
-      CHECK_GE(options_.downsample_factor(), 1);
+      ABSL_CHECK_GE(options_.downsample_factor(), 1);
       downsample_scale_ = options_.downsample_factor();
       break;
     }
@@ -728,7 +730,7 @@ RegionFlowComputation::RegionFlowComputation(
       frames_to_track_ = 1;
       break;
     case TrackingOptions::POLICY_MULTI_FRAME:
-      CHECK_GT(options_.tracking_options().multi_frames_to_track(), 0);
+      ABSL_CHECK_GT(options_.tracking_options().multi_frames_to_track(), 0);
       frames_to_track_ = options_.tracking_options().multi_frames_to_track();
       break;
     case TrackingOptions::POLICY_LONG_TRACKS:
@@ -808,7 +810,7 @@ RegionFlowComputation::RegionFlowComputation(
 
   // Compute settings for block based flow.
   const float block_size = options_.fast_estimation_block_size();
-  CHECK_GT(block_size, 0) << "Need positive block size";
+  ABSL_CHECK_GT(block_size, 0) << "Need positive block size";
 
   block_width_ = block_size < 1 ? block_size * original_width_ : block_size;
   block_height_ = block_size < 1 ? block_size * original_height_ : block_size;
@@ -869,7 +871,7 @@ RegionFlowComputation::RetrieveRegionFlowFeatureListImpl(
     int track_index, bool compute_feature_descriptor,
     bool compute_match_descriptor, const cv::Mat* curr_color_image,
     const cv::Mat* prev_color_image) {
-  CHECK_GT(region_flow_results_.size(), track_index);
+  ABSL_CHECK_GT(region_flow_results_.size(), track_index);
   CHECK(region_flow_results_[track_index].get());
 
   std::unique_ptr<RegionFlowFeatureList> feature_list(
@@ -877,10 +879,10 @@ RegionFlowComputation::RetrieveRegionFlowFeatureListImpl(
 
   if (compute_feature_descriptor) {
     CHECK(curr_color_image != nullptr);
-    CHECK_EQ(3, curr_color_image->channels());
+    ABSL_CHECK_EQ(3, curr_color_image->channels());
     if (compute_match_descriptor) {
       CHECK(prev_color_image != nullptr);
-      CHECK_EQ(3, prev_color_image->channels());
+      ABSL_CHECK_EQ(3, prev_color_image->channels());
     }
 
     ComputeRegionFlowFeatureDescriptors(
@@ -1006,7 +1008,7 @@ bool RegionFlowComputation::InitFrame(const cv::Mat& source,
         LOG(ERROR) << "Expecting 1 channel input for GRAYSCALE.";
         return false;
       }
-      CHECK_EQ(1, source_ptr->channels());
+      ABSL_CHECK_EQ(1, source_ptr->channels());
       if (source_ptr != &dest_frame) {
         source_ptr->copyTo(dest_frame);
       }
@@ -1024,8 +1026,8 @@ bool RegionFlowComputation::InitFrame(const cv::Mat& source,
   }
 
   // Consistency checks; not input governed.
-  CHECK_EQ(dest_frame.cols, frame_width_);
-  CHECK_EQ(dest_frame.rows, frame_height_);
+  ABSL_CHECK_EQ(dest_frame.cols, frame_width_);
+  ABSL_CHECK_EQ(dest_frame.rows, frame_height_);
 
   data->BuildPyramid(pyramid_levels_,
                      options_.tracking_options().tracking_window_size(),
@@ -1089,8 +1091,8 @@ bool RegionFlowComputation::AddImageAndTrack(
   curr_data->Reset(frame_num_, timestamp_usec);
 
   if (!IsModelIdentity(initial_transform)) {
-    CHECK_EQ(1, frames_to_track_) << "Initial transform is not supported "
-                                  << "for multi frame tracking";
+    ABSL_CHECK_EQ(1, frames_to_track_) << "Initial transform is not supported "
+                                       << "for multi frame tracking";
     Homography transform = initial_transform;
     if (downsample_scale_ != 1) {
       const float scale = 1.0f / downsample_scale_;
@@ -1204,7 +1206,7 @@ bool RegionFlowComputation::AddImageAndTrack(
 }
 
 cv::Mat RegionFlowComputation::GetGrayscaleFrameFromResults() {
-  CHECK_GT(data_queue_.size(), 0) << "Empty queue, was AddImage* called?";
+  ABSL_CHECK_GT(data_queue_.size(), 0) << "Empty queue, was AddImage* called?";
   FrameTrackingData* curr_data = data_queue_.back().get();
   CHECK(curr_data);
   return curr_data->frame;
@@ -1228,9 +1230,9 @@ void RegionFlowComputation::GetFeatureTrackInliers(
 
 float RegionFlowComputation::ComputeVisualConsistency(
     FrameTrackingData* previous, FrameTrackingData* current) const {
-  CHECK_EQ(previous->frame_num + 1, current->frame_num);
+  ABSL_CHECK_EQ(previous->frame_num + 1, current->frame_num);
   const int total = previous->tiny_image.total();
-  CHECK_GT(total, 0) << "Tiny image dimension set to zero.";
+  ABSL_CHECK_GT(total, 0) << "Tiny image dimension set to zero.";
   current->tiny_image_diff =
       FrameDifferenceMedian(previous->tiny_image, current->tiny_image) *
       (1.0f / total);
@@ -1263,10 +1265,10 @@ void RegionFlowComputation::ComputeRegionFlow(
   } else {
     const int index1 = data_queue_.size() + from - 1;
     const int index2 = data_queue_.size() + to - 1;
-    CHECK_GE(index1, 0);
-    CHECK_LT(index1, data_queue_.size());
-    CHECK_GE(index2, 0);
-    CHECK_LT(index2, data_queue_.size());
+    ABSL_CHECK_GE(index1, 0);
+    ABSL_CHECK_LT(index1, data_queue_.size());
+    ABSL_CHECK_GE(index2, 0);
+    ABSL_CHECK_LT(index2, data_queue_.size());
     data1 = data_queue_[index1].get();
     data2 = data_queue_[index2].get();
 
@@ -1611,14 +1613,14 @@ class GridFeatureLocator {
 // or adds K to the existing mask if add is set to true.
 template <int N, int K, bool add>
 inline void SetMaskNeighborhood(int mask_x, int mask_y, cv::Mat* mask) {
-  DCHECK_EQ(mask->type(), CV_8U);
+  ABSL_DCHECK_EQ(mask->type(), CV_8U);
   const int mask_start_x = max(0, mask_x - N);
   const int mask_end_x = min(mask->cols - 1, mask_x + N);
   const int mask_dx = mask_end_x - mask_start_x + 1;
   const int mask_start_y = max(0, mask_y - N);
   const int mask_end_y = min(mask->rows - 1, mask_y + N);
-  DCHECK_LE(mask_start_x, mask_end_x);
-  DCHECK_LE(mask_start_y, mask_end_y);
+  ABSL_DCHECK_LE(mask_start_x, mask_end_x);
+  ABSL_DCHECK_LE(mask_start_y, mask_end_y);
 
   if (!add) {
     for (int i = mask_start_y; i <= mask_end_y; ++i) {
@@ -1651,7 +1653,7 @@ void RegionFlowComputation::AdaptiveGoodFeaturesToTrack(
 
   // Setup grid information.
   const float block_size = tracking_options.adaptive_features_block_size();
-  CHECK_GT(block_size, 0) << "Need positive block size";
+  ABSL_CHECK_GT(block_size, 0) << "Need positive block size";
 
   int block_width = block_size < 1 ? block_size * frame_width_ : block_size;
   int block_height = block_size < 1 ? block_size * frame_height_ : block_size;
@@ -1703,8 +1705,8 @@ void RegionFlowComputation::AdaptiveGoodFeaturesToTrack(
     std::vector<cv::KeyPoint> fast_keypoints;
     if (e == 0) {
       MEASURE_TIME << "Corner extraction";
-      CHECK_EQ(rows, frame_height_);
-      CHECK_EQ(cols, frame_width_);
+      ABSL_CHECK_EQ(rows, frame_height_);
+      ABSL_CHECK_EQ(cols, frame_width_);
 
       if (use_fast) {
         fast_detector->detect(image, fast_keypoints);
@@ -1716,8 +1718,8 @@ void RegionFlowComputation::AdaptiveGoodFeaturesToTrack(
     } else {
       // Compute corner response on a down-scaled image and upsample.
       step *= 2;
-      CHECK_EQ(rows, (extraction_pyramid[e - 1].rows + 1) / 2);
-      CHECK_EQ(cols, (extraction_pyramid[e - 1].cols + 1) / 2);
+      ABSL_CHECK_EQ(rows, (extraction_pyramid[e - 1].rows + 1) / 2);
+      ABSL_CHECK_EQ(cols, (extraction_pyramid[e - 1].cols + 1) / 2);
 
       if (use_fast) {
         fast_detector->detect(image, fast_keypoints);
@@ -2015,8 +2017,8 @@ bool RegionFlowComputation::GainCorrectFrame(const cv::Mat& reference_frame,
                                              float input_mean,
                                              cv::Mat* calibrated_frame) const {
   CHECK(calibrated_frame);
-  CHECK_EQ(reference_frame.rows, input_frame.rows);
-  CHECK_EQ(reference_frame.cols, input_frame.cols);
+  ABSL_CHECK_EQ(reference_frame.rows, input_frame.rows);
+  ABSL_CHECK_EQ(reference_frame.cols, input_frame.cols);
 
   // Do not attempt gain correction for tiny images.
   if (std::min(reference_frame.rows, reference_frame.cols) < 10) {
@@ -2185,7 +2187,7 @@ void RegionFlowComputation::RemoveAbsentFeatures(
   // Build hash set of track ids.
   absl::node_hash_set<int> track_ids;
   for (const auto& feature : prev_result) {
-    DCHECK_NE(feature.track_id, -1);
+    ABSL_DCHECK_NE(feature.track_id, -1);
     track_ids.insert(feature.track_id);
   }
 
@@ -2233,8 +2235,8 @@ void RegionFlowComputation::ExtractFeatures(
 
     if (data->last_feature_extraction_time == 0) {
       // Features already extracted from this frame.
-      CHECK_EQ(data->corner_responses.size(), data->features.size());
-      CHECK_EQ(data->octaves.size(), data->features.size());
+      ABSL_CHECK_EQ(data->corner_responses.size(), data->features.size());
+      ABSL_CHECK_EQ(data->octaves.size(), data->features.size());
       VLOG(1) << "Features already present (extracted from this frame)";
       return;
     }
@@ -2242,8 +2244,8 @@ void RegionFlowComputation::ExtractFeatures(
     // Remove features that lie outside feature extraction mask.
     RemoveFeaturesOutsideMask(data);
 
-    CHECK_EQ(data->corner_responses.size(), data->features.size());
-    CHECK_EQ(data->octaves.size(), data->features.size());
+    ABSL_CHECK_EQ(data->corner_responses.size(), data->features.size());
+    ABSL_CHECK_EQ(data->octaves.size(), data->features.size());
 
     float feature_fraction = 0;
     if (data->num_original_extracted_and_tracked > 0) {
@@ -2309,7 +2311,7 @@ void RegionFlowComputation::ExtractFeatures(
     data->neighborhoods->reserve(features_to_allocate);
   }
 
-  CHECK_EQ(data->extraction_pyramid.size(), extraction_levels_);
+  ABSL_CHECK_EQ(data->extraction_pyramid.size(), extraction_levels_);
   for (int i = 1; i < extraction_levels_; ++i) {
     // Need factor 2 as OpenCV stores image + gradient pairs when
     // "with_derivative" is set to true.
@@ -2357,8 +2359,8 @@ void RegionFlowComputation::ExtractFeatures(
     // For FORWARD output flow, we need to add flow to obtain the match
     // position, for BACKWARD output flow, flow is inverted, so that feature
     // locations already point to locations in the current frame.
-    CHECK_EQ(options_.tracking_options().internal_tracking_direction(),
-             TrackingOptions::FORWARD);
+    ABSL_CHECK_EQ(options_.tracking_options().internal_tracking_direction(),
+                  TrackingOptions::FORWARD);
     float match_sign = options_.tracking_options().output_flow_direction() ==
                                TrackingOptions::FORWARD
                            ? 1.0f
@@ -2426,9 +2428,9 @@ void RegionFlowComputation::ExtractFeatures(
                               mask_scale, &mask, data);
 
   const int num_features = data->features.size();
-  CHECK_EQ(num_features, data->octaves.size());
-  CHECK_EQ(num_features, data->corner_responses.size());
-  CHECK_EQ(num_features, data->track_ids.size());
+  ABSL_CHECK_EQ(num_features, data->octaves.size());
+  ABSL_CHECK_EQ(num_features, data->corner_responses.size());
+  ABSL_CHECK_EQ(num_features, data->track_ids.size());
 }
 
 // Selects features based on lambda evaluator: bool (int index)
@@ -2439,23 +2441,23 @@ int RegionFlowComputation::InplaceFeatureSelection(
     std::vector<std::vector<float>*> float_vecs, const Eval& eval) {
   int num_selected_features = 0;
   const int num_features = data->features.size();
-  DCHECK_EQ(num_features, data->corner_responses.size());
-  DCHECK_EQ(num_features, data->octaves.size());
-  DCHECK_EQ(num_features, data->track_ids.size());
-  DCHECK_EQ(num_features, data->feature_source_map.size());
+  ABSL_DCHECK_EQ(num_features, data->corner_responses.size());
+  ABSL_DCHECK_EQ(num_features, data->octaves.size());
+  ABSL_DCHECK_EQ(num_features, data->track_ids.size());
+  ABSL_DCHECK_EQ(num_features, data->feature_source_map.size());
   if (data->neighborhoods != nullptr) {
-    DCHECK_EQ(num_features, data->neighborhoods->size());
+    ABSL_DCHECK_EQ(num_features, data->neighborhoods->size());
   }
 
   for (const auto vec_ptr : int_vecs) {
-    DCHECK_EQ(num_features, vec_ptr->size());
+    ABSL_DCHECK_EQ(num_features, vec_ptr->size());
   }
   for (const auto vec_ptr : float_vecs) {
-    DCHECK_EQ(num_features, vec_ptr->size());
+    ABSL_DCHECK_EQ(num_features, vec_ptr->size());
   }
 
   for (int i = 0; i < num_features; ++i) {
-    DCHECK_LE(num_selected_features, i);
+    ABSL_DCHECK_LE(num_selected_features, i);
     if (eval(i)) {
       data->features[num_selected_features] = data->features[i];
       data->corner_responses[num_selected_features] = data->corner_responses[i];
@@ -2549,14 +2551,14 @@ void RegionFlowComputation::TrackFeatures(FrameTrackingData* from_data_ptr,
     octaves2.resize(num_features);
     data2.source = from_data_ptr;
   } else {
-    CHECK_EQ(data2.source, from_data_ptr);
-    CHECK_EQ(num_features, features2.size());
+    ABSL_CHECK_EQ(data2.source, from_data_ptr);
+    ABSL_CHECK_EQ(num_features, features2.size());
     tracking_flags |= cv::OPTFLOW_USE_INITIAL_FLOW;
   }
 
   const int track_win_size = options_.tracking_options().tracking_window_size();
-  CHECK_GT(track_win_size, 1) << "Needs to be at least 2 pixels in each "
-                              << "direction";
+  ABSL_CHECK_GT(track_win_size, 1) << "Needs to be at least 2 pixels in each "
+                                   << "direction";
 
   // Proceed with gain correction only if it succeeds, and set flag accordingly.
   bool frame1_gain_reference = true;
@@ -2946,14 +2948,14 @@ void RegionFlowComputation::InitializeFeatureLocationsFromTransform(
 
 void RegionFlowComputation::InitializeFeatureLocationsFromPreviousResult(
     int from, int to) {
-  CHECK_NE(from, to) << "Cannot initialize FrameTrackingData from itself.";
+  ABSL_CHECK_NE(from, to) << "Cannot initialize FrameTrackingData from itself.";
 
   const int index1 = data_queue_.size() + from - 1;
   const int index2 = data_queue_.size() + to - 1;
-  CHECK_GE(index1, 0);
-  CHECK_LT(index1, data_queue_.size());
-  CHECK_GE(index2, 0);
-  CHECK_LT(index2, data_queue_.size());
+  ABSL_CHECK_GE(index1, 0);
+  ABSL_CHECK_LT(index1, data_queue_.size());
+  ABSL_CHECK_GE(index2, 0);
+  ABSL_CHECK_LT(index2, data_queue_.size());
   const FrameTrackingData& data1 = *data_queue_[index1];
   FrameTrackingData* data2 = data_queue_[index2].get();
   CHECK(data1.source != nullptr);
@@ -2965,7 +2967,7 @@ void RegionFlowComputation::InitializeFeatureLocationsFromPreviousResult(
     }
   } else {
     data2->features = data1.features;
-    CHECK_EQ(data1.features.size(), data1.source->features.size());
+    ABSL_CHECK_EQ(data1.features.size(), data1.source->features.size());
   }
   data2->source = data1.source;
   data2->features_initialized = true;
diff --git a/third_party/mediapipe/src/mediapipe/util/tracking/region_flow_visualization.cc b/third_party/mediapipe/src/mediapipe/util/tracking/region_flow_visualization.cc
index dc067da7c9a34..841ce5e0dc54c 100644
--- a/third_party/mediapipe/src/mediapipe/util/tracking/region_flow_visualization.cc
+++ b/third_party/mediapipe/src/mediapipe/util/tracking/region_flow_visualization.cc
@@ -19,6 +19,7 @@
 #include <memory>
 #include <numeric>
 
+#include "absl/log/absl_check.h"
 #include "absl/strings/str_cat.h"
 #include "mediapipe/framework/port/integral_types.h"
 #include "mediapipe/util/tracking/measure_time.h"
@@ -138,7 +139,7 @@ void VisualizeLongFeatureStreamImpl(const LongFeatureStream& stream,
     if (min_track_length > 0 && pts.size() < min_track_length) {
       continue;
     }
-    CHECK_GT(pts.size(), 1);  // Should have at least two points per track.
+    ABSL_CHECK_GT(pts.size(), 1);  // Should have at least two points per track.
 
     // Tracks are ordered with oldest point first, most recent one last.
     const int start_k =
diff --git a/third_party/mediapipe/src/mediapipe/util/tracking/streaming_buffer.cc b/third_party/mediapipe/src/mediapipe/util/tracking/streaming_buffer.cc
index 2e5b0ac2f034e..286edbb8e5055 100644
--- a/third_party/mediapipe/src/mediapipe/util/tracking/streaming_buffer.cc
+++ b/third_party/mediapipe/src/mediapipe/util/tracking/streaming_buffer.cc
@@ -14,6 +14,7 @@
 
 #include "mediapipe/util/tracking/streaming_buffer.h"
 
+#include "absl/log/absl_check.h"
 #include "absl/strings/str_cat.h"
 
 namespace mediapipe {
@@ -21,7 +22,7 @@ namespace mediapipe {
 StreamingBuffer::StreamingBuffer(
     const std::vector<TaggedType>& data_configuration, int overlap)
     : overlap_(overlap) {
-  CHECK_GE(overlap, 0);
+  ABSL_CHECK_GE(overlap, 0);
   for (auto& item : data_configuration) {
     CHECK(data_config_.find(item.first) == data_config_.end())
         << "Tag " << item.first << " already exists";
diff --git a/third_party/mediapipe/src/mediapipe/util/tracking/streaming_buffer.h b/third_party/mediapipe/src/mediapipe/util/tracking/streaming_buffer.h
index 41aadbbb5ad5f..bdaeb0cef05fa 100644
--- a/third_party/mediapipe/src/mediapipe/util/tracking/streaming_buffer.h
+++ b/third_party/mediapipe/src/mediapipe/util/tracking/streaming_buffer.h
@@ -23,6 +23,7 @@
 #include <vector>
 
 #include "absl/container/node_hash_map.h"
+#include "absl/log/absl_check.h"
 #include "absl/types/any.h"
 #include "mediapipe/framework/port/logging.h"
 #include "mediapipe/framework/tool/type_util.h"
@@ -324,7 +325,7 @@ template <class T>
 void StreamingBuffer::AddDatum(const std::string& tag,
                                std::unique_ptr<T> pointer) {
   CHECK(HasTag(tag));
-  CHECK_EQ(data_config_[tag], kTypeId<PointerType<T>>.hash_code());
+  ABSL_CHECK_EQ(data_config_[tag], kTypeId<PointerType<T>>.hash_code());
   auto& buffer = data_[tag];
   absl::any packet(PointerType<T>(CreatePointer(pointer.release())));
   buffer.push_back(packet);
@@ -344,7 +345,7 @@ void StreamingBuffer::AddDatumCopy(const std::string& tag, const T& datum) {
 template <class... Types>
 void StreamingBuffer::AddData(const std::vector<std::string>& tags,
                               std::unique_ptr<Types>... pointers) {
-  CHECK_EQ(tags.size(), sizeof...(pointers))
+  ABSL_CHECK_EQ(tags.size(), sizeof...(pointers))
       << "Number of tags and data pointers is inconsistent";
   return AddDataImpl(tags, std::move(pointers)...);
 }
@@ -387,7 +388,7 @@ T& StreamingBuffer::GetDatumRef(const std::string& tag, int frame_index) const {
 template <class T>
 T* StreamingBuffer::GetMutableDatum(const std::string& tag,
                                     int frame_index) const {
-  CHECK_GE(frame_index, 0);
+  ABSL_CHECK_GE(frame_index, 0);
   CHECK(HasTag(tag));
   auto& buffer = data_.find(tag)->second;
   if (frame_index > buffer.size()) {
@@ -488,7 +489,7 @@ template <class T>
 std::unique_ptr<T> StreamingBuffer::ReleaseDatum(const std::string& tag,
                                                  int frame_index) {
   CHECK(HasTag(tag));
-  CHECK_GE(frame_index, 0);
+  ABSL_CHECK_GE(frame_index, 0);
 
   auto& buffer = data_.find(tag)->second;
   if (frame_index >= buffer.size()) {
diff --git a/third_party/mediapipe/src/mediapipe/util/tracking/tone_estimation.cc b/third_party/mediapipe/src/mediapipe/util/tracking/tone_estimation.cc
index 587fe96f2ee80..2fdfa114a362d 100644
--- a/third_party/mediapipe/src/mediapipe/util/tracking/tone_estimation.cc
+++ b/third_party/mediapipe/src/mediapipe/util/tracking/tone_estimation.cc
@@ -21,6 +21,7 @@
 #include <numeric>
 #include <vector>
 
+#include "absl/log/absl_check.h"
 #include "mediapipe/util/tracking/motion_models.pb.h"
 #include "mediapipe/util/tracking/tone_models.pb.h"
 
@@ -58,7 +59,7 @@ ToneEstimation::ToneEstimation(const ToneEstimationOptions& options,
       break;
     }
     case ToneEstimationOptions::DOWNSAMPLE_BY_FACTOR: {
-      CHECK_GE(options_.downsample_factor(), 1);
+      ABSL_CHECK_GE(options_.downsample_factor(), 1);
       frame_width_ /= options_.downsample_factor();
       frame_height_ /= options_.downsample_factor();
       downsample_scale_ = options_.downsample_factor();
@@ -80,8 +81,8 @@ void ToneEstimation::EstimateToneChange(
     const RegionFlowFeatureList& feature_list_input,
     const cv::Mat& curr_frame_input, const cv::Mat* prev_frame_input,
     ToneChange* tone_change, cv::Mat* debug_output) {
-  CHECK_EQ(original_height_, curr_frame_input.rows);
-  CHECK_EQ(original_width_, curr_frame_input.cols);
+  ABSL_CHECK_EQ(original_height_, curr_frame_input.rows);
+  ABSL_CHECK_EQ(original_width_, curr_frame_input.cols);
   CHECK(tone_change != nullptr);
 
   const cv::Mat& curr_frame =
@@ -106,8 +107,8 @@ void ToneEstimation::EstimateToneChange(
     TransformRegionFlowFeatureList(scale_transform, &scaled_feature_list);
   }
 
-  CHECK_EQ(frame_height_, curr_frame.rows);
-  CHECK_EQ(frame_width_, curr_frame.cols);
+  ABSL_CHECK_EQ(frame_height_, curr_frame.rows);
+  ABSL_CHECK_EQ(frame_width_, curr_frame.cols);
 
   ClipMask<3> curr_clip;
   ComputeClipMask<3>(options_.clip_mask_options(), curr_frame, &curr_clip);
@@ -219,8 +220,8 @@ void ToneEstimation::EstimateGainBiasModel(int irls_iterations,
   float solution_ptr[6] = {1.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f};
 
   const int num_channels = color_tone_matches->size();
-  CHECK_GT(num_channels, 0);
-  CHECK_LE(num_channels, 3);
+  ABSL_CHECK_GT(num_channels, 0);
+  ABSL_CHECK_LE(num_channels, 3);
 
   // TODO: One IRLS weight per color match.
   for (int c = 0; c < num_channels; ++c) {
diff --git a/third_party/mediapipe/src/mediapipe/util/tracking/tone_estimation.h b/third_party/mediapipe/src/mediapipe/util/tracking/tone_estimation.h
index 0fa049e2bc685..9f37cdd374b1e 100644
--- a/third_party/mediapipe/src/mediapipe/util/tracking/tone_estimation.h
+++ b/third_party/mediapipe/src/mediapipe/util/tracking/tone_estimation.h
@@ -25,6 +25,7 @@
 #include <memory>
 #include <vector>
 
+#include "absl/log/absl_check.h"
 #include "mediapipe/framework/port/integral_types.h"
 #include "mediapipe/framework/port/logging.h"
 #include "mediapipe/framework/port/opencv_core_inc.h"
@@ -151,7 +152,7 @@ void ToneEstimation::ComputeClipMask(const ClipMaskOptions& options,
                                      const cv::Mat& frame,
                                      ClipMask<C>* clip_mask) {
   CHECK(clip_mask != nullptr);
-  CHECK_EQ(frame.channels(), C);
+  ABSL_CHECK_EQ(frame.channels(), C);
 
   // Over / Underexposure handling.
   // Masks pixels affected by clipping.
@@ -163,7 +164,7 @@ void ToneEstimation::ComputeClipMask(const ClipMaskOptions& options,
 
   std::vector<cv::Mat> planes;
   cv::split(frame, planes);
-  CHECK_EQ(C, planes.size());
+  ABSL_CHECK_EQ(C, planes.size());
   float min_exposure[C];
   float max_exposure[C];
   for (int c = 0; c < C; ++c) {
@@ -224,8 +225,8 @@ void ToneEstimation::ComputeToneMatches(
     const ClipMask<C>& prev_clip_mask,  // Optional.
     ColorToneMatches* color_tone_matches, cv::Mat* debug_output) {
   CHECK(color_tone_matches != nullptr);
-  CHECK_EQ(curr_frame.channels(), C);
-  CHECK_EQ(prev_frame.channels(), C);
+  ABSL_CHECK_EQ(curr_frame.channels(), C);
+  ABSL_CHECK_EQ(prev_frame.channels(), C);
 
   color_tone_matches->clear();
   color_tone_matches->resize(C);
diff --git a/third_party/mediapipe/src/mediapipe/util/tracking/tone_models.cc b/third_party/mediapipe/src/mediapipe/util/tracking/tone_models.cc
index 9410834bdd129..4ab896a5644a7 100644
--- a/third_party/mediapipe/src/mediapipe/util/tracking/tone_models.cc
+++ b/third_party/mediapipe/src/mediapipe/util/tracking/tone_models.cc
@@ -16,6 +16,7 @@
 
 #include <cmath>
 
+#include "absl/log/absl_check.h"
 #include "absl/strings/str_format.h"
 
 namespace mediapipe {
@@ -50,10 +51,10 @@ void ToneModelMethods<Model, Adapter>::MapImage(const Model& model,
   CHECK(output != nullptr);
 
   const int out_channels = output->channels();
-  CHECK_EQ(input.channels(), 3);
-  CHECK_LE(out_channels, 3);
-  CHECK_EQ(input.rows, output->rows);
-  CHECK_EQ(input.cols, output->cols);
+  ABSL_CHECK_EQ(input.channels(), 3);
+  ABSL_CHECK_LE(out_channels, 3);
+  ABSL_CHECK_EQ(input.rows, output->rows);
+  ABSL_CHECK_EQ(input.cols, output->cols);
 
   float norm_scale =
       normalized_model
diff --git a/third_party/mediapipe/src/mediapipe/util/tracking/tone_models.h b/third_party/mediapipe/src/mediapipe/util/tracking/tone_models.h
index 266257e1fcc85..17b4427ae39e3 100644
--- a/third_party/mediapipe/src/mediapipe/util/tracking/tone_models.h
+++ b/third_party/mediapipe/src/mediapipe/util/tracking/tone_models.h
@@ -23,6 +23,7 @@
 #include <string>
 #include <vector>
 
+#include "absl/log/absl_check.h"
 #include "mediapipe/framework/port/integral_types.h"
 #include "mediapipe/framework/port/logging.h"
 #include "mediapipe/framework/port/opencv_core_inc.h"
@@ -593,8 +594,8 @@ void ToneModelMethods<Model, Adapter>::MapImageIndependent(
     const Model& model, bool log_domain, bool normalized_model,
     const cv::Mat& input, cv::Mat* output) {
   CHECK(output != nullptr);
-  CHECK_EQ(input.channels(), C);
-  CHECK_EQ(output->channels(), C);
+  ABSL_CHECK_EQ(input.channels(), C);
+  ABSL_CHECK_EQ(output->channels(), C);
 
   // Input LUT which will be mapped to the output LUT by the tone change model.
   // Needs 3 channels to represent input RGB colors, but since they are assumed
diff --git a/third_party/mediapipe/src/mediapipe/util/tracking/tracking.cc b/third_party/mediapipe/src/mediapipe/util/tracking/tracking.cc
index 50aaa940cfe41..efac37dd0d35b 100644
--- a/third_party/mediapipe/src/mediapipe/util/tracking/tracking.cc
+++ b/third_party/mediapipe/src/mediapipe/util/tracking/tracking.cc
@@ -25,6 +25,7 @@
 #include "Eigen/Dense"
 #include "Eigen/SVD"
 #include "absl/algorithm/container.h"
+#include "absl/log/absl_check.h"
 #include "absl/memory/memory.h"
 #include "mediapipe/framework/port/logging.h"
 #include "mediapipe/framework/port/opencv_calib3d_inc.h"
@@ -63,7 +64,7 @@ void StoreInternalState(const std::vector<const MotionVector*>& vectors,
                         const std::vector<float>& inlier_weights,
                         float aspect_ratio, MotionBoxInternalState* internal) {
   const int num_vectors = vectors.size();
-  CHECK_EQ(num_vectors, inlier_weights.size());
+  ABSL_CHECK_EQ(num_vectors, inlier_weights.size());
 
   float scale_x = 1.0f;
   float scale_y = 1.0f;
@@ -171,7 +172,7 @@ bool LinearSimilarityL2Solve(
   matrix.setTo(0);
   rhs.setTo(0);
 
-  CHECK_EQ(motion_vectors.size(), weights.size());
+  ABSL_CHECK_EQ(motion_vectors.size(), weights.size());
   for (int k = 0; k < motion_vectors.size(); ++k) {
     const float x = motion_vectors[k]->pos.x();
     const float y = motion_vectors[k]->pos.y();
@@ -245,7 +246,7 @@ bool HomographyL2Solve(const std::vector<const MotionVector*>& motion_vectors,
 
   // Matrix multiplications are hand-coded for speed improvements vs.
   // opencv's cvGEMM calls.
-  CHECK_EQ(motion_vectors.size(), weights.size());
+  ABSL_CHECK_EQ(motion_vectors.size(), weights.size());
   for (int k = 0; k < motion_vectors.size(); ++k) {
     const float x = motion_vectors[k]->pos.x();
     const float y = motion_vectors[k]->pos.y();
@@ -828,7 +829,7 @@ void InitializePnpHomographyInMotionBoxState(
   }
 
   const int kQuadCornersSize = 4;
-  CHECK_EQ(state->quad().vertices_size(), kQuadCornersSize * 2);
+  ABSL_CHECK_EQ(state->quad().vertices_size(), kQuadCornersSize * 2);
   float scale_x, scale_y;
   ScaleFromAspect(tracking.frame_aspect(), false, &scale_x, &scale_y);
   std::vector<cv::Point2f> corners_2d(kQuadCornersSize);
@@ -910,7 +911,7 @@ void InitializePnpHomographyInMotionBoxState(
     state->set_aspect_ratio(width_norm / height_norm);
   }
 
-  CHECK_GT(state->aspect_ratio(), 0.0f);
+  ABSL_CHECK_GT(state->aspect_ratio(), 0.0f);
 
   const float half_width = state->aspect_ratio();
   const float half_height = 1.0f;
@@ -973,7 +974,7 @@ void ScaleStateAspect(float aspect, bool invert, MotionBoxState* state) {
 
 MotionVector MotionVector::FromInternalState(
     const MotionBoxInternalState& internal, int index) {
-  CHECK_LT(index, internal.pos_x_size());
+  ABSL_CHECK_LT(index, internal.pos_x_size());
   MotionVector v;
   v.pos = Vector2_f(internal.pos_x(index), internal.pos_y(index));
   v.object = Vector2_f(internal.dx(index), internal.dy(index));
@@ -1150,7 +1151,7 @@ void ComputeSpatialPrior(bool interpolate, bool use_next_position,
   std::vector<float> old_confidence(update_pos->spatial_confidence().begin(),
                                     update_pos->spatial_confidence().end());
 
-  CHECK_EQ(old_confidence.size(), old_prior.size());
+  ABSL_CHECK_EQ(old_confidence.size(), old_prior.size());
   CHECK(old_confidence.empty() ||
         grid_size * grid_size == old_confidence.size())
       << "Empty or priors of constant size expected";
@@ -1192,10 +1193,10 @@ void ComputeSpatialPrior(bool interpolate, bool use_next_position,
       const int int_x = static_cast<int>(grid_pos.x());
       const int int_y = static_cast<int>(grid_pos.y());
 
-      CHECK_GE(grid_pos.x(), 0) << pos.x() << ", " << update_pos->pos_x();
-      CHECK_GE(grid_pos.y(), 0);
-      CHECK_LE(grid_pos.x(), grid_size - 1);
-      CHECK_LE(grid_pos.y(), grid_size - 1);
+      ABSL_CHECK_GE(grid_pos.x(), 0) << pos.x() << ", " << update_pos->pos_x();
+      ABSL_CHECK_GE(grid_pos.y(), 0);
+      ABSL_CHECK_LE(grid_pos.x(), grid_size - 1);
+      ABSL_CHECK_LE(grid_pos.y(), grid_size - 1);
 
       const float dx = grid_pos.x() - int_x;
       const float dy = grid_pos.y() - int_y;
@@ -1431,8 +1432,8 @@ MotionBox::DistanceWeightsComputer::DistanceWeightsComputer(
   tracking_degrees_ = options.tracking_degrees();
   const Vector2_f box_domain(current_state.width() * current_state.scale(),
                              current_state.height() * current_state.scale());
-  CHECK_GT(box_domain.x(), 0.0f);
-  CHECK_GT(box_domain.y(), 0.0f);
+  ABSL_CHECK_GT(box_domain.x(), 0.0f);
+  ABSL_CHECK_GT(box_domain.y(), 0.0f);
   inv_box_domain_ = Vector2_f(1.0f / box_domain.x(), 1.0f / box_domain.y());
 
   // Space sigma depends on how much the tracked object fills the rectangle.
@@ -1575,8 +1576,8 @@ bool MotionBox::GetVectorsAndWeights(
   const Vector2_f box_domain(box_state.width() * box_state.scale(),
                              box_state.height() * box_state.scale());
 
-  CHECK_GT(box_domain.x(), 0.0f);
-  CHECK_GT(box_domain.y(), 0.0f);
+  ABSL_CHECK_GT(box_domain.x(), 0.0f);
+  ABSL_CHECK_GT(box_domain.y(), 0.0f);
   const Vector2_f inv_box_domain(1.0f / box_domain.x(), 1.0f / box_domain.y());
 
   // The four lines of the rotated and scaled box.
@@ -1670,8 +1671,8 @@ bool MotionBox::GetVectorsAndWeights(
     is_outlier.push_back(is_outlier_flag);
   }
 
-  CHECK_EQ(vectors->size(), is_inlier.size());
-  CHECK_EQ(vectors->size(), is_outlier.size());
+  ABSL_CHECK_EQ(vectors->size(), is_inlier.size());
+  ABSL_CHECK_EQ(vectors->size(), is_outlier.size());
 
   const float prev_motion_mag = MotionBoxVelocity(box_state).Norm();
 
@@ -1814,7 +1815,7 @@ bool MotionBox::GetVectorsAndWeights(
   }
 
   const int num_vectors = vectors->size();
-  CHECK_EQ(num_vectors, weights->size());
+  ABSL_CHECK_EQ(num_vectors, weights->size());
 
   const float weight_sum =
       std::accumulate(weights->begin(), weights->end(), 0.0f);
@@ -1917,8 +1918,8 @@ void MotionBox::EstimateObjectMotion(
   CHECK(object_homography);
 
   const int num_vectors = motion_vectors.size();
-  CHECK_EQ(num_vectors, prior_weights.size());
-  CHECK_EQ(num_vectors, weights->size());
+  ABSL_CHECK_EQ(num_vectors, prior_weights.size());
+  ABSL_CHECK_EQ(num_vectors, weights->size());
 
   // Create backup of weights if needed.
   std::vector<float> similarity_weights;
@@ -2440,8 +2441,8 @@ void MotionBox::ComputeInlierCenterAndExtent(
   float weight_sum = 0;
   float inlier_sum = 0;
   const int num_vectors = motion_vectors.size();
-  CHECK_EQ(num_vectors, weights.size());
-  CHECK_EQ(num_vectors, density.size());
+  ABSL_CHECK_EQ(num_vectors, weights.size());
+  ABSL_CHECK_EQ(num_vectors, density.size());
 
   Vector2_f first_moment(0.0f, 0.0f);
   Vector2_f second_moment(0.0f, 0.0f);
@@ -2498,7 +2499,7 @@ float MotionBox::ScaleEstimate(
     const std::vector<const MotionVector*>& motion_vectors,
     const std::vector<float>& weights, float min_sum) const {
   const int num_vectors = motion_vectors.size();
-  CHECK_EQ(num_vectors, weights.size());
+  ABSL_CHECK_EQ(num_vectors, weights.size());
 
   float scale_sum = 0;
 
@@ -2793,7 +2794,7 @@ void MotionBox::TrackStepImplDeNormalized(
   VLOG(1) << "Good inits: " << num_good_inits;
 
   const int num_vectors = vectors.size();
-  CHECK_EQ(num_vectors, prior_weights.size());
+  ABSL_CHECK_EQ(num_vectors, prior_weights.size());
 
   Vector2_f object_translation;
 
diff --git a/third_party/mediapipe/src/mediapipe/util/tracking/tracking.h b/third_party/mediapipe/src/mediapipe/util/tracking/tracking.h
index 4d3343f583e54..248d20bcb83f0 100644
--- a/third_party/mediapipe/src/mediapipe/util/tracking/tracking.h
+++ b/third_party/mediapipe/src/mediapipe/util/tracking/tracking.h
@@ -26,6 +26,7 @@
 #include <vector>
 
 #include "absl/container/flat_hash_set.h"
+#include "absl/log/absl_check.h"
 #include "mediapipe/framework/port/vector.h"
 #include "mediapipe/util/tracking/flow_packager.pb.h"
 #include "mediapipe/util/tracking/motion_models.h"
@@ -122,7 +123,7 @@ inline void MotionBoxInliers(const MotionBoxState& state,
                              std::unordered_map<int, int>* inliers) {
   CHECK(inliers);
   const int num_inliers = state.inlier_ids_size();
-  DCHECK_EQ(num_inliers, state.inlier_length_size());
+  ABSL_DCHECK_EQ(num_inliers, state.inlier_length_size());
 
   for (int k = 0; k < num_inliers; ++k) {
     (*inliers)[state.inlier_ids(k)] =
@@ -572,7 +573,7 @@ class MotionBox {
     // Check if it is a convex quad.
     static bool IsValidQuad(const MotionBoxState::Quad& quad) {
       const int kQuadVerticesSize = 8;
-      CHECK_EQ(quad.vertices_size(), kQuadVerticesSize);
+      ABSL_CHECK_EQ(quad.vertices_size(), kQuadVerticesSize);
       for (int a = 0; a < kQuadVerticesSize; a += 2) {
         int b = (a + 2) % kQuadVerticesSize;
         int c = (a - 2 + kQuadVerticesSize) % kQuadVerticesSize;
@@ -595,7 +596,7 @@ class MotionBox {
     static bool IsQuadOutOfFov(const MotionBoxState::Quad& quad,
                                const Vector2_f& fov) {
       const int kQuadVerticesSize = 8;
-      CHECK_EQ(quad.vertices_size(), kQuadVerticesSize);
+      ABSL_CHECK_EQ(quad.vertices_size(), kQuadVerticesSize);
       bool too_far = true;
       for (int j = 0; j < kQuadVerticesSize; j += 2) {
         if (quad.vertices(j) < fov.x() && quad.vertices(j) > 0.0f &&
